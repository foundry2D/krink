diff --git a/flecs.c b/flecs.c
index 73691fb2..98d59322 100644
--- a/flecs.c
+++ b/flecs.c
@@ -142,7 +142,7 @@ void flecs_bitset_swap(
  * @file switch_list.h
  * @brief Interleaved linked list for storing mutually exclusive values.
  *
- * Datastructure that stores N interleaved linked lists in an array. 
+ * Datastructure that stores N interleaved linked lists in an array.
  * This allows for efficient storage of elements with mutually exclusive values.
  * Each linked list has a header element which points to the index in the array
  * that stores the first node of the list. Each list node points to the next
@@ -187,7 +187,7 @@ struct ecs_switch_t {
 /** Create new switch. */
 FLECS_DBG_API
 ecs_switch_t* flecs_switch_new(
-    uint64_t min, 
+    uint64_t min,
     uint64_t max,
     int32_t elements);
 
@@ -217,7 +217,7 @@ void flecs_switch_ensure(
 FLECS_DBG_API
 void flecs_switch_addn(
     ecs_switch_t *sw,
-    int32_t count);    
+    int32_t count);
 
 /** Set value of element. */
 FLECS_DBG_API
@@ -248,7 +248,7 @@ void flecs_switch_swap(
 /** Get vector with all values. Use together with count(). */
 FLECS_DBG_API
 ecs_vector_t* flecs_switch_values(
-    const ecs_switch_t *sw);    
+    const ecs_switch_t *sw);
 
 /** Return number of different values. */
 FLECS_DBG_API
@@ -310,7 +310,7 @@ typedef enum ecs_mixin_kind_t {
 struct ecs_mixins_t {
     const char *type_name; /* Include name of mixin type so debug code doesn't
                             * need to know about every object */
-    ecs_size_t elems[EcsMixinMax];                        
+    ecs_size_t elems[EcsMixinMax];
 };
 
 /* Mixin tables */
@@ -360,7 +360,7 @@ typedef struct ecs_table_event_t {
     /* If the nubmer of fields gets out of hand, this can be turned into a union
      * but since events are very temporary objects, this works for now and makes
      * initializing an event a bit simpler. */
-} ecs_table_event_t;    
+} ecs_table_event_t;
 
 /** A component column. */
 struct ecs_column_t {
@@ -419,7 +419,7 @@ typedef struct ecs_table_diff_t {
     ecs_ids_t added;         /* Components added between tables */
     ecs_ids_t removed;       /* Components removed between tables */
     ecs_ids_t on_set;        /* OnSet from exposing/adding base components */
-    ecs_ids_t un_set;        /* UnSet from hiding/removing base components */   
+    ecs_ids_t un_set;        /* UnSet from hiding/removing base components */
 } ecs_table_diff_t;
 
 /** Single edge. */
@@ -440,7 +440,7 @@ typedef struct ecs_graph_node_t {
     ecs_graph_edges_t add;
     ecs_graph_edges_t remove;
 
-    /* Metadata that keeps track of id diffs for non-trivial edges */ 
+    /* Metadata that keeps track of id diffs for non-trivial edges */
     ecs_vector_t *diffs;
 } ecs_graph_node_t;
 
@@ -495,7 +495,7 @@ typedef struct ecs_table_cache_hdr_t {
 /* Sparse query column */
 typedef struct flecs_sparse_column_t {
     ecs_sw_column_t *sw_column;
-    ecs_entity_t sw_case; 
+    ecs_entity_t sw_case;
     int32_t signature_column_index;
 } flecs_sparse_column_t;
 
@@ -518,7 +518,7 @@ struct ecs_query_table_node_t {
     ecs_query_table_node_t *next, *prev;
 };
 
-/** Type containing data for a table matched with a query. 
+/** Type containing data for a table matched with a query.
  * A single table can have multiple matches, if the query contains wildcards. */
 struct ecs_query_table_match_t {
     ecs_query_table_node_t node; /* Embedded list node */
@@ -556,7 +556,7 @@ typedef struct ecs_query_table_list_t {
     int32_t count;
 } ecs_query_table_list_t;
 
-#define EcsQueryNeedsTables (1)      /* Query needs matching with tables */ 
+#define EcsQueryNeedsTables (1)      /* Query needs matching with tables */
 #define EcsQueryMatchDisabled (16)   /* Does query match disabled */
 #define EcsQueryMatchPrefab (32)     /* Does query match prefabs */
 #define EcsQueryHasRefs (64)         /* Does query have references */
@@ -606,7 +606,7 @@ struct ecs_query_t {
     /* Used for sorting */
     ecs_entity_t order_by_component;
     ecs_order_by_action_t order_by;
-    ecs_vector_t *table_slices;     
+    ecs_vector_t *table_slices;
 
     /* Used for grouping */
     ecs_entity_t group_by_id;
@@ -658,7 +658,7 @@ typedef enum ecs_defer_op_kind_t {
     EcsOpClone,
     EcsOpBulkNew,
     EcsOpAdd,
-    EcsOpRemove,   
+    EcsOpRemove,
     EcsOpSet,
     EcsOpMut,
     EcsOpModified,
@@ -673,16 +673,16 @@ typedef struct ecs_defer_op_1_t {
     ecs_entity_t entity;        /* Entity id */
     void *value;                /* Value (used for set / get_mut) */
     ecs_size_t size;            /* Size of value */
-    bool clone_value;           /* Clone entity with value (used for clone) */ 
+    bool clone_value;           /* Clone entity with value (used for clone) */
 } ecs_defer_op_1_t;
 
 typedef struct ecs_defer_op_n_t {
-    ecs_entity_t *entities;  
+    ecs_entity_t *entities;
     int32_t count;
 } ecs_defer_op_n_t;
 
 typedef struct ecs_defer_op_t {
-    ecs_defer_op_kind_t kind;         /* Operation kind */    
+    ecs_defer_op_kind_t kind;         /* Operation kind */
     ecs_id_t id;                /* (Component) id */
     union {
         ecs_defer_op_1_t _1;
@@ -835,15 +835,15 @@ struct ecs_world_t {
     ecs_sparse_t *queries;       /* sparse<query_id, ecs_query_t> */
     ecs_sparse_t *triggers;      /* sparse<query_id, ecs_trigger_t> */
     ecs_sparse_t *observers;     /* sparse<query_id, ecs_observer_t> */
-    
+
 
     /* Keep track of components that were added/removed to/from monitored
      * entities. Monitored entities are entities that are directly referenced by
-     * a query, either explicitly (e.g. Position(Foo)) or implicitly 
+     * a query, either explicitly (e.g. Position(Foo)) or implicitly
      * (Position(supser)).
      * When these entities change type, queries may have to be rematched.
      * Queries register themselves as component monitors for specific components
-     * and when these components change they are rematched. The component 
+     * and when these components change they are rematched. The component
      * monitors are evaluated during a merge. */
     ecs_relation_monitor_t monitors;
 
@@ -899,7 +899,7 @@ struct ecs_world_t {
 
 
     /* -- Defered operation count -- */
-    
+
     int32_t new_count;
     int32_t bulk_new_count;
     int32_t delete_count;
@@ -918,7 +918,7 @@ struct ecs_world_t {
     bool measure_frame_time;     /* Time spent on each frame */
     bool measure_system_time;    /* Time spent by each system */
     bool should_quit;            /* Did a system signal that app should quit */
-    bool locking_enabled;        /* Lock world when in progress */ 
+    bool locking_enabled;        /* Lock world when in progress */
 
     void *context;               /* Application context */
     ecs_vector_t *fini_actions;  /* Callbacks to execute when world exits */
@@ -1019,7 +1019,7 @@ void _ecs_table_cache_fini_delete_all(
 
 #endif
 
-/* From: https://github.com/svpv/qsort/blob/master/qsort.h 
+/* From: https://github.com/svpv/qsort/blob/master/qsort.h
  * Use custom qsort implementation rather than relying on the version in libc to
  * ensure that results are consistent across platforms.
  */
@@ -1208,9 +1208,9 @@ do {									\
 } while (0)
 
 void ecs_qsort(
-    void *base, 
-    ecs_size_t nitems, 
-    ecs_size_t size, 
+    void *base,
+    ecs_size_t nitems,
+    ecs_size_t size,
     int (*compar)(const void *, const void*));
 
 #define ecs_qsort_t(base, nitems, T, compar) \
@@ -1423,7 +1423,7 @@ void flecs_stage_deinit(
 /* Post-frame merge actions */
 void flecs_stage_merge_post_frame(
     ecs_world_t *world,
-    ecs_stage_t *stage);  
+    ecs_stage_t *stage);
 
 /* Delete table from stage */
 void flecs_delete_table(
@@ -1486,7 +1486,7 @@ bool flecs_defer_enable(
     ecs_stage_t *stage,
     ecs_entity_t entity,
     ecs_entity_t component,
-    bool enable);    
+    bool enable);
 
 bool flecs_defer_add(
     ecs_world_t *world,
@@ -1522,7 +1522,7 @@ bool flecs_defer_purge(
 
 ////////////////////////////////////////////////////////////////////////////////
 //// Notifications
-//////////////////////////////////////////////////////////////////////////////// 
+////////////////////////////////////////////////////////////////////////////////
 
 void flecs_notify_on_remove(
     ecs_world_t *world,
@@ -1553,7 +1553,7 @@ ecs_table_t* flecs_table_find_or_create(
 /* Initialize columns for data */
 void flecs_table_init_data(
     ecs_world_t *world,
-    ecs_table_t *table); 
+    ecs_table_t *table);
 
 /* Clear all entities from a table. */
 void flecs_table_clear_entities(
@@ -1574,7 +1574,7 @@ void flecs_table_clear_entities_silent(
 void flecs_table_clear_data(
     ecs_world_t *world,
     ecs_table_t *table,
-    ecs_data_t *data);    
+    ecs_data_t *data);
 
 /* Return number of entities in data */
 int32_t flecs_table_data_count(
@@ -1646,12 +1646,12 @@ void flecs_table_remove_actions(
 /* Free table */
 void flecs_table_free(
     ecs_world_t *world,
-    ecs_table_t *table); 
+    ecs_table_t *table);
 
 /* Free table */
 void flecs_table_free_type(
-    ecs_table_t *table);     
-    
+    ecs_table_t *table);
+
 /* Replace data */
 void flecs_table_replace_data(
     ecs_world_t *world,
@@ -1697,7 +1697,7 @@ const EcsComponent* flecs_component_from_id(
 int32_t flecs_table_switch_from_case(
     const ecs_world_t *world,
     const ecs_table_t *table,
-    ecs_entity_t add);    
+    ecs_entity_t add);
 
 void flecs_table_notify(
     ecs_world_t *world,
@@ -1936,17 +1936,17 @@ uint64_t flecs_from_row(
 
 /* Get actual row from record row */
 uint32_t flecs_record_to_row(
-    uint32_t row, 
+    uint32_t row,
     bool *is_watched_out);
 
 /* Convert actual row to record row */
 uint32_t flecs_row_to_record(
-    uint32_t row, 
+    uint32_t row,
     bool is_watched);
 
 /* Convert type to entity array */
 ecs_ids_t flecs_type_to_ids(
-    ecs_type_t type); 
+    ecs_type_t type);
 
 /* Convert a symbol name to an entity name by removing the prefix */
 const char* flecs_name_from_symbol(
@@ -1955,10 +1955,10 @@ const char* flecs_name_from_symbol(
 
 /* Compare function for entity ids */
 int flecs_entity_compare(
-    ecs_entity_t e1, 
-    const void *ptr1, 
-    ecs_entity_t e2, 
-    const void *ptr2); 
+    ecs_entity_t e1,
+    const void *ptr1,
+    ecs_entity_t e2,
+    const void *ptr2);
 
 /* Compare function for entity ids which can be used with qsort */
 int flecs_entity_compare_qsort(
@@ -1967,8 +1967,8 @@ int flecs_entity_compare_qsort(
 
 /* Convert floating point to string */
 char * ecs_ftoa(
-    double f, 
-    char * buf, 
+    double f,
+    char * buf,
     int precision);
 
 uint64_t flecs_string_hash(
@@ -2104,8 +2104,8 @@ void init_storage_table(
     for (i = 0; i < count; i ++) {
         ecs_id_t id = ids[i];
 
-        if ((id == ecs_id(EcsComponent)) || 
-            (ECS_PAIR_RELATION(id) == ecs_id(EcsIdentifier))) 
+        if ((id == ecs_id(EcsComponent)) ||
+            (ECS_PAIR_RELATION(id) == ecs_id(EcsIdentifier)))
         {
             storage_ids.array[storage_ids.count ++] = id;
             continue;
@@ -2118,7 +2118,7 @@ void init_storage_table(
 
         storage_ids.array[storage_ids.count ++] = id;
     }
-    
+
     if (storage_ids.count && storage_ids.count != count) {
         table->storage_table = flecs_table_find_or_create(world, &storage_ids);
         table->storage_type = table->storage_table->type;
@@ -2198,8 +2198,8 @@ void flecs_table_init_data(
             int32_t sw_array_count = ecs_vector_count(sw_type);
 
             ecs_switch_t *sw = flecs_switch_new(
-                sw_array[0], 
-                sw_array[sw_array_count - 1], 
+                sw_array[0],
+                sw_array[sw_array_count - 1],
                 0);
 
             storage->sw_columns[i].data = sw;
@@ -2217,7 +2217,7 @@ void flecs_table_init_data(
 
 static
 ecs_flags32_t get_component_action_flags(
-    const ecs_type_info_t *c_info) 
+    const ecs_type_info_t *c_info)
 {
     ecs_flags32_t flags = 0;
 
@@ -2232,9 +2232,9 @@ ecs_flags32_t get_component_action_flags(
     }
     if (c_info->lifecycle.move) {
         flags |= EcsTableHasMove;
-    }  
+    }
 
-    return flags;  
+    return flags;
 }
 
 /* Check if table has instance of component, including pairs */
@@ -2252,7 +2252,7 @@ bool has_component(
             return true;
         }
     }
-    
+
     return false;
 }
 
@@ -2270,7 +2270,7 @@ void notify_component_info(
         if (!column_count) {
             return;
         }
-        
+
         if (!table->c_info) {
             table->c_info = ecs_os_calloc(
                 ECS_SIZEOF(ecs_type_info_t*) * column_count);
@@ -2295,7 +2295,7 @@ void notify_component_info(
                 c = ecs_get_typeid(world, array[i]);
             }
             ecs_assert(c != 0, ECS_INTERNAL_ERROR, NULL);
-            
+
             const ecs_type_info_t *c_info = flecs_get_c_info(world, c);
             if (c_info) {
                 ecs_flags32_t flags = get_component_action_flags(c_info);
@@ -2304,15 +2304,15 @@ void notify_component_info(
 
             /* Store pointer to c_info for fast access */
             table->c_info[i] = (ecs_type_info_t*)c_info;
-        }        
+        }
     }
 }
 
 static
 void notify_trigger(
-    ecs_world_t *world, 
-    ecs_table_t *table, 
-    ecs_entity_t event) 
+    ecs_world_t *world,
+    ecs_table_t *table,
+    ecs_entity_t event)
 {
     (void)world;
 
@@ -2344,7 +2344,7 @@ void run_on_remove(
             .removed = removed,
             .un_set = removed
         };
-        
+
         flecs_notify_on_remove(world, table, NULL, 0, count, &diff);
     }
 }
@@ -2395,7 +2395,7 @@ void ctor_component(
 
         void *ptr = ecs_vector_get_t(column->data, size, alignment, row);
 
-        ctor(world, cdata->component, entities, ptr, 
+        ctor(world, cdata->component, entities, ptr,
             flecs_itosize(size), count, ctx);
     }
 }
@@ -2412,7 +2412,7 @@ void dtor_component(
     if (!count) {
         return;
     }
-    
+
     /* An old component is destructed */
     ecs_xtor_t dtor;
     if (cdata && (dtor = cdata->lifecycle.dtor)) {
@@ -2470,21 +2470,21 @@ void dtor_all_components(
              * be safely used in destructor callbacks. */
             if (update_entity_index) {
                 ecs_entity_t e = entities[i];
-                ecs_assert(!e || ecs_is_valid(world, e), 
+                ecs_assert(!e || ecs_is_valid(world, e),
                     ECS_INTERNAL_ERROR, NULL);
-                ecs_assert(!e || records[i] == ecs_eis_get(world, e), 
+                ecs_assert(!e || records[i] == ecs_eis_get(world, e),
                     ECS_INTERNAL_ERROR, NULL);
-                ecs_assert(!e || records[i]->table == table, 
+                ecs_assert(!e || records[i]->table == table,
                     ECS_INTERNAL_ERROR, NULL);
 
                 if (is_delete) {
                     ecs_eis_delete(world, e);
-                    ecs_assert(ecs_is_valid(world, e) == false, 
+                    ecs_assert(ecs_is_valid(world, e) == false,
                         ECS_INTERNAL_ERROR, NULL);
                 } else {
                     // If this is not a delete, clear the entity index record
                     ecs_record_t r = {NULL, 0};
-                    ecs_eis_set(world, e, &r);                
+                    ecs_eis_set(world, e, &r);
                 }
             } else {
                 /* This should only happen in rare cases, such as when the data
@@ -2493,7 +2493,7 @@ void dtor_all_components(
         }
 
         table->lock = false;
-    
+
         ecs_defer_end(world);
 
     /* If table does not have destructors, just update entity index */
@@ -2502,26 +2502,26 @@ void dtor_all_components(
             for (i = row; i < end; i ++) {
                 ecs_entity_t e = entities[i];
                 ecs_assert(!e || ecs_is_valid(world, e), ECS_INTERNAL_ERROR, NULL);
-                ecs_assert(!e || records[i] == ecs_eis_get(world, e), 
+                ecs_assert(!e || records[i] == ecs_eis_get(world, e),
                     ECS_INTERNAL_ERROR, NULL);
-                ecs_assert(!e || records[i]->table == table, 
+                ecs_assert(!e || records[i]->table == table,
                     ECS_INTERNAL_ERROR, NULL);
 
                 ecs_eis_delete(world, e);
                 ecs_assert(!ecs_is_valid(world, e), ECS_INTERNAL_ERROR, NULL);
-            } 
+            }
         } else {
             for (i = row; i < end; i ++) {
                 ecs_entity_t e = entities[i];
                 ecs_assert(!e || ecs_is_valid(world, e), ECS_INTERNAL_ERROR, NULL);
-                ecs_assert(!e || records[i] == ecs_eis_get(world, e), 
+                ecs_assert(!e || records[i] == ecs_eis_get(world, e),
+                    ECS_INTERNAL_ERROR, NULL);
+                ecs_assert(!e || records[i]->table == table,
                     ECS_INTERNAL_ERROR, NULL);
-                ecs_assert(!e || records[i]->table == table, 
-                    ECS_INTERNAL_ERROR, NULL);                
                 ecs_record_t r = {NULL, 0};
                 ecs_eis_set(world, e, &r);
             }
-        }      
+        }
     }
 }
 
@@ -2542,17 +2542,17 @@ void fini_data(
     }
 
     if (do_on_remove) {
-        run_on_remove(world, table, data);        
+        run_on_remove(world, table, data);
     }
 
     int32_t count = flecs_table_data_count(data);
     if (count) {
-        dtor_all_components(world, table, data, 0, count, 
+        dtor_all_components(world, table, data, 0, count,
             update_entity_index, is_delete);
     }
 
     /* Sanity check */
-    ecs_assert(ecs_vector_count(data->record_ptrs) == 
+    ecs_assert(ecs_vector_count(data->record_ptrs) ==
         ecs_vector_count(data->entities), ECS_INTERNAL_ERROR, NULL);
 
     ecs_column_t *columns = data->columns;
@@ -2560,7 +2560,7 @@ void fini_data(
         int32_t c, column_count = ecs_vector_count(table->storage_type);
         for (c = 0; c < column_count; c ++) {
             /* Sanity check */
-            ecs_assert(!columns[c].data || (ecs_vector_count(columns[c].data) == 
+            ecs_assert(!columns[c].data || (ecs_vector_count(columns[c].data) ==
                 ecs_vector_count(data->entities)), ECS_INTERNAL_ERROR, NULL);
 
             ecs_vector_free(columns[c].data);
@@ -2633,7 +2633,7 @@ void flecs_table_delete_entities(
     fini_data(world, table, &table->storage, true, true, true, true);
 }
 
-/* Unset all components in table. This function is called before a table is 
+/* Unset all components in table. This function is called before a table is
  * deleted, and invokes all UnSet handlers, if any */
 void flecs_table_remove_actions(
     ecs_world_t *world,
@@ -2655,7 +2655,7 @@ void flecs_table_free(
     char *expr = ecs_type_str(world, table->type);
     ecs_dbg_2("#[green]table#[reset] [%s] deleted", expr);
     ecs_os_free(expr);
-#endif    
+#endif
 
     /* Cleanup data, no OnRemove, delete from entity index, don't deactivate */
     fini_data(world, table, &table->storage, false, true, true, false);
@@ -2720,11 +2720,11 @@ void flecs_table_mark_dirty(
 
 static
 void move_switch_columns(
-    ecs_table_t *new_table, 
-    ecs_data_t *new_data, 
+    ecs_table_t *new_table,
+    ecs_data_t *new_data,
     int32_t new_index,
-    ecs_table_t *old_table, 
-    ecs_data_t *old_data, 
+    ecs_table_t *old_table,
+    ecs_data_t *old_data,
     int32_t old_index,
     int32_t count)
 {
@@ -2771,11 +2771,11 @@ void move_switch_columns(
 
 static
 void move_bitset_columns(
-    ecs_table_t *new_table, 
-    ecs_data_t *new_data, 
+    ecs_table_t *new_table,
+    ecs_data_t *new_data,
     int32_t new_index,
-    ecs_table_t *old_table, 
-    ecs_data_t *old_data, 
+    ecs_table_t *old_table,
+    ecs_data_t *old_data,
     int32_t old_index,
     int32_t count)
 {
@@ -2841,7 +2841,7 @@ void grow_column(
 
     ecs_assert(new_size >= new_count, ECS_INTERNAL_ERROR, NULL);
 
-    /* If the array could possibly realloc and the component has a move action 
+    /* If the array could possibly realloc and the component has a move action
      * defined, move old elements manually */
     ecs_move_t move;
     if (c_info && count && can_realloc && (move = c_info->lifecycle.move)) {
@@ -2859,13 +2859,13 @@ void grow_column(
             new_vec, size, alignment);
 
         /* First construct elements (old and new) in new buffer */
-        ctor(world, c_info->component, entities, new_buffer, 
-            flecs_itosize(size), construct ? new_count : count, 
+        ctor(world, c_info->component, entities, new_buffer,
+            flecs_itosize(size), construct ? new_count : count,
             c_info->lifecycle.ctx);
-        
+
         /* Move old elements */
-        move(world, c_info->component, entities, entities, 
-            new_buffer, old_buffer, flecs_itosize(size), count, 
+        move(world, c_info->component, entities, entities,
+            new_buffer, old_buffer, flecs_itosize(size), count,
             c_info->lifecycle.ctx);
 
         /* Free old vector */
@@ -2883,14 +2883,14 @@ void grow_column(
         if (construct && c_info && (ctor = c_info->lifecycle.ctor)) {
             /* If new elements need to be constructed and component has a
              * constructor, construct */
-            ctor(world, c_info->component, &entities[count], elem, 
+            ctor(world, c_info->component, &entities[count], elem,
                 flecs_itosize(size), to_add, c_info->lifecycle.ctx);
         }
 
         column->data = vec;
     }
 
-    ecs_assert(ecs_vector_size(column->data) == new_size, 
+    ecs_assert(ecs_vector_size(column->data) == new_size,
         ECS_INTERNAL_ERROR, NULL);
 }
 
@@ -2912,7 +2912,7 @@ int32_t grow_data(
     int32_t bs_column_count = table->bs_column_count;
     ecs_column_t *columns = data->columns;
     ecs_sw_column_t *sw_columns = data->sw_columns;
-    ecs_bs_column_t *bs_columns = data->bs_columns; 
+    ecs_bs_column_t *bs_columns = data->bs_columns;
 
     /* Add record to record ptr array */
     ecs_vector_set_size(&data->record_ptrs, ecs_record_t*, size);
@@ -2952,7 +2952,7 @@ int32_t grow_data(
         }
 
         grow_column(world, entities, column, c_info, to_add, size, true);
-        ecs_assert(ecs_vector_size(columns[i].data) == size, 
+        ecs_assert(ecs_vector_size(columns[i].data) == size,
             ECS_INTERNAL_ERROR, NULL);
     }
 
@@ -3016,21 +3016,21 @@ int32_t flecs_table_append(
     int32_t size = ecs_vector_size(data->entities);
     int32_t column_count = ecs_vector_count(table->storage_type);
     ecs_column_t *columns = table->storage.columns;
-    
+
     /* Grow buffer with entity ids, set new element to new entity */
     ecs_entity_t *e = ecs_vector_add(&data->entities, ecs_entity_t);
     ecs_assert(e != NULL, ECS_INTERNAL_ERROR, NULL);
-    *e = entity;    
+    *e = entity;
 
     /* Keep track of alloc count. This allows references to check if cached
-     * pointers need to be updated. */  
+     * pointers need to be updated. */
     table->alloc_count += (count == size);
 
     /* Add record ptr to array with record ptrs */
     ecs_record_t **r = ecs_vector_add(&data->record_ptrs, ecs_record_t*);
     ecs_assert(r != NULL, ECS_INTERNAL_ERROR, NULL);
     *r = record;
- 
+
     /* If the table is monitored indicate that there has been a change */
     mark_table_dirty(world, table, 0);
     ecs_assert(count >= 0, ECS_INTERNAL_ERROR, NULL);
@@ -3053,7 +3053,7 @@ int32_t flecs_table_append(
     ecs_entity_t *entities = ecs_vector_first(
         data->entities, ecs_entity_t);
 
-    /* Reobtain size to ensure that the columns have the same size as the 
+    /* Reobtain size to ensure that the columns have the same size as the
      * entities and record vectors. This keeps reasoning about when allocations
      * occur easier. */
     size = ecs_vector_size(data->entities);
@@ -3070,14 +3070,14 @@ int32_t flecs_table_append(
         }
 
         grow_column(world, entities, column, c_info, 1, size, construct);
-        
+
         ecs_assert(
-            ecs_vector_size(columns[i].data) == ecs_vector_size(data->entities), 
-            ECS_INTERNAL_ERROR, NULL); 
-            
+            ecs_vector_size(columns[i].data) == ecs_vector_size(data->entities),
+            ECS_INTERNAL_ERROR, NULL);
+
         ecs_assert(
-            ecs_vector_count(columns[i].data) == ecs_vector_count(data->entities), 
-            ECS_INTERNAL_ERROR, NULL);                        
+            ecs_vector_count(columns[i].data) == ecs_vector_count(data->entities),
+            ECS_INTERNAL_ERROR, NULL);
     }
 
     /* Add element to each switch column */
@@ -3092,13 +3092,13 @@ int32_t flecs_table_append(
         ecs_assert(bs_columns != NULL, ECS_INTERNAL_ERROR, NULL);
         ecs_bitset_t *bs = &bs_columns[i].data;
         flecs_bitset_addn(bs, 1);
-    }    
+    }
 
     /* If this is the first entity in this table, signal queries so that the
      * table moves from an inactive table to an active table. */
     if (!count) {
         table_activate(world, table, true);
-    } 
+    }
 
     return count;
 }
@@ -3106,7 +3106,7 @@ int32_t flecs_table_append(
 static
 void fast_delete_last(
     ecs_column_t *columns,
-    int32_t column_count) 
+    int32_t column_count)
 {
     int i;
     for (i = 0; i < column_count; i ++) {
@@ -3119,7 +3119,7 @@ static
 void fast_delete(
     ecs_column_t *columns,
     int32_t column_count,
-    int32_t index) 
+    int32_t index)
 {
     int i;
     for (i = 0; i < column_count; i ++) {
@@ -3159,13 +3159,13 @@ void flecs_table_delete(
     ecs_vector_remove_last(v_entities);
 
     /* Move last record ptr to index */
-    ecs_vector_t *v_records = data->record_ptrs;     
+    ecs_vector_t *v_records = data->record_ptrs;
     ecs_assert(count < ecs_vector_count(v_records), ECS_INTERNAL_ERROR, NULL);
 
     ecs_record_t **records = ecs_vector_first(v_records, ecs_record_t*);
     ecs_record_t *record_to_move = records[count];
     records[index] = record_to_move;
-    ecs_vector_remove_last(v_records); 
+    ecs_vector_remove_last(v_records);
 
     /* Update record of moved entity in entity index */
     if (index != count) {
@@ -3175,10 +3175,10 @@ void flecs_table_delete(
             ecs_assert(record_to_move->table != NULL, ECS_INTERNAL_ERROR, NULL);
             ecs_assert(record_to_move->table == table, ECS_INTERNAL_ERROR, NULL);
         }
-    }     
+    }
 
     /* If the table is monitored indicate that there has been a change */
-    mark_table_dirty(world, table, 0);    
+    mark_table_dirty(world, table, 0);
 
     /* If table is empty, deactivate it */
     if (!count) {
@@ -3208,7 +3208,7 @@ void flecs_table_delete(
         /* If table has component destructors, invoke */
         if (destruct && (table->flags & EcsTableHasDtors)) {
             ecs_assert(c_info_array != NULL, ECS_INTERNAL_ERROR, NULL);
-            
+
             for (i = 0; i < column_count; i ++) {
                 ecs_type_info_t *c_info = c_info_array[i];
                 ecs_xtor_t dtor;
@@ -3218,7 +3218,7 @@ void flecs_table_delete(
                     dtor(world, c_info->component, &entity_to_delete,
                         ecs_vector_last_t(columns[i].data, size, alignment),
                         flecs_itosize(size), 1, c_info->lifecycle.ctx);
-                }        
+                }
             }
         }
 
@@ -3237,12 +3237,12 @@ void flecs_table_delete(
                 ecs_vector_t *vec = column->data;
                 void *dst = ecs_vector_get_t(vec, size, align, index);
                 void *src = ecs_vector_last_t(vec, size, align);
-                
+
                 ecs_type_info_t *c_info = c_info_array[i];
                 ecs_move_ctor_t move_dtor;
                 if (c_info && (move_dtor = c_info->lifecycle.move_dtor)) {
                     move_dtor(world, c_info->component, &c_info->lifecycle,
-                        &entity_to_move, &entity_to_delete, dst, src, 
+                        &entity_to_move, &entity_to_delete, dst, src,
                         flecs_itosize(size), 1, c_info->lifecycle.ctx);
                 } else {
                     ecs_os_memcpy(dst, src, size);
@@ -3391,8 +3391,8 @@ void flecs_table_move(
                 if (cdata && (callback = cdata->lifecycle.ctor_move_dtor)) {
                     void *ctx = cdata->lifecycle.ctx;
                     /* ctor + move + dtor */
-                    callback(world, new_component, &cdata->lifecycle, 
-                        &dst_entity, &src_entity, 
+                    callback(world, new_component, &cdata->lifecycle,
+                        &dst_entity, &src_entity,
                         dst, src, flecs_itosize(size), 1, ctx);
                 } else {
                     ecs_os_memcpy(dst, src, size);
@@ -3401,8 +3401,8 @@ void flecs_table_move(
                 ecs_copy_ctor_t copy;
                 if (cdata && (copy = cdata->lifecycle.copy_ctor)) {
                     void *ctx = cdata->lifecycle.ctx;
-                    copy(world, new_component, &cdata->lifecycle, 
-                        &dst_entity, &src_entity, 
+                    copy(world, new_component, &cdata->lifecycle,
+                        &dst_entity, &src_entity,
                         dst, src, flecs_itosize(size), 1, ctx);
                 } else {
                     ecs_os_memcpy(dst, src, size);
@@ -3517,20 +3517,20 @@ void flecs_table_swap(
     ecs_data_t *data,
     int32_t row_1,
     int32_t row_2)
-{    
+{
     (void)world;
 
     ecs_assert(!table->lock, ECS_LOCKED_STORAGE, NULL);
     ecs_assert(data != NULL, ECS_INTERNAL_ERROR, NULL);
     ecs_assert(row_1 >= 0, ECS_INTERNAL_ERROR, NULL);
     ecs_assert(row_2 >= 0, ECS_INTERNAL_ERROR, NULL);
-    
+
     if (row_1 == row_2) {
         return;
     }
 
     /* If the table is monitored indicate that there has been a change */
-    mark_table_dirty(world, table, 0);    
+    mark_table_dirty(world, table, 0);
 
     ecs_entity_t *entities = ecs_vector_first(data->entities, ecs_entity_t);
     ecs_entity_t e1 = entities[row_1];
@@ -3556,7 +3556,7 @@ void flecs_table_swap(
     record_ptrs[row_2] = record_ptr_1;
 
     swap_switch_columns(table, data, row_1, row_2);
-    swap_bitset_columns(table, data, row_1, row_2);  
+    swap_bitset_columns(table, data, row_1, row_2);
 
     ecs_column_t *columns = data->columns;
     if (!columns) {
@@ -3565,7 +3565,7 @@ void flecs_table_swap(
 
     /* Swap columns */
     int32_t i, column_count = ecs_vector_count(table->storage_type);
-    
+
     for (i = 0; i < column_count; i ++) {
         int16_t size = columns[i].size;
         int16_t alignment = columns[i].alignment;
@@ -3581,7 +3581,7 @@ void flecs_table_swap(
         ecs_os_memcpy(tmp, el_1, size);
         ecs_os_memcpy(el_1, el_2, size);
         ecs_os_memcpy(el_2, tmp, size);
-    }  
+    }
 }
 
 static
@@ -3600,18 +3600,18 @@ void merge_vector(
         }
 
         *dst_out = src;
-    
+
     /* If the new table is not empty, copy the contents from the
      * src into the dst. */
     } else {
         int32_t src_count = ecs_vector_count(src);
         ecs_vector_set_count_t(&dst, size, alignment, dst_count + src_count);
-        
+
         void *dst_ptr = ecs_vector_first_t(dst, size, alignment);
         void *src_ptr = ecs_vector_first_t(src, size, alignment);
 
         dst_ptr = ECS_OFFSET(dst_ptr, size * dst_count);
-        
+
         ecs_os_memcpy(dst_ptr, src_ptr, size * src_count);
 
         ecs_vector_free(src);
@@ -3641,7 +3641,7 @@ void merge_column(
         }
 
         column->data = src;
-    
+
     /* If the new table is not empty, copy the contents from the
      * src into the dst. */
     } else {
@@ -3654,17 +3654,17 @@ void merge_column(
             ctor_component(
                 world, c_info, column, entities, dst_count, src_count);
         }
-        
+
         void *dst_ptr = ecs_vector_first_t(dst, size, alignment);
         void *src_ptr = ecs_vector_first_t(src, size, alignment);
 
         dst_ptr = ECS_OFFSET(dst_ptr, size * dst_count);
-        
+
         /* Move values into column */
         ecs_move_t move;
         if (c_info && (move = c_info->lifecycle.move)) {
-            move(world, c_info->component, entities, entities, 
-                dst_ptr, src_ptr, flecs_itosize(size), src_count, 
+            move(world, c_info->component, entities, entities,
+                dst_ptr, src_ptr, flecs_itosize(size), src_count,
                 c_info->lifecycle.ctx);
         } else {
             ecs_os_memcpy(dst_ptr, src_ptr, size * src_count);
@@ -3697,7 +3697,7 @@ void merge_table_data(
     if (!new_columns && !new_data->entities) {
         new_columns = new_data->columns;
     }
-    
+
     ecs_assert(!new_column_count || new_columns, ECS_INTERNAL_ERROR, NULL);
 
     if (!old_count) {
@@ -3705,18 +3705,18 @@ void merge_table_data(
     }
 
     /* Merge entities */
-    merge_vector(&new_data->entities, old_data->entities, ECS_SIZEOF(ecs_entity_t), 
+    merge_vector(&new_data->entities, old_data->entities, ECS_SIZEOF(ecs_entity_t),
         ECS_ALIGNOF(ecs_entity_t));
     old_data->entities = NULL;
     ecs_entity_t *entities = ecs_vector_first(new_data->entities, ecs_entity_t);
 
-    ecs_assert(ecs_vector_count(new_data->entities) == old_count + new_count, 
+    ecs_assert(ecs_vector_count(new_data->entities) == old_count + new_count,
         ECS_INTERNAL_ERROR, NULL);
 
     /* Merge entity index record pointers */
-    merge_vector(&new_data->record_ptrs, old_data->record_ptrs, 
+    merge_vector(&new_data->record_ptrs, old_data->record_ptrs,
         ECS_SIZEOF(ecs_record_t*), ECS_ALIGNOF(ecs_record_t*));
-    old_data->record_ptrs = NULL;        
+    old_data->record_ptrs = NULL;
 
     for (; (i_new < new_column_count) && (i_old < old_column_count); ) {
         ecs_entity_t new_component = new_components[i_new];
@@ -3726,13 +3726,13 @@ void merge_table_data(
         ecs_assert(size != 0, ECS_INTERNAL_ERROR, NULL);
 
         if (new_component == old_component) {
-            merge_column(world, new_table, new_data, i_new, 
+            merge_column(world, new_table, new_data, i_new,
                 old_columns[i_old].data);
             old_columns[i_old].data = NULL;
 
             /* Mark component column as dirty */
             mark_table_dirty(world, new_table, i_new + 1);
-            
+
             i_new ++;
             i_old ++;
         } else if (new_component < old_component) {
@@ -3745,18 +3745,18 @@ void merge_table_data(
             /* Construct new values */
             ecs_type_info_t *c_info = new_table->c_info[i_new];
             if (c_info) {
-                ctor_component(world, c_info, column, 
+                ctor_component(world, c_info, column,
                     entities, 0, old_count + new_count);
             }
-            
+
             i_new ++;
         } else if (new_component > old_component) {
             ecs_column_t *column = &old_columns[i_old];
-            
+
             /* Destruct old values */
             ecs_type_info_t *c_info = old_table->c_info[i_old];
             if (c_info) {
-                dtor_component(world, c_info, column, 
+                dtor_component(world, c_info, column,
                     entities, 0, old_count);
             }
 
@@ -3784,7 +3784,7 @@ void merge_table_data(
         /* Construct new values */
         ecs_type_info_t *c_info = new_table->c_info[i_new];
         if (c_info) {
-            ctor_component(world, c_info, column, 
+            ctor_component(world, c_info, column,
                 entities, 0, old_count + new_count);
         }
     }
@@ -3796,17 +3796,17 @@ void merge_table_data(
         /* Destruct old values */
         ecs_type_info_t *c_info = old_table->c_info[i_old];
         if (c_info) {
-            dtor_component(world, c_info, column, entities, 
+            dtor_component(world, c_info, column, entities,
                 0, old_count);
         }
 
         /* Old column does not occur in new table, remove */
         ecs_vector_free(column->data);
         column->data = NULL;
-    }    
+    }
 
     /* Mark entity column as dirty */
-    mark_table_dirty(world, new_table, 0); 
+    mark_table_dirty(world, new_table, 0);
 }
 
 int32_t ecs_table_count(
@@ -3825,9 +3825,9 @@ void flecs_table_merge(
 {
     ecs_assert(old_table != NULL, ECS_INTERNAL_ERROR, NULL);
     ecs_assert(!old_table->lock, ECS_LOCKED_STORAGE, NULL);
-    
+
     bool move_data = false;
-    
+
     /* If there is nothing to merge to, just clear the old table */
     if (!new_table) {
         flecs_table_clear_data(world, old_table, old_data);
@@ -3875,7 +3875,7 @@ void flecs_table_merge(
     if (move_data) {
         *new_data = *old_data;
     } else {
-        merge_table_data(world, new_table, old_table, old_count, new_count, 
+        merge_table_data(world, new_table, old_table, old_count, new_count,
             old_data, new_data);
     }
 
@@ -3919,12 +3919,12 @@ void flecs_table_replace_data(
 
 int32_t* flecs_table_get_dirty_state(
     ecs_table_t *table)
-{    
+{
     if (!table->dirty_state) {
         int32_t column_count = ecs_vector_count(table->storage_type);
         table->dirty_state = ecs_os_malloc_n( int32_t, column_count + 1);
         ecs_assert(table->dirty_state != NULL, ECS_INTERNAL_ERROR, NULL);
-        
+
         for (int i = 0; i < column_count + 1; i ++) {
             table->dirty_state[i] = 1;
         }
@@ -4037,7 +4037,7 @@ int32_t ecs_table_type_to_storage_index(
     int32_t index)
 {
     ecs_assert(index >= 0, ECS_INVALID_PARAMETER, NULL);
-    ecs_check(index < ecs_vector_count(table->type), 
+    ecs_check(index < ecs_vector_count(table->type),
         ECS_INVALID_PARAMETER, NULL);
     int32_t *storage_map = table->storage_map;
     if (storage_map) {
@@ -4051,7 +4051,7 @@ int32_t ecs_table_storage_to_type_index(
     const ecs_table_t *table,
     int32_t index)
 {
-    ecs_check(index < ecs_vector_count(table->storage_type), 
+    ecs_check(index < ecs_vector_count(table->storage_type),
         ECS_INVALID_PARAMETER, NULL);
     ecs_check(table->storage_map != NULL, ECS_INVALID_PARAMETER, NULL);
     int32_t offset = ecs_vector_count(table->type);
@@ -4085,17 +4085,17 @@ void* ecs_record_get_column(
     (void)c_size;
     ecs_table_t *table = r->table;
 
-    ecs_check(column < ecs_vector_count(table->storage_type), 
+    ecs_check(column < ecs_vector_count(table->storage_type),
         ECS_INVALID_PARAMETER, NULL);
 
     ecs_column_t *c = &table->storage.columns[column];
     ecs_assert(c != NULL, ECS_INTERNAL_ERROR, NULL);
 
-    ecs_check(!flecs_utosize(c_size) || 
-        flecs_utosize(c_size) == c->size, 
+    ecs_check(!flecs_utosize(c_size) ||
+        flecs_utosize(c_size) == c->size,
         ECS_INVALID_PARAMETER, NULL);
 
-    return ecs_vector_get_t(c->data, c->size, c->alignment, 
+    return ecs_vector_get_t(c->data, c->size, c->alignment,
         ECS_RECORD_TO_ROW(r->row));
 error:
     return NULL;
@@ -4150,7 +4150,7 @@ void* get_mixin(
 {
     ecs_assert(poly != NULL, ECS_INVALID_PARAMETER, NULL);
     ecs_assert(kind < EcsMixinMax, ECS_INVALID_PARAMETER, NULL);
-    
+
     const ecs_header_t *hdr = poly;
     ecs_assert(hdr != NULL, ECS_INVALID_PARAMETER, NULL);
     ecs_assert(hdr->magic == ECS_OBJECT_MAGIC, ECS_INVALID_PARAMETER, NULL);
@@ -4171,7 +4171,7 @@ void* get_mixin(
     /* Object has mixin, return its address */
     return ECS_OFFSET(hdr, offset);
 
-find_in_base:    
+find_in_base:
     if (offset) {
         /* If the poly has a base, try to find the mixin in the base */
         ecs_poly_t *base = *(ecs_poly_t**)ECS_OFFSET(hdr, offset);
@@ -4179,7 +4179,7 @@ find_in_base:
             return get_mixin(base, kind);
         }
     }
-    
+
 not_found:
     /* Mixin wasn't found for poly */
     return NULL;
@@ -4194,7 +4194,7 @@ void* assert_mixin(
     if (!ptr) {
         const ecs_header_t *header = poly;
         const ecs_mixins_t *mixins = header->mixins;
-        ecs_err("%s not available for type %s", 
+        ecs_err("%s not available for type %s",
             mixin_kind_str[kind],
             mixins ? mixins->type_name : "unknown");
         ecs_os_abort();
@@ -4248,7 +4248,7 @@ void _ecs_poly_assert(
     int32_t line)
 {
     assert_object(poly != NULL, file, line);
-    
+
     const ecs_header_t *hdr = poly;
     assert_object(hdr->magic == ECS_OBJECT_MAGIC, file, line);
     assert_object(hdr->type == type, file, line);
@@ -4263,7 +4263,7 @@ bool _ecs_poly_is(
 
     const ecs_header_t *hdr = poly;
     ecs_assert(hdr->magic == ECS_OBJECT_MAGIC, ECS_INVALID_PARAMETER, NULL);
-    return hdr->type == type;    
+    return hdr->type == type;
 }
 
 ecs_iterable_t* ecs_get_iterable(
@@ -4316,18 +4316,18 @@ void* get_component_w_index(
     int32_t column_index,
     int32_t row)
 {
-    ecs_check(column_index < ecs_table_storage_count(table), 
+    ecs_check(column_index < ecs_table_storage_count(table),
         ECS_NOT_A_COMPONENT, NULL);
 
     ecs_column_t *column = &table->storage.columns[column_index];
 
     /* If size is 0, component does not have a value. This is likely caused by
     * an application trying to call ecs_get with a tag. */
-    int32_t size = column->size;    
+    int32_t size = column->size;
     ecs_check(size != 0, ECS_INVALID_PARAMETER, NULL);
 
-    void *ptr = ecs_vector_first_t(column->data, size, column->alignment); 
-    return ECS_OFFSET(ptr, size * row);  
+    void *ptr = ecs_vector_first_t(column->data, size, column->alignment);
+    return ECS_OFFSET(ptr, size * row);
 error:
     return NULL;
 }
@@ -4343,7 +4343,7 @@ void* get_component(
     ecs_assert(id != 0, ECS_INVALID_PARAMETER, NULL);
 
     if (!table->storage_table) {
-        ecs_check(ecs_search(world, table, id, 0) == -1, 
+        ecs_check(ecs_search(world, table, id, 0) == -1,
             ECS_NOT_A_COMPONENT, NULL);
         return NULL;
     }
@@ -4351,7 +4351,7 @@ void* get_component(
     ecs_table_record_t *tr = flecs_get_table_record(
         world, table->storage_table, id);
     if (!tr) {
-        ecs_check(ecs_search(world, table, id, 0) == -1, 
+        ecs_check(ecs_search(world, table, id, 0) == -1,
             ECS_NOT_A_COMPONENT, NULL);
        return NULL;
     }
@@ -4383,7 +4383,7 @@ void* get_base_component(
         return NULL;
     }
 
-    /* Should always be an id record for IsA, otherwise a table with a 
+    /* Should always be an id record for IsA, otherwise a table with a
      * HasBase flag set should not exist. */
     if (!table_index_isa) {
         ecs_id_record_t *idr = flecs_get_id_record(
@@ -4423,12 +4423,12 @@ void* get_base_component(
         if (storage_table) {
             tr = flecs_id_record_table(table_index, storage_table);
         } else {
-            ecs_check(!ecs_owns_id(world, base, id), 
+            ecs_check(!ecs_owns_id(world, base, id),
                 ECS_NOT_A_COMPONENT, NULL);
         }
 
         if (!tr) {
-            ptr = get_base_component(world, table, id, table_index, 
+            ptr = get_base_component(world, table, id, table_index,
                 table_index_isa, recur_depth + 1);
         } else {
             int32_t row = ECS_RECORD_TO_ROW(r->row);
@@ -4472,7 +4472,7 @@ void set_info_from_record(
 
     info->data = &table->storage;
 
-    ecs_assert(ecs_vector_count(table->storage.entities) > info->row, 
+    ecs_assert(ecs_vector_count(table->storage.entities) > info->row,
         ECS_INTERNAL_ERROR, NULL);
 }
 
@@ -4497,7 +4497,7 @@ void ids_merge(
     if (!add || !add->count) {
         return;
     }
-    
+
     int32_t new_count = ids->count + add->count;
     if (new_count >= ids->size) {
         ids->size = flecs_next_pow_of_2(new_count);
@@ -4507,7 +4507,7 @@ void ids_merge(
         if (ids->count >= ECS_MAX_ADD_REMOVE) {
             ecs_os_free(ids->array);
         }
-        
+
         ids->array = arr;
     }
 
@@ -4641,7 +4641,7 @@ void instantiate_children(
 
         /* Keep track of the element that creates the ChildOf relationship with
          * the prefab parent. We need to replace this element to make sure the
-         * created children point to the instance and not the prefab */ 
+         * created children point to the instance and not the prefab */
         if (ECS_HAS_RELATION(id, EcsChildOf) && (ECS_PAIR_OBJECT(id) == base)) {
             childof_base_index = pos;
         }
@@ -4679,7 +4679,7 @@ void instantiate_children(
         ecs_entity_t instance = entities[i];
         ecs_table_diff_t diff = ECS_TABLE_DIFF_INIT;
         ecs_table_t *i_table = NULL;
- 
+
         /* Replace ChildOf element in the component array with instance id */
         components.array[childof_base_index] = ecs_pair(EcsChildOf, instance);
 
@@ -4700,7 +4700,7 @@ void instantiate_children(
 
 #ifdef FLECS_SANITIZE
         for (j = 0; j < child_count; j ++) {
-            ecs_entity_t child = children[j];        
+            ecs_entity_t child = children[j];
             ecs_check(child != instance, ECS_INVALID_PARAMETER, NULL);
         }
 #else
@@ -4710,8 +4710,8 @@ void instantiate_children(
 #endif
 
         /* Create children */
-        int32_t child_row; 
-        new_w_data(world, i_table, NULL, &components, child_count, 
+        int32_t child_row;
+        new_w_data(world, i_table, NULL, &components, child_count,
             component_data, false, &child_row, &diff);
         diff_free(&diff);
 
@@ -4721,9 +4721,9 @@ void instantiate_children(
             ecs_entity_t child = children[j];
             instantiate(world, child, i_table, i_data, child_row + j, 1);
         }
-    }   
+    }
 error:
-    return;    
+    return;
 }
 
 static
@@ -4815,7 +4815,7 @@ bool override_from_base(
             for (index = 0; index < count; index ++) {
                 ecs_os_memcpy(data_ptr, base_ptr, data_size);
                 data_ptr = ECS_OFFSET(data_ptr, data_size);
-            }                    
+            }
         }
 
         ecs_ids_t ids = {
@@ -4826,19 +4826,19 @@ bool override_from_base(
         if (notify_on_set) {
             /* Check if the component was available for the previous table. If
              * the override is caused by an add operation, it does not introduce
-             * a new component value, and the application should not be 
-             * notified. 
-             * 
+             * a new component value, and the application should not be
+             * notified.
+             *
              * If the override is the result if adding a IsA relation
              * with an entity that has components with the OVERRIDE flag, an
              * event should be generated, since this represents a new component
              * (and component value) for the entity.
-             * 
-             * Note that this is an edge case, regular (self) triggers won't be 
+             *
+             * Note that this is an edge case, regular (self) triggers won't be
              * notified because the event id is not the component but an IsA
              * relationship. Superset triggers will not be invoked because the
              * component is owned. */
-            int32_t c = ecs_search_relation(world, other_table, 0, component, 
+            int32_t c = ecs_search_relation(world, other_table, 0, component,
                 EcsIsA, 1, 0, 0, 0, 0);
             if (c == -1) {
                 notify(
@@ -4850,7 +4850,7 @@ bool override_from_base(
     } else {
         /* If component not found on base, check if base itself inherits */
         ecs_type_t base_type = base_info.table->type;
-        return override_component(world, component, base_type, table, 
+        return override_component(world, component, base_type, table,
             other_table, data, column, row, count, notify_on_set);
     }
 }
@@ -4949,7 +4949,7 @@ void components_override(
             continue;
         }
 
-        override_component(world, id, type, table, other_table, data, column, 
+        override_component(world, id, type, table, other_table, data, column,
             row, count, notify_on_set);
     }
 error:
@@ -4962,7 +4962,7 @@ void set_switch(
     ecs_table_t *table,
     ecs_data_t *data,
     int32_t row,
-    int32_t count,    
+    int32_t count,
     ecs_ids_t *entities,
     bool reset)
 {
@@ -4985,7 +4985,7 @@ void set_switch(
             ecs_assert(sw_index != -1, ECS_INTERNAL_ERROR, NULL);
             ecs_switch_t *sw = data->sw_columns[sw_index].data;
             ecs_assert(sw != NULL, ECS_INTERNAL_ERROR, NULL);
-            
+
             int32_t r;
             for (r = 0; r < count; r ++) {
                 flecs_switch_set(sw, row + r, sw_case);
@@ -5009,7 +5009,7 @@ void ecs_components_switch(
     }
     if (removed) {
         set_switch(world, table, data, row, count, removed, true);
-    } 
+    }
 }
 
 static
@@ -5036,12 +5036,12 @@ int32_t new_entity(
     record->table = new_table;
     record->row = ECS_ROW_TO_RECORD(new_row, info->row_flags);
 
-    ecs_assert(ecs_vector_count(new_data[0].entities) > new_row, 
+    ecs_assert(ecs_vector_count(new_data[0].entities) > new_row,
         ECS_INTERNAL_ERROR, NULL);
 
     if (new_table->flags & EcsTableHasAddActions) {
         flecs_notify_on_add(
-            world, new_table, NULL, new_data, new_row, 1, diff, notify_on_set);       
+            world, new_table, NULL, new_data, new_row, 1, diff, notify_on_set);
     }
 
     info->data = new_data;
@@ -5061,24 +5061,24 @@ int32_t move_entity(
     ecs_table_diff_t *diff,
     bool construct,
     bool notify_on_set)
-{    
+{
     ecs_data_t *dst_data = &dst_table->storage;
     ecs_assert(src_data != dst_data, ECS_INTERNAL_ERROR, NULL);
     ecs_assert(src_table != NULL, ECS_INTERNAL_ERROR, NULL);
     ecs_assert(src_data != NULL, ECS_INTERNAL_ERROR, NULL);
     ecs_assert(src_row >= 0, ECS_INTERNAL_ERROR, NULL);
-    ecs_assert(ecs_vector_count(src_data->entities) > src_row, 
+    ecs_assert(ecs_vector_count(src_data->entities) > src_row,
         ECS_INTERNAL_ERROR, NULL);
     ecs_check(ecs_is_alive(world, entity), ECS_INVALID_PARAMETER, NULL);
 
     ecs_record_t *record = info->record;
-    ecs_assert(!record || record == ecs_eis_get(world, entity), 
+    ecs_assert(!record || record == ecs_eis_get(world, entity),
         ECS_INTERNAL_ERROR, NULL);
 
-    int32_t dst_row = flecs_table_append(world, dst_table, dst_data, entity, 
+    int32_t dst_row = flecs_table_append(world, dst_table, dst_data, entity,
         record, false);
 
-    ecs_assert(ecs_vector_count(src_data->entities) > src_row, 
+    ecs_assert(ecs_vector_count(src_data->entities) > src_row,
         ECS_INTERNAL_ERROR, NULL);
 
     /* Copy entity & components from src_table to dst_table */
@@ -5086,20 +5086,20 @@ int32_t move_entity(
         flecs_notify_on_remove(
             world, src_table, dst_table, src_row, 1, diff);
 
-        flecs_table_move(world, entity, entity, dst_table, dst_data, dst_row, 
-            src_table, src_data, src_row, construct);                
+        flecs_table_move(world, entity, entity, dst_table, dst_data, dst_row,
+            src_table, src_data, src_row, construct);
     }
 
     /* Update entity index & delete old data after running remove actions */
     record->table = dst_table;
     record->row = ECS_ROW_TO_RECORD(dst_row, info->row_flags);
-    
+
     flecs_table_delete(world, src_table, src_data, src_row, false);
 
     /* If components were added, invoke add actions */
     if (src_table != dst_table || diff->added.count) {
         if (diff->added.count && (dst_table->flags & EcsTableHasAddActions)) {
-            flecs_notify_on_add(world, dst_table, src_table, dst_data, 
+            flecs_notify_on_add(world, dst_table, src_table, dst_data,
                 dst_row, 1, diff, notify_on_set);
         }
     }
@@ -5120,9 +5120,9 @@ void delete_entity(
 {
     if (src_table) {
         /* Invoke remove actions before deleting */
-        if (src_table->flags & EcsTableHasRemoveActions) {   
+        if (src_table->flags & EcsTableHasRemoveActions) {
             flecs_notify_on_remove(world, src_table, NULL, src_row, 1, diff);
-        } 
+        }
     }
 
     flecs_table_delete(world, src_table, src_data, src_row, true);
@@ -5150,17 +5150,17 @@ void update_component_monitor_w_array(
         ecs_entity_t id = entities->array[i];
         if (ECS_HAS_ROLE(id, PAIR)) {
             ecs_entity_t rel = ECS_PAIR_RELATION(id);
-            
+
             /* If a relationship has changed, check if it could have impacted
              * the shape of the graph for that relationship. If so, mark the
-             * relationship as dirty */        
+             * relationship as dirty */
             if (rel != relation && flecs_get_id_record(
-                world, ecs_pair(rel, entity))) 
+                world, ecs_pair(rel, entity)))
             {
                 update_component_monitor_w_array(world, entity, rel, entities);
             }
         }
-        
+
         if (ECS_HAS_RELATION(id, EcsIsA)) {
             /* If an IsA relationship is added to a monitored entity (can
              * be either a parent or a base) component monitors need to be
@@ -5173,7 +5173,7 @@ void update_component_monitor_w_array(
              * base entity. If the base entity contains IsA relationships
              * these will be evaluated recursively as well. */
             update_component_monitor_w_array(
-                world, entity, relation, &base_entities);               
+                world, entity, relation, &base_entities);
         } else {
             flecs_monitor_mark_dirty(world, relation, id);
         }
@@ -5196,23 +5196,23 @@ void commit(
     ecs_world_t *world,
     ecs_entity_t entity,
     ecs_entity_info_t *info,
-    ecs_table_t *dst_table,   
+    ecs_table_t *dst_table,
     ecs_table_diff_t *diff,
     bool construct,
     bool notify_on_set)
 {
     ecs_assert(!world->is_readonly, ECS_INTERNAL_ERROR, NULL);
-    
+
     ecs_table_t *src_table = info->table;
     if (src_table == dst_table) {
         /* If source and destination table are the same no action is needed *
          * However, if a component was added in the process of traversing a
          * table, this suggests that a case switch could have occured. */
-        if (((diff->added.count) || (diff->removed.count)) && 
-             src_table && src_table->flags & EcsTableHasSwitch) 
+        if (((diff->added.count) || (diff->removed.count)) &&
+             src_table && src_table->flags & EcsTableHasSwitch)
         {
             ecs_components_switch(
-                world, src_table, info->data, info->row, 1, 
+                world, src_table, info->data, info->row, 1,
                     &diff->added, &diff->removed);
         }
 
@@ -5223,8 +5223,8 @@ void commit(
         ecs_data_t *src_data = info->data;
         ecs_assert(dst_table != NULL, ECS_INTERNAL_ERROR, NULL);
 
-        if (dst_table->type) { 
-            info->row = move_entity(world, entity, info, src_table, 
+        if (dst_table->type) {
+            info->row = move_entity(world, entity, info, src_table,
                 src_data, info->row, dst_table, diff, construct, notify_on_set);
             info->table = dst_table;
         } else {
@@ -5233,30 +5233,30 @@ void commit(
             ecs_eis_set(world, entity, &(ecs_record_t){
                 NULL, info->row_flags
             });
-        }      
-    } else {        
+        }
+    } else {
         if (dst_table->type) {
             info->row = new_entity(
                 world, entity, info, dst_table, diff, construct, notify_on_set);
             info->table = dst_table;
-        }        
+        }
     }
 
     /* If the entity is being watched, it is being monitored for changes and
      * requires rematching systems when components are added or removed. This
      * ensures that systems that rely on components from containers or prefabs
-     * update the matched tables when the application adds or removes a 
+     * update the matched tables when the application adds or removes a
      * component from, for example, a container. */
     if (info->row_flags) {
         update_component_monitors(world, entity, &diff->added, &diff->removed);
     }
 
     if ((!src_table || !src_table->type) && world->range_check_enabled) {
-        ecs_check(!world->stats.max_id || entity <= world->stats.max_id, 
+        ecs_check(!world->stats.max_id || entity <= world->stats.max_id,
             ECS_OUT_OF_RANGE, 0);
-        ecs_check(entity >= world->stats.min_id, 
+        ecs_check(entity >= world->stats.min_id,
             ECS_OUT_OF_RANGE, 0);
-    } 
+    }
 error:
     return;
 }
@@ -5270,7 +5270,7 @@ void new(
     ecs_entity_info_t info = {0};
     int32_t i, count = to_add->count;
     ecs_table_t *table = &world->store.root;
-    
+
     ecs_table_diff_t diff = ECS_TABLE_DIFF_INIT;
     for (i = 0; i < count; i ++) {
         table = table_append(world, table, to_add->array[i], &diff);
@@ -5303,9 +5303,9 @@ const ecs_entity_t* new_w_data(
         return entities;
     }
 
-    ecs_type_t type = table->type;   
+    ecs_type_t type = table->type;
     if (!type) {
-        return entities;        
+        return entities;
     }
 
     ecs_ids_t component_array = { 0 };
@@ -5317,12 +5317,12 @@ const ecs_entity_t* new_w_data(
 
     ecs_data_t *data = &table->storage;
     int32_t row = flecs_table_appendn(world, table, data, count, entities);
-    
+
     /* Update entity index. */
     int i;
     ecs_record_t **record_ptrs = ecs_vector_first(data->record_ptrs, ecs_record_t*);
-    for (i = 0; i < count; i ++) { 
-        record_ptrs[row + i] = ecs_eis_set(world, entities[i], 
+    for (i = 0; i < count; i ++) {
+        record_ptrs[row + i] = ecs_eis_set(world, entities[i],
             &(ecs_record_t){
                 .table = table,
                 .row = ECS_ROW_TO_RECORD(row + i, 0)
@@ -5331,7 +5331,7 @@ const ecs_entity_t* new_w_data(
 
     flecs_defer_none(world, &world->stage);
 
-    flecs_notify_on_add(world, table, NULL, data, row, count, diff, 
+    flecs_notify_on_add(world, table, NULL, data, row, count, diff,
         component_data == NULL);
 
     if (component_data) {
@@ -5362,15 +5362,15 @@ const ecs_entity_t* new_w_data(
             ecs_move_t move;
             if (cdata && is_move && (move = cdata->lifecycle.move)) {
                 ecs_entity_t *eids = ecs_vector_first(data->entities, ecs_entity_t);
-                move(world, id, eids, eids, ptr, src_ptr, 
+                move(world, id, eids, eids, ptr, src_ptr,
                     flecs_itosize(size), count, cdata->lifecycle.ctx);
             } else if (cdata && !is_move && (copy = cdata->lifecycle.copy)) {
                 ecs_entity_t *eids = ecs_vector_first(data->entities, ecs_entity_t);
-                copy(world, id, eids, eids, ptr, src_ptr, 
+                copy(world, id, eids, eids, ptr, src_ptr,
                     flecs_itosize(size), count, cdata->lifecycle.ctx);
             } else {
                 ecs_os_memcpy(ptr, src_ptr, size * count);
-            } 
+            }
         };
 
         flecs_notify_on_set(world, table, row, count, NULL, true);
@@ -5405,7 +5405,7 @@ void add_id_w_info(
     ecs_table_t *dst_table = flecs_table_traverse_add(
         world, src_table, &id, &diff);
 
-    commit(world, entity, info, dst_table, &diff, construct, 
+    commit(world, entity, info, dst_table, &diff, construct,
         false); /* notify_on_set = false, this function is only called from
                  * functions that are about to set the component. */
 }
@@ -5470,7 +5470,7 @@ void *get_mutable(
 {
     ecs_check(world != NULL, ECS_INVALID_PARAMETER, NULL);
     ecs_check(component != 0, ECS_INVALID_PARAMETER, NULL);
-    ecs_check((component & ECS_COMPONENT_MASK) == component || 
+    ecs_check((component & ECS_COMPONENT_MASK) == component ||
         ECS_HAS_ROLE(component, PAIR), ECS_INVALID_PARAMETER, NULL);
 
     void *dst = NULL;
@@ -5482,7 +5482,7 @@ void *get_mutable(
         ecs_table_t *table = info->table;
         add_id_w_info(world, entity, info, component, true);
         flecs_get_info(world, entity, info);
-        
+
         ecs_assert(info->table != NULL, ECS_INTERNAL_ERROR, NULL);
         ecs_assert(info->table->storage_table != NULL, ECS_INTERNAL_ERROR, NULL);
         dst = get_component(world, info->table, info->row, component);
@@ -5520,7 +5520,7 @@ void flecs_notify_on_add(
 
     if (diff->added.count) {
         if (table->flags & EcsTableHasIsA) {
-            components_override(world, table, other_table, data, row, count, 
+            components_override(world, table, other_table, data, row, count,
                 &diff->added, run_on_set);
         }
 
@@ -5530,7 +5530,7 @@ void flecs_notify_on_add(
         }
 
         if (table->flags & EcsTableHasOnAdd) {
-            notify(world, table, other_table, row, count, EcsOnAdd, 
+            notify(world, table, other_table, row, count, EcsOnAdd,
                 &diff->added, 0);
         }
     }
@@ -5539,7 +5539,7 @@ void flecs_notify_on_add(
      * components from the base. Send OnSet notifications so that an application
      * can respond to these new components. */
     if (run_on_set && diff->on_set.count) {
-        notify(world, table, other_table, row, count, EcsOnSet, &diff->on_set, 
+        notify(world, table, other_table, row, count, EcsOnSet, &diff->on_set,
             EcsIsA);
     }
 }
@@ -5560,12 +5560,12 @@ void flecs_notify_on_remove(
         }
 
         if (table->flags & EcsTableHasOnRemove && diff->removed.count) {
-            notify(world, table, other_table, row, count, EcsOnRemove, 
+            notify(world, table, other_table, row, count, EcsOnRemove,
                 &diff->removed, 0);
         }
 
         if (table->flags & EcsTableHasIsA && diff->on_set.count) {
-            notify(world, table, other_table, row, count, EcsOnSet, 
+            notify(world, table, other_table, row, count, EcsOnSet,
                 &diff->on_set, 0);
         }
     }
@@ -5581,11 +5581,11 @@ void flecs_notify_on_set(
 {
     ecs_data_t *data = &table->storage;
 
-    ecs_entity_t *entities = ecs_vector_first(data->entities, ecs_entity_t);        
+    ecs_entity_t *entities = ecs_vector_first(data->entities, ecs_entity_t);
     ecs_assert(entities != NULL, ECS_INTERNAL_ERROR, NULL);
-    ecs_assert(row < ecs_vector_count(data->entities), 
+    ecs_assert(row < ecs_vector_count(data->entities),
         ECS_INTERNAL_ERROR, NULL);
-    ecs_assert((row + count) <= ecs_vector_count(data->entities), 
+    ecs_assert((row + count) <= ecs_vector_count(data->entities),
         ECS_INTERNAL_ERROR, NULL);
     entities = ECS_OFFSET(entities, ECS_SIZEOF(ecs_entity_t) * row);
 
@@ -5610,7 +5610,7 @@ void flecs_notify_on_set(
 
                 ecs_iter_t it = {.term_count = 1};
                 it.entities = entities;
-                
+
                 flecs_iter_init(&it);
                 it.world = world;
                 it.real_world = world;
@@ -5619,7 +5619,7 @@ void flecs_notify_on_set(
                 it.ids[0] = id;
                 it.ctx = info->lifecycle.ctx;
                 it.count = count;
-                
+
                 on_set(&it);
             }
         }
@@ -5644,7 +5644,7 @@ bool flecs_get_info(
     if (entity & ECS_ROLE) {
         return false;
     }
-    
+
     ecs_record_t *record = ecs_eis_get(world, entity);
 
     if (!record) {
@@ -5657,16 +5657,16 @@ bool flecs_get_info(
 }
 
 uint32_t flecs_record_to_row(
-    uint32_t row, 
-    bool *is_watched_out) 
+    uint32_t row,
+    bool *is_watched_out)
 {
     *is_watched_out = (row & ECS_ROW_FLAGS_MASK) != 0;
     return row & ECS_ROW_MASK;
 }
 
 uint32_t flecs_row_to_record(
-    uint32_t row, 
-    bool is_watched) 
+    uint32_t row,
+    bool is_watched)
 {
     return row | (ECS_FLAG_OBSERVED * is_watched);
 }
@@ -5684,7 +5684,7 @@ void flecs_add_flag(
     ecs_world_t *world,
     ecs_entity_t entity,
     uint32_t flag)
-{    
+{
     (void)world;
 
     ecs_record_t *record = ecs_eis_get(world, entity);
@@ -5727,7 +5727,7 @@ bool ecs_commit(
     if (removed) {
         diff.added = *removed;
     }
-    
+
     commit(world, entity, &info, table, &diff, true, true);
 
     return src_table != table;
@@ -5775,7 +5775,7 @@ ecs_entity_t ecs_new_id(
     int32_t stage_count = ecs_get_stage_count(unsafe_world);
     if (stage->asynchronous || (ecs_os_has_threading() && stage_count > 1)) {
         /* Can't atomically increase number above max int */
-        ecs_assert(unsafe_world->stats.last_id < UINT_MAX, 
+        ecs_assert(unsafe_world->stats.last_id < UINT_MAX,
             ECS_INVALID_OPERATION, NULL);
         entity = (ecs_entity_t)ecs_os_ainc(
             (int32_t*)&unsafe_world->stats.last_id);
@@ -5783,8 +5783,8 @@ ecs_entity_t ecs_new_id(
         entity = ecs_eis_recycle(unsafe_world);
     }
 
-    ecs_assert(!unsafe_world->stats.max_id || 
-        ecs_entity_t_lo(entity) <= unsafe_world->stats.max_id, 
+    ecs_assert(!unsafe_world->stats.max_id ||
+        ecs_entity_t_lo(entity) <= unsafe_world->stats.max_id,
         ECS_OUT_OF_RANGE, NULL);
 
     return entity;
@@ -5812,7 +5812,7 @@ ecs_entity_t ecs_new_low_id(
     if (unsafe_world->stats.last_component_id < ECS_HI_COMPONENT_ID) {
         do {
             id = unsafe_world->stats.last_component_id ++;
-        } while (ecs_exists(unsafe_world, id) && id <= ECS_HI_COMPONENT_ID);        
+        } while (ecs_exists(unsafe_world, id) && id <= ECS_HI_COMPONENT_ID);
     }
 
     if (!id || id >= ECS_HI_COMPONENT_ID) {
@@ -5821,7 +5821,7 @@ ecs_entity_t ecs_new_low_id(
     }
 
     return id;
-error: 
+error:
     return 0;
 }
 
@@ -5831,7 +5831,7 @@ ecs_entity_t ecs_new_w_id(
 {
     ecs_check(world != NULL, ECS_INVALID_PARAMETER, NULL);
 
-    ecs_stage_t *stage = flecs_stage_from_world(&world);    
+    ecs_stage_t *stage = flecs_stage_from_world(&world);
     ecs_entity_t entity = ecs_new_id(world);
 
     ecs_id_t ids[3];
@@ -5921,13 +5921,13 @@ ecs_table_t *traverse_from_expr(
                 if (error) {
                     *error = true;
                 }
-                ecs_parser_error(name, expr, (ptr - expr), 
+                ecs_parser_error(name, expr, (ptr - expr),
                     "invalid non-trivial term in add expression");
                 return NULL;
             }
 
             if (term.role == ECS_CASE) {
-                table = table_append(world, table, 
+                table = table_append(world, table,
                     ECS_SWITCH | ECS_PAIR_RELATION(term.id), diff);
                 term.id = ECS_CASE | ECS_PAIR_OBJECT(term.id);
             }
@@ -5942,11 +5942,11 @@ ecs_table_t *traverse_from_expr(
                     if (error) {
                         *error = true;
                     }
-                    ecs_parser_error(name, expr, (ptr - expr), 
+                    ecs_parser_error(name, expr, (ptr - expr),
                         "expected type for AND role");
                     return NULL;
                 }
-                
+
                 ecs_id_t *ids = ecs_vector_first(t->normalized->type, ecs_id_t);
                 int32_t i, count = ecs_vector_count(t->normalized->type);
                 for (i = 0; i < count; i ++) {
@@ -5968,7 +5968,7 @@ ecs_table_t *traverse_from_expr(
     return table;
 }
 
-/* Add/remove components based on the parsed expression. This operation is 
+/* Add/remove components based on the parsed expression. This operation is
  * slower than traverse_from_expr, but safe to use from a deferred context. */
 static
 void defer_from_expr(
@@ -5992,7 +5992,7 @@ void defer_from_expr(
             }
 
             if (!ecs_term_is_trivial(&term)) {
-                ecs_parser_error(name, expr, (ptr - expr), 
+                ecs_parser_error(name, expr, (ptr - expr),
                     "invalid non-trivial term in add expression");
                 return;
             }
@@ -6008,11 +6008,11 @@ void defer_from_expr(
                 /* Add all components from the specified type */
                 const EcsType *t = ecs_get(world, term.id, EcsType);
                 if (!t) {
-                    ecs_parser_error(name, expr, (ptr - expr), 
+                    ecs_parser_error(name, expr, (ptr - expr),
                         "expected type for AND role");
                     return;
                 }
-                
+
                 ecs_id_t *ids = ecs_vector_first(t->normalized->type, ecs_id_t);
                 int32_t i, count = ecs_vector_count(t->normalized->type);
                 for (i = 0; i < count; i ++) {
@@ -6032,7 +6032,7 @@ void defer_from_expr(
 
 /* If operation is not deferred, add components by finding the target
  * table and moving the entity towards it. */
-static 
+static
 int traverse_add(
     ecs_world_t *world,
     ecs_entity_t result,
@@ -6072,7 +6072,7 @@ int traverse_add(
 
     /* If a name is provided but not yet assigned, add the Name component */
     if (name && !name_assigned) {
-        table = table_append(world, table, 
+        table = table_append(world, table,
             ecs_pair(ecs_id(EcsIdentifier), EcsName), &diff);
     }
 
@@ -6129,7 +6129,7 @@ int traverse_add(
 
 /* When in deferred mode, we need to add/remove components one by one using
  * the regular operations. */
-static 
+static
 void deferred_add_remove(
     ecs_world_t *world,
     ecs_entity_t entity,
@@ -6173,7 +6173,7 @@ void deferred_add_remove(
 
     /* Set name */
     if (name && !name_assigned) {
-        ecs_add_path_w_sep(world, entity, scope, name, sep, NULL);   
+        ecs_add_path_w_sep(world, entity, scope, name, sep, NULL);
     }
 
     /* Currently it's not supported to set the symbol from a deferred context */
@@ -6206,18 +6206,18 @@ ecs_entity_t ecs_entity_init(
     bool new_entity = false;
     bool name_assigned = false;
 
-    /* Remove optional prefix from name. Entity names can be derived from 
+    /* Remove optional prefix from name. Entity names can be derived from
      * language identifiers, such as components (typenames) and systems
      * function names). Because C does not have namespaces, such identifiers
      * often encode the namespace as a prefix.
-     * To ensure interoperability between C and C++ (and potentially other 
+     * To ensure interoperability between C and C++ (and potentially other
      * languages with namespacing) the entity must be stored without this prefix
      * and with the proper namespace, which is what the name_prefix is for */
     const char *prefix = world->name_prefix;
     if (name && prefix) {
         ecs_size_t len = ecs_os_strlen(prefix);
-        if (!ecs_os_strncmp(name, prefix, len) && 
-           (isupper(name[len]) || name[len] == '_')) 
+        if (!ecs_os_strncmp(name, prefix, len) &&
+           (isupper(name[len]) || name[len] == '_'))
         {
             if (name[len] == '_') {
                 name = name + len + 1;
@@ -6245,7 +6245,7 @@ ecs_entity_t ecs_entity_init(
                 result = ecs_new_id(world);
             }
             new_entity = true;
-            ecs_assert(ecs_get_type(world, result) == NULL, 
+            ecs_assert(ecs_get_type(world, result) == NULL,
                 ECS_INTERNAL_ERROR, NULL);
         }
     } else {
@@ -6272,11 +6272,11 @@ ecs_entity_t ecs_entity_init(
             ECS_INTERNAL_ERROR, NULL);
 
     if (stage->defer) {
-        deferred_add_remove((ecs_world_t*)stage, result, name, desc, 
+        deferred_add_remove((ecs_world_t*)stage, result, name, desc,
             scope, with, new_entity, name_assigned);
     } else {
         if (traverse_add(world, result, name, desc,
-            scope, with, new_entity, name_assigned)) 
+            scope, with, new_entity, name_assigned))
         {
             return 0;
         }
@@ -6364,7 +6364,7 @@ ecs_entity_t ecs_component_init(
      * still happen directly on the main storage, but only if the application
      * is singlethreaded. */
     if (is_readonly || is_deferred) {
-        ecs_assert(ecs_get_stage_count(world) <= 1, 
+        ecs_assert(ecs_get_stage_count(world) <= 1,
             ECS_INVALID_WHILE_ITERATING, NULL);
 
         /* Silence readonly warnings */
@@ -6398,10 +6398,10 @@ ecs_entity_t ecs_component_init(
         ptr->size = flecs_utosize(desc->size);
         ptr->alignment = flecs_utosize(desc->alignment);
         if (!ptr->size) {
-            ecs_trace("#[green]tag#[reset] %s created", 
+            ecs_trace("#[green]tag#[reset] %s created",
                 ecs_get_name(world, result));
         } else {
-            ecs_trace("#[green]component#[reset] %s created", 
+            ecs_trace("#[green]component#[reset] %s created",
                 ecs_get_name(world, result));
         }
     } else {
@@ -6428,7 +6428,7 @@ ecs_entity_t ecs_component_init(
         stage->defer = defer_count;
         stage->defer_queue = defer_queue;
     }
-    
+
     ecs_assert(result != 0, ECS_INTERNAL_ERROR, NULL);
     ecs_assert(ecs_has(world, result, EcsComponent), ECS_INTERNAL_ERROR, NULL);
 
@@ -6472,13 +6472,13 @@ ecs_entity_t ecs_type_init(
 #ifdef FLECS_PARSER
         bool error = false;
 
-        normalized = traverse_from_expr(world, normalized, desc->entity.name, 
+        normalized = traverse_from_expr(world, normalized, desc->entity.name,
             desc->ids_expr, &diff, true, &error);
         if (error) {
             goto error;
         }
 
-        table = traverse_from_expr(world, table, desc->entity.name, 
+        table = traverse_from_expr(world, table, desc->entity.name,
             desc->ids_expr, &diff, false, &error);
         if (error) {
             goto error;
@@ -6491,7 +6491,7 @@ ecs_entity_t ecs_type_init(
     diff_free(&diff);
 
     ecs_type_t type = NULL;
-    
+
     if (table) {
         type = table->type;
     }
@@ -6509,10 +6509,10 @@ ecs_entity_t ecs_type_init(
 
         ecs_modified(world, result, EcsType);
     } else {
-        ecs_check(type_ptr->type == type, ECS_ALREADY_DEFINED, 
+        ecs_check(type_ptr->type == type, ECS_ALREADY_DEFINED,
             desc->entity.name);
         ecs_check(type_ptr->normalized == normalized, ECS_ALREADY_DEFINED,
-            desc->entity.name);      
+            desc->entity.name);
     }
 
     return result;
@@ -6535,7 +6535,7 @@ const ecs_entity_t* ecs_bulk_new_w_id(
 
     ecs_table_t *table = &world->store.root;
     ecs_table_diff_t diff = ECS_TABLE_DIFF_INIT;
-    
+
     if (id) {
         table = table_append(world, table, id, &diff);
     }
@@ -6575,7 +6575,7 @@ void ecs_clear(
         delete_entity(world, table, &table->storage, info.row, &diff);
         info.record->table = NULL;
         info.record->row = 0;
-    }    
+    }
 
     flecs_defer_flush(world, stage);
 error:
@@ -6609,14 +6609,14 @@ void remove_from_table(
     int32_t column_count)
 {
     ecs_table_diff_t temp_diff, diff = ECS_TABLE_DIFF_INIT;
-    ecs_table_t *dst_table = src_table; 
+    ecs_table_t *dst_table = src_table;
     ecs_id_t *ids = ecs_vector_first(src_table->type, ecs_id_t);
 
     /* If id is pair but the column pointed to is not a pair, the record is
      * pointing to an instance of the id that has a (non-PAIR) role. */
-    bool is_pair = ECS_HAS_ROLE(id, PAIR);     
+    bool is_pair = ECS_HAS_ROLE(id, PAIR);
     bool is_role = is_pair && !ECS_HAS_ROLE(ids[column], PAIR);
-    ecs_assert(!is_role || ((ids[column] & ECS_ROLE_MASK) != 0), 
+    ecs_assert(!is_role || ((ids[column] & ECS_ROLE_MASK) != 0),
         ECS_INTERNAL_ERROR, NULL);
     bool is_wildcard = ecs_id_is_wildcard(id);
 
@@ -6637,7 +6637,7 @@ void remove_from_table(
         dst_table = flecs_table_traverse_remove(
             world, dst_table, &e, &temp_diff);
         diff_append(&diff, &temp_diff);
-        
+
         removed_count ++;
         if (removed_count == column_count) {
             break;
@@ -6655,11 +6655,11 @@ void remove_from_table(
             ecs_data_t *src_data = &src_table->storage;
             int32_t src_count = ecs_table_count(src_table);
             if (diff.removed.count) {
-                flecs_notify_on_remove(world, src_table, NULL, 
+                flecs_notify_on_remove(world, src_table, NULL,
                     0, src_count, &diff);
             }
 
-            flecs_table_merge(world, dst_table, src_table, 
+            flecs_table_merge(world, dst_table, src_table,
                 &dst_table->storage, src_data);
         }
     }
@@ -6682,7 +6682,7 @@ void delete_objects(
             ecs_entity_t e = entities[i];
             ecs_record_t *r = flecs_sparse_get(
                 world->store.entity_index, ecs_record_t, e);
-            
+
             /* If entity is flagged, it could have delete actions. */
             uint32_t flags;
             if (r && (flags = (r->row & ECS_ROW_FLAGS_MASK))) {
@@ -6691,12 +6691,12 @@ void delete_objects(
 
                 /* Run delete actions for objects */
                 on_delete_any_w_entity(world, entities[i], 0, flags);
-            }        
+            }
         }
 
         /* Clear components from table (invokes destructors, OnRemove) */
-        flecs_table_delete_entities(world, table);            
-    } 
+        flecs_table_delete_entities(world, table);
+    }
 }
 
 static
@@ -6731,9 +6731,9 @@ void on_delete_object_action(
                 idrr = flecs_get_id_record(world, rel);
                 if (idrr) {
                     action =idrr->on_delete_object;
-                } 
+                }
             }
-             
+
             if (!action || action == EcsRemove) {
                 remove_from_table(world, table, id, tr->column, tr->count);
                 i = 0; count = flecs_id_record_count(idr);
@@ -6883,7 +6883,7 @@ void ecs_delete(
             /* Refetch data. In case of circular relations, the entity may have
              * moved to a different table. */
             set_info_from_record(&info, r);
-            
+
             table = info.table;
             if (table) {
                 table_id = table->id;
@@ -6980,11 +6980,11 @@ ecs_entity_t ecs_clone(
     ecs_table_diff_t diff = {.added = flecs_type_to_ids(src_type)};
 
     ecs_entity_info_t dst_info = {0};
-    dst_info.row = new_entity(world, dst, &dst_info, src_table, &diff, 
+    dst_info.row = new_entity(world, dst, &dst_info, src_table, &diff,
         true, true);
 
     if (copy_value) {
-        flecs_table_move(world, dst, src, src_table, dst_info.data, 
+        flecs_table_move(world, dst, src, src_table, dst_info.data,
             dst_info.row, src_table, src_info.data, src_info.row, true);
 
         flecs_notify_on_set(world, src_table, dst_info.row, 1, NULL, true);
@@ -7004,7 +7004,7 @@ const void* ecs_get_id(
 {
     ecs_check(world != NULL, ECS_INVALID_PARAMETER, NULL);
     ecs_check(ecs_is_valid(world, entity), ECS_INVALID_PARAMETER, NULL);
-    ecs_check(flecs_stage_from_readonly_world(world)->asynchronous == false, 
+    ecs_check(flecs_stage_from_readonly_world(world)->asynchronous == false,
         ECS_INVALID_PARAMETER, NULL);
 
     world = ecs_get_world(world);
@@ -7052,9 +7052,9 @@ const void* ecs_get_ref_id(
 {
     ecs_check(world != NULL, ECS_INVALID_PARAMETER, NULL);
     ecs_check(ref != NULL, ECS_INVALID_PARAMETER, NULL);
-    ecs_check(!entity || !ref->entity || entity == ref->entity, 
+    ecs_check(!entity || !ref->entity || entity == ref->entity,
         ECS_INVALID_PARAMETER, NULL);
-    ecs_check(!id || !ref->component || id == ref->component, 
+    ecs_check(!id || !ref->component || id == ref->component,
         ECS_INVALID_PARAMETER, NULL);
     ecs_record_t *record = ref->record;
 
@@ -7109,7 +7109,7 @@ void* ecs_get_mut_id(
     ecs_check(world != NULL, ECS_INVALID_PARAMETER, NULL);
     ecs_check(ecs_is_valid(world, entity), ECS_INVALID_PARAMETER, NULL);
     ecs_check(ecs_is_valid(world, id), ECS_INVALID_PARAMETER, NULL);
-    
+
     ecs_stage_t *stage = flecs_stage_from_world(&world);
     void *result;
 
@@ -7122,25 +7122,25 @@ void* ecs_get_mut_id(
     ecs_entity_info_t info;
     result = get_mutable(world, entity, id, &info, is_added);
     ecs_check(result != NULL, ECS_INVALID_PARAMETER, NULL);
-    
+
     /* Store table so we can quickly check if returned pointer is still valid */
     ecs_table_t *table = info.record->table;
     ecs_assert(table != NULL, ECS_INTERNAL_ERROR, NULL);
 
     /* Keep track of alloc count of table, since even if the entity has not
      * moved, other entities could have been added to the table which could
-     * reallocate arrays. Also store the row, as the entity could have 
+     * reallocate arrays. Also store the row, as the entity could have
      * reallocated. */
     int32_t alloc_count = table->alloc_count;
     uint32_t row = info.record->row;
-    
+
     flecs_defer_flush(world, stage);
 
     /* Ensure that after flushing, the pointer is still valid. Flushing may
      * trigger callbacks, which could do anything with the entity */
-    if (table != info.record->table || 
+    if (table != info.record->table ||
         alloc_count != info.record->table->alloc_count ||
-        row != info.record->row) 
+        row != info.record->row)
     {
         if (flecs_get_info(world, entity, &info) && info.table) {
             result = get_component(world, info.table, info.row, id);
@@ -7205,7 +7205,7 @@ void ecs_modified_id(
         return;
     }
 
-    /* If the entity does not have the component, calling ecs_modified is 
+    /* If the entity does not have the component, calling ecs_modified is
      * invalid. The assert needs to happen after the defer statement, as the
      * entity may not have the component when this function is called while
      * operations are being deferred. */
@@ -7243,7 +7243,7 @@ ecs_entity_t assign_ptr_w_id(
         }
     }
 
-    if (flecs_defer_set(world, stage, EcsOpSet, entity, id, 
+    if (flecs_defer_set(world, stage, EcsOpSet, entity, id,
         flecs_utosize(size), ptr, NULL, NULL))
     {
         return entity;
@@ -7261,7 +7261,7 @@ ecs_entity_t assign_ptr_w_id(
             if (is_move) {
                 ecs_move_t move = cdata->lifecycle.move;
                 if (move) {
-                    move(world, real_id, &entity, &entity, dst, ptr, size, 1, 
+                    move(world, real_id, &entity, &entity, dst, ptr, size, 1,
                         cdata->lifecycle.ctx);
                 } else {
                     ecs_os_memcpy(dst, ptr, flecs_utosize(size));
@@ -7269,7 +7269,7 @@ ecs_entity_t assign_ptr_w_id(
             } else {
                 ecs_copy_t copy = cdata->lifecycle.copy;
                 if (copy) {
-                    copy(world, real_id, &entity, &entity, dst, ptr, size, 1, 
+                    copy(world, real_id, &entity, &entity, dst, ptr, size, 1,
                         cdata->lifecycle.ctx);
                 } else {
                     ecs_os_memcpy(dst, ptr, flecs_utosize(size));
@@ -7343,8 +7343,8 @@ ecs_entity_t ecs_get_case(
 
     /* Data cannot be NULl, since entity is stored in the table */
     ecs_assert(info.data != NULL, ECS_INTERNAL_ERROR, NULL);
-    ecs_switch_t *sw = info.data->sw_columns[index].data;  
-    return flecs_switch_get(sw, info.row);  
+    ecs_switch_t *sw = info.data->sw_columns[index].data;
+    return flecs_switch_get(sw, info.row);
 error:
     return 0;
 }
@@ -7374,7 +7374,7 @@ void ecs_enable_component_w_id(
     flecs_get_info(world, entity, &info);
 
     ecs_entity_t bs_id = (id & ECS_COMPONENT_MASK) | ECS_DISABLED;
-    
+
     ecs_table_t *table = info.table;
     int32_t index = -1;
     if (table) {
@@ -7431,7 +7431,7 @@ bool ecs_is_component_enabled_w_id(
 
     /* Data cannot be NULl, since entity is stored in the table */
     ecs_assert(info.data != NULL, ECS_INTERNAL_ERROR, NULL);
-    ecs_bitset_t *bs = &info.data->bs_columns[index].data;  
+    ecs_bitset_t *bs = &info.data->bs_columns[index].data;
 
     return flecs_bitset_get(bs, info.row);
 error:
@@ -7459,7 +7459,7 @@ bool ecs_has_id(
 
         int32_t index = flecs_table_switch_from_case(world, table, id);
         ecs_assert(index < table->sw_column_count, ECS_INTERNAL_ERROR, NULL);
-        
+
         ecs_data_t *data = info.data;
         ecs_switch_t *sw = data->sw_columns[index].data;
         ecs_entity_t value = flecs_switch_get(sw, info.row);
@@ -7472,7 +7472,7 @@ bool ecs_has_id(
         }
 
         return ecs_search_relation(
-            world, table, 0, id, EcsIsA, 0, 0, 
+            world, table, 0, id, EcsIsA, 0, 0,
                 NULL, NULL, NULL) != -1;
     }
 error:
@@ -7598,7 +7598,7 @@ ecs_entity_t set_identifier(
     if (!entity) {
         entity = ecs_new_id(world);
     }
-    
+
     ecs_set_pair(world, entity, EcsIdentifier, tag, {.value = (char*)name});
     return entity;
 error:
@@ -7644,7 +7644,7 @@ bool ecs_is_valid(
     if (entity & ~0xFF00FFFFFFFFFFFF) {
         return false;
     }
-    
+
     /* Make sure we're not working with a stage */
     world = ecs_get_world(world);
 
@@ -7696,7 +7696,7 @@ ecs_entity_t ecs_get_alive(
     ecs_entity_t entity)
 {
     ecs_check(world != NULL, ECS_INVALID_PARAMETER, NULL);
-    
+
     if (!entity) {
         return 0;
     }
@@ -7761,7 +7761,7 @@ ecs_table_t* ecs_get_table(
 {
     ecs_check(world != NULL, ECS_INVALID_PARAMETER, NULL);
     ecs_check(ecs_is_valid(world, entity), ECS_INVALID_PARAMETER, NULL);
-    
+
     world = ecs_get_world(world);
 
     ecs_record_t *record = ecs_eis_get(world, entity);
@@ -7782,7 +7782,7 @@ ecs_table_t* ecs_get_storage_table(
        return table->storage_table;
     }
 
-    return NULL;   
+    return NULL;
 }
 
 ecs_type_t ecs_get_type(
@@ -7819,12 +7819,12 @@ ecs_id_t ecs_get_typeid(
         if (ptr && ptr->size != 0) {
             return rel;
         }
-        
+
         ecs_entity_t obj = ECS_PAIR_OBJECT(id);
         if (obj) {
             obj = ecs_get_alive(world, obj);
             ptr = ecs_get(world, obj, EcsComponent);
-            
+
             if (ptr && ptr->size != 0) {
                 return obj;
             }
@@ -7915,7 +7915,7 @@ const char* ecs_role_str(
     } else
     if (ECS_HAS_ROLE(entity, DISABLED)) {
         return "DISABLED";
-    } else    
+    } else
     if (ECS_HAS_ROLE(entity, XOR)) {
         return "XOR";
     } else
@@ -8049,13 +8049,13 @@ void free_value(
     ecs_entity_t real_id = ecs_get_typeid(world, id);
     const ecs_type_info_t *info = flecs_get_c_info(world, real_id);
     ecs_xtor_t dtor;
-    
+
     if (info && (dtor = info->lifecycle.dtor)) {
         ecs_size_t size = info->size;
         void *ptr;
         int i;
         for (i = 0, ptr = value; i < count; i ++, ptr = ECS_OFFSET(ptr, size)) {
-            dtor(world, id, &entities[i], ptr, flecs_itosize(size), 1, 
+            dtor(world, id, &entities[i], ptr, flecs_itosize(size), 1,
                 info->lifecycle.ctx);
         }
     }
@@ -8077,7 +8077,7 @@ void discard_op(
     }
 }
 
-static 
+static
 bool is_entity_valid(
     ecs_world_t *world,
     ecs_entity_t e)
@@ -8156,7 +8156,7 @@ bool flecs_defer_flush(
         if (defer_queue) {
             ecs_defer_op_t *ops = ecs_vector_first(defer_queue, ecs_defer_op_t);
             int32_t i, count = ecs_vector_count(defer_queue);
-            
+
             for (i = 0; i < count; i ++) {
                 ecs_defer_op_t *op = &ops[i];
                 ecs_entity_t e = op->is._1.entity;
@@ -8168,7 +8168,7 @@ bool flecs_defer_flush(
                  * contained both a delete and a subsequent add/remove/set which
                  * should be ignored. */
                 if (e && !ecs_is_alive(world, e) && ecs_eis_exists(world, e)) {
-                    ecs_assert(op->kind != EcsOpNew && op->kind != EcsOpClone, 
+                    ecs_assert(op->kind != EcsOpNew && op->kind != EcsOpClone,
                         ECS_INTERNAL_ERROR, NULL);
                     world->discard_count ++;
                     discard_op(world, op);
@@ -8195,13 +8195,13 @@ bool flecs_defer_flush(
                     ecs_clone(world, e, op->id, op->is._1.clone_value);
                     break;
                 case EcsOpSet:
-                    assign_ptr_w_id(world, e, 
-                        op->id, flecs_itosize(op->is._1.size), 
+                    assign_ptr_w_id(world, e,
+                        op->id, flecs_itosize(op->is._1.size),
                         op->is._1.value, true, true);
                     break;
                 case EcsOpMut:
-                    assign_ptr_w_id(world, e, 
-                        op->id, flecs_itosize(op->is._1.size), 
+                    assign_ptr_w_id(world, e,
+                        op->id, flecs_itosize(op->is._1.size),
                         op->is._1.value, true, false);
                     break;
                 case EcsOpModified:
@@ -8230,7 +8230,7 @@ bool flecs_defer_flush(
 
                 if (op->is._1.value) {
                     ecs_os_free(op->is._1.value);
-                }                  
+                }
             }
 
             if (stage->defer_queue) {
@@ -8322,7 +8322,7 @@ bool defer_add_remove(
     } else {
         stage->defer ++;
     }
-    
+
     return false;
 }
 
@@ -8349,7 +8349,7 @@ void merge_stages(
             ecs_defer_end((ecs_world_t*)stage);
         }
     } else {
-        /* Merge stages. Only merge if the stage has auto_merging turned on, or 
+        /* Merge stages. Only merge if the stage has auto_merging turned on, or
          * if this is a forced merge (like when ecs_merge is called) */
         int32_t i, count = ecs_get_stage_count(world);
         for (i = 0; i < count; i ++) {
@@ -8367,7 +8367,7 @@ void merge_stages(
         world->stats.merge_time_total += (float)ecs_time_measure(&t_start);
     }
 
-    world->stats.merge_count_total ++; 
+    world->stats.merge_count_total ++;
 
     /* If stage is asynchronous, deferring is always enabled */
     if (stage->asynchronous) {
@@ -8413,7 +8413,7 @@ bool flecs_defer_modified(
     } else {
         stage->defer ++;
     }
-    
+
     return false;
 }
 
@@ -8423,7 +8423,7 @@ bool flecs_defer_clone(
     ecs_entity_t entity,
     ecs_entity_t src,
     bool clone_value)
-{   
+{
     (void)world;
     if (stage->defer) {
         ecs_defer_op_t *op = new_defer_op(stage);
@@ -8435,8 +8435,8 @@ bool flecs_defer_clone(
     } else {
         stage->defer ++;
     }
-    
-    return false;   
+
+    return false;
 }
 
 bool flecs_defer_delete(
@@ -8554,7 +8554,7 @@ bool flecs_defer_new(
     ecs_stage_t *stage,
     ecs_entity_t entity,
     ecs_id_t id)
-{   
+{
     return defer_add_remove(world, stage, EcsOpNew, entity, id);
 }
 
@@ -8563,7 +8563,7 @@ bool flecs_defer_add(
     ecs_stage_t *stage,
     ecs_entity_t entity,
     ecs_id_t id)
-{   
+{
     return defer_add_remove(world, stage, EcsOpAdd, entity, id);
 }
 
@@ -8618,8 +8618,8 @@ bool flecs_defer_set(
         if (value) {
             ecs_copy_ctor_t copy;
             if (c_info && (copy = c_info->lifecycle.copy_ctor)) {
-                copy(world, id, &c_info->lifecycle, &entity, &entity, 
-                    op->is._1.value, value, flecs_itosize(size), 1, 
+                copy(world, id, &c_info->lifecycle, &entity, &entity,
+                    op->is._1.value, value, flecs_itosize(size), 1,
                         c_info->lifecycle.ctx);
             } else {
                 ecs_os_memcpy(op->is._1.value, value, size);
@@ -8627,7 +8627,7 @@ bool flecs_defer_set(
         } else {
             ecs_xtor_t ctor;
             if (c_info && (ctor = c_info->lifecycle.ctor)) {
-                ctor(world, id, &entity, op->is._1.value, 
+                ctor(world, id, &entity, op->is._1.value,
                     flecs_itosize(size), 1, c_info->lifecycle.ctx);
             }
         }
@@ -8681,7 +8681,7 @@ void flecs_stage_deinit(
     ecs_poly_assert(stage, ecs_stage_t);
 
     /* Make sure stage has no unmerged data */
-    ecs_assert(ecs_vector_count(stage->defer_queue) == 0, 
+    ecs_assert(ecs_vector_count(stage->defer_queue) == 0,
         ECS_INTERNAL_ERROR, NULL);
 
     ecs_poly_fini(stage, ecs_stage_t);
@@ -8712,7 +8712,7 @@ void ecs_set_stages(
 
         ecs_vector_free(world->worker_stages);
     }
-    
+
     if (stage_count) {
         world->worker_stages = ecs_vector_new(ecs_stage_t, stage_count);
 
@@ -8773,7 +8773,7 @@ ecs_world_t* ecs_get_stage(
     int32_t stage_id)
 {
     ecs_poly_assert(world, ecs_world_t);
-    ecs_check(ecs_vector_count(world->worker_stages) > stage_id, 
+    ecs_check(ecs_vector_count(world->worker_stages) > stage_id,
         ECS_INVALID_PARAMETER, NULL);
 
     return (ecs_world_t*)ecs_vector_get(
@@ -8794,7 +8794,7 @@ bool ecs_staging_begin(
 
     bool is_readonly = world->is_readonly;
 
-    /* From this point on, the world is "locked" for mutations, and it is only 
+    /* From this point on, the world is "locked" for mutations, and it is only
      * allowed to enqueue commands from stages */
     world->is_readonly = true;
 
@@ -8823,7 +8823,7 @@ void ecs_merge(
     ecs_world_t *world)
 {
     ecs_check(world != NULL, ECS_INVALID_PARAMETER, NULL);
-    ecs_check(ecs_poly_is(world, ecs_world_t) || 
+    ecs_check(ecs_poly_is(world, ecs_world_t) ||
                ecs_poly_is(world, ecs_stage_t), ECS_INVALID_PARAMETER, NULL);
     do_manual_merge(world);
 error:
@@ -8914,7 +8914,7 @@ bool ecs_stage_is_async(
     if (!stage) {
         return false;
     }
-    
+
     if (!ecs_poly_is(stage, ecs_stage_t)) {
         return false;
     }
@@ -8953,7 +8953,7 @@ ecs_vector_t* _ecs_vector_new(
     int32_t elem_count)
 {
     ecs_assert(elem_size != 0, ECS_INTERNAL_ERROR, NULL);
-    
+
     ecs_vector_t *result =
         ecs_os_malloc(offset + elem_size * elem_count);
     ecs_assert(result != NULL, ECS_OUT_OF_MEMORY, NULL);
@@ -8973,7 +8973,7 @@ ecs_vector_t* _ecs_vector_from_array(
     void *array)
 {
     ecs_assert(elem_size != 0, ECS_INTERNAL_ERROR, NULL);
-    
+
     ecs_vector_t *result =
         ecs_os_malloc(offset + elem_size * elem_count);
     ecs_assert(result != NULL, ECS_OUT_OF_MEMORY, NULL);
@@ -8985,7 +8985,7 @@ ecs_vector_t* _ecs_vector_from_array(
 #ifndef NDEBUG
     result->elem_size = elem_size;
 #endif
-    return result;   
+    return result;
 }
 
 void ecs_vector_free(
@@ -9016,7 +9016,7 @@ void ecs_vector_assert_size(
     ecs_size_t elem_size)
 {
     (void)elem_size;
-    
+
     if (vector) {
         ecs_dbg_assert(vector->elem_size == elem_size, ECS_INTERNAL_ERROR, NULL);
     }
@@ -9029,11 +9029,11 @@ void* _ecs_vector_addn(
     int32_t elem_count)
 {
     ecs_assert(array_inout != NULL, ECS_INTERNAL_ERROR, NULL);
-    
+
     if (elem_count == 1) {
         return _ecs_vector_add(array_inout, elem_size, offset);
     }
-    
+
     ecs_vector_t *vector = *array_inout;
     if (!vector) {
         vector = _ecs_vector_new(elem_size, offset, 1);
@@ -9117,7 +9117,7 @@ void* _ecs_vector_insert_at(
     _ecs_vector_add(vec, elem_size, offset);
     void *start = _ecs_vector_get(*vec, elem_size, offset, index);
     if (index < count) {
-        ecs_os_memmove(ECS_OFFSET(start, elem_size), start, 
+        ecs_os_memmove(ECS_OFFSET(start, elem_size), start,
             (count - index) * elem_size);
     }
 
@@ -9184,7 +9184,7 @@ int32_t _ecs_vector_remove(
     int32_t index)
 {
     ecs_dbg_assert(vector->elem_size == elem_size, ECS_INTERNAL_ERROR, NULL);
-    
+
     int32_t count = vector->count;
     void *buffer = ECS_OFFSET(vector, offset);
     void *elem = ECS_OFFSET(buffer, index * elem_size);
@@ -9210,7 +9210,7 @@ void _ecs_vector_reclaim(
     ecs_vector_t *vector = *array_inout;
 
     ecs_dbg_assert(vector->elem_size == elem_size, ECS_INTERNAL_ERROR, NULL);
-    
+
     int32_t size = vector->size;
     int32_t count = vector->count;
 
@@ -9321,7 +9321,7 @@ void* _ecs_vector_get(
     int32_t index)
 {
     ecs_assert(vector != NULL, ECS_INTERNAL_ERROR, NULL);
-    ecs_dbg_assert(vector->elem_size == elem_size, ECS_INTERNAL_ERROR, NULL);    
+    ecs_dbg_assert(vector->elem_size == elem_size, ECS_INTERNAL_ERROR, NULL);
     ecs_assert(index >= 0, ECS_INTERNAL_ERROR, NULL);
     ecs_assert(index < vector->count, ECS_INTERNAL_ERROR, NULL);
 
@@ -9385,7 +9385,7 @@ void _ecs_vector_sort(
         return;
     }
 
-    ecs_dbg_assert(vector->elem_size == elem_size, ECS_INTERNAL_ERROR, NULL);    
+    ecs_dbg_assert(vector->elem_size == elem_size, ECS_INTERNAL_ERROR, NULL);
 
     int32_t count = vector->count;
     void *buffer = ECS_OFFSET(vector, offset);
@@ -9445,7 +9445,7 @@ ecs_vector_t* _ecs_vector_copy(
 
 typedef struct chunk_t {
     int32_t *sparse;            /* Sparse array with indices to dense array */
-    void *data;                 /* Store data in sparse array to reduce  
+    void *data;                 /* Store data in sparse array to reduce
                                  * indirection and provide stable pointers. */
 } chunk_t;
 
@@ -9486,11 +9486,11 @@ chunk_t* chunk_new(
 
     /* Initialize sparse array with zero's, as zero is used to indicate that the
      * sparse element has not been paired with a dense element. Use zero
-     * as this means we can take advantage of calloc having a possibly better 
+     * as this means we can take advantage of calloc having a possibly better
      * performance than malloc + memset. */
     result->sparse = ecs_os_calloc(ECS_SIZEOF(int32_t) * CHUNK_COUNT);
 
-    /* Initialize the data array with zero's to guarantee that data is 
+    /* Initialize the data array with zero's to guarantee that data is
      * always initialized. When an entry is removed, data is reset back to
      * zero. Initialize now, as this can take advantage of calloc. */
     result->data = ecs_os_calloc(sparse->size * CHUNK_COUNT);
@@ -9566,9 +9566,9 @@ uint64_t strip_generation(
 
 static
 void assign_index(
-    chunk_t * chunk, 
-    uint64_t * dense_array, 
-    uint64_t index, 
+    chunk_t * chunk,
+    uint64_t * dense_array,
+    uint64_t index,
     int32_t dense)
 {
     /* Initialize sparse-dense pair. This assigns the dense index to the sparse
@@ -9608,8 +9608,8 @@ void set_id(
     ecs_sparse_t *sparse,
     uint64_t value)
 {
-    /* Sometimes the max id needs to be assigned directly, which typically 
-     * happens when the API calls get_or_create for an id that hasn't been 
+    /* Sometimes the max id needs to be assigned directly, which typically
+     * happens when the API calls get_or_create for an id that hasn't been
      * issued before. */
     sparse->max_id[0] = value;
 }
@@ -9625,10 +9625,10 @@ uint64_t create_id(
 
     chunk_t *chunk = get_or_create_chunk(sparse, CHUNK(index));
     ecs_assert(chunk->sparse[OFFSET(index)] == 0, ECS_INTERNAL_ERROR, NULL);
-    
+
     uint64_t *dense_array = ecs_vector_first(sparse->dense, uint64_t);
     assign_index(chunk, dense_array, index, dense);
-    
+
     return index;
 }
 
@@ -9658,7 +9658,7 @@ static
 void* try_sparse_any(
     const ecs_sparse_t *sparse,
     uint64_t index)
-{    
+{
     strip_generation(&index);
 
     chunk_t *chunk = get_chunk(sparse, CHUNK(index));
@@ -9718,7 +9718,7 @@ void* get_sparse(
     strip_generation(&index);
     chunk_t *chunk = get_chunk(sparse, CHUNK(index));
     int32_t offset = OFFSET(index);
-    
+
     ecs_assert(chunk != NULL, ECS_INTERNAL_ERROR, NULL);
     ecs_assert(dense == chunk->sparse[offset], ECS_INTERNAL_ERROR, NULL);
     (void)dense;
@@ -9784,7 +9784,7 @@ void flecs_sparse_clear(
     ecs_vector_free(sparse->chunks);
     ecs_vector_set_count(&sparse->dense, uint64_t, 1);
 
-    sparse->chunks = NULL;   
+    sparse->chunks = NULL;
     sparse->count = 1;
     sparse->max_id_local = 0;
 }
@@ -9889,7 +9889,7 @@ void* _flecs_sparse_ensure(
          * using the ensure function in combination with ids that have their
          * generation stripped. */
         ecs_vector_t *dense_vector = sparse->dense;
-        uint64_t *dense_array = ecs_vector_first(dense_vector, uint64_t);    
+        uint64_t *dense_array = ecs_vector_first(dense_vector, uint64_t);
         ecs_assert(!gen || dense_array[dense] == (index | gen), ECS_INTERNAL_ERROR, NULL);
         (void)dense_vector;
         (void)dense_array;
@@ -9898,7 +9898,7 @@ void* _flecs_sparse_ensure(
         grow_dense(sparse);
 
         ecs_vector_t *dense_vector = sparse->dense;
-        uint64_t *dense_array = ecs_vector_first(dense_vector, uint64_t);    
+        uint64_t *dense_array = ecs_vector_first(dense_vector, uint64_t);
         int32_t dense_count = ecs_vector_count(dense_vector) - 1;
         int32_t count = sparse->count ++;
 
@@ -9958,7 +9958,7 @@ void* _flecs_sparse_remove_get(
 
         /* Increase generation */
         dense_array[dense] = index | inc_gen(cur_gen);
-        
+
         int32_t count = sparse->count;
         if (dense == (count - 1)) {
             /* If dense is the last used element, simply decrease count */
@@ -9996,7 +9996,7 @@ void flecs_sparse_set_generation(
 {
     ecs_assert(sparse != NULL, ECS_INVALID_PARAMETER, NULL);
     chunk_t *chunk = get_or_create_chunk(sparse, CHUNK(index));
-    
+
     uint64_t index_w_gen = index;
     strip_generation(&index);
     int32_t offset = OFFSET(index);
@@ -10020,7 +10020,7 @@ bool flecs_sparse_exists(
     if (!chunk) {
         return false;
     }
-    
+
     strip_generation(&index);
     int32_t offset = OFFSET(index);
     int32_t dense = chunk->sparse[offset];
@@ -10108,7 +10108,7 @@ int32_t flecs_sparse_size(
     if (!sparse) {
         return 0;
     }
-        
+
     return ecs_vector_count(sparse->dense) - 1;
 }
 
@@ -10134,7 +10134,7 @@ void sparse_copy(
 {
     flecs_sparse_set_size(dst, flecs_sparse_size(src));
     const uint64_t *indices = flecs_sparse_ids(src);
-    
+
     ecs_size_t size = src->size;
     int32_t i, count = src->count;
 
@@ -10243,7 +10243,7 @@ ecs_sparse_iter_t _flecs_sparse_iter(
 
 
 #ifdef FLECS_SANITIZE
-static 
+static
 void verify_nodes(
     flecs_switch_header_t *hdr,
     flecs_switch_node_t *nodes)
@@ -10300,7 +10300,7 @@ void remove_node(
         /* If this is the first node, update the header */
         hdr->element = node->next;
     } else {
-        /* If this is not the first node, update the previous node to the 
+        /* If this is not the first node, update the previous node to the
          * removed node's next ptr */
         ecs_assert(node->prev != -1, ECS_INVALID_PARAMETER, NULL);
         flecs_switch_node_t *prev_node = &nodes[node->prev];
@@ -10323,7 +10323,7 @@ void remove_node(
 }
 
 ecs_switch_t* flecs_switch_new(
-    uint64_t min, 
+    uint64_t min,
     uint64_t max,
     int32_t elements)
 {
@@ -10351,7 +10351,7 @@ ecs_switch_t* flecs_switch_new(
     flecs_switch_node_t *nodes = ecs_vector_first(
         result->nodes, flecs_switch_node_t);
     uint64_t *values = ecs_vector_first(
-        result->values, uint64_t);        
+        result->values, uint64_t);
 
     for (i = 0; i < elements; i ++) {
         nodes[i].prev = -1;
@@ -10476,7 +10476,7 @@ void flecs_switch_set(
         }
 
         dst_hdr->element = element;
-        dst_hdr->count ++;        
+        dst_hdr->count ++;
     }
 }
 
@@ -10517,7 +10517,7 @@ void flecs_switch_remove(
         } else {
             flecs_switch_header_t *hdr = get_header(sw, values[last_elem]);
             if (hdr && hdr->element != -1) {
-                ecs_assert(hdr->element == last_elem, 
+                ecs_assert(hdr->element == last_elem,
                     ECS_INTERNAL_ERROR, NULL);
                 hdr->element = element;
             }
@@ -10579,7 +10579,7 @@ int32_t flecs_switch_first(
     ecs_assert(sw != NULL, ECS_INVALID_PARAMETER, NULL);
     ecs_assert((uint32_t)value <= sw->max, ECS_INVALID_PARAMETER, NULL);
     ecs_assert((uint32_t)value >= sw->min, ECS_INVALID_PARAMETER, NULL);
-    
+
     flecs_switch_header_t *hdr = get_header(sw, value);
     ecs_assert(hdr != NULL, ECS_INVALID_PARAMETER, NULL);
 
@@ -10666,7 +10666,7 @@ This was tested for:
   the output delta to a Gray code (a^(a>>1)) so a string of 1's (as
   is commonly produced by subtraction) look like a single 1-bit
   difference.
-* the base values were pseudorandom, all zero but one bit set, or 
+* the base values were pseudorandom, all zero but one bit set, or
   all zero plus a counter that starts at zero.
 Some k values for my "a-=c; a^=rot(c,k); c+=b;" arrangement that
 satisfy this are
@@ -10675,7 +10675,7 @@ satisfy this are
    14  9  3  7 17  3
 Well, "9 15 3 18 27 15" didn't quite get 32 bits diffing
 for "differ" defined as + with a one-bit base and a two-bit delta.  I
-used http://burtleburtle.net/bob/hash/avalanche.html to choose 
+used http://burtleburtle.net/bob/hash/avalanche.html to choose
 the operations, constants, and arrangements of the variables.
 This does not achieve avalanche.  There are input bits of (a,b,c)
 that fail to affect some output bits of (a,b,c), especially of a.  The
@@ -10711,7 +10711,7 @@ produce values of c that look totally different.  This was tested for
   the output delta to a Gray code (a^(a>>1)) so a string of 1's (as
   is commonly produced by subtraction) look like a single 1-bit
   difference.
-* the base values were pseudorandom, all zero but one bit set, or 
+* the base values were pseudorandom, all zero but one bit set, or
   all zero plus a counter that starts at zero.
 These constants passed:
  14 11 25 16 4 14 24
@@ -10745,7 +10745,7 @@ and these came close:
  * a 64-bit value do something like "*pc + (((uint64_t)*pb)<<32)".
  */
 static
-void hashlittle2( 
+void hashlittle2(
   const void *key,       /* the key to hash */
   size_t      length,    /* length of the key */
   uint32_t   *pc,        /* IN: primary initval, OUT: primary hash */
@@ -10776,7 +10776,7 @@ void hashlittle2(
     }
 
     /*----------------------------- handle the last (probably partial) block */
-    /* 
+    /*
      * "k[2]&0xffffff" actually reads beyond the end of the string, but
      * then masks off the part it's not allowed to read.  Because the
      * string is aligned, the masked-off tail is in the same word as the
@@ -10938,9 +10938,9 @@ uint64_t flecs_hash(
 
 
 void ecs_qsort(
-    void *base, 
-    ecs_size_t nitems, 
-    ecs_size_t size, 
+    void *base,
+    ecs_size_t nitems,
+    ecs_size_t size,
     int (*compar)(const void *, const void*))
 {
     void *tmp = ecs_os_alloca(size); /* For swap */
@@ -11094,8 +11094,8 @@ static const double rounders[MAX_PRECISION + 1] =
 
 static
 int ecs_strbuf_ftoa(
-    ecs_strbuf_t *out, 
-    double f, 
+    ecs_strbuf_t *out,
+    double f,
     int precision)
 {
     char buf[64];
@@ -11159,7 +11159,7 @@ int ecs_strbuf_ftoa(
 		}
 	}
 	*ptr = 0;
-    
+
     return ecs_strbuf_appendstrn(out, buf, (int32_t)(ptr - buf));
 }
 
@@ -11454,7 +11454,7 @@ bool ecs_strbuf_appendch(
     ecs_strbuf_t *b,
     char ch)
 {
-    ecs_assert(b != NULL, ECS_INVALID_PARAMETER, NULL); 
+    ecs_assert(b != NULL, ECS_INVALID_PARAMETER, NULL);
     return appendch(b, ch);
 }
 
@@ -11462,7 +11462,7 @@ bool ecs_strbuf_appendflt(
     ecs_strbuf_t *b,
     double flt)
 {
-    ecs_assert(b != NULL, ECS_INVALID_PARAMETER, NULL); 
+    ecs_assert(b != NULL, ECS_INVALID_PARAMETER, NULL);
     return ecs_strbuf_ftoa(b, flt, 2);
 }
 
@@ -11524,7 +11524,7 @@ bool ecs_strbuf_mergebuff(
 }
 
 char* ecs_strbuf_get(
-    ecs_strbuf_t *b) 
+    ecs_strbuf_t *b)
 {
     ecs_assert(b != NULL, ECS_INVALID_PARAMETER, NULL);
 
@@ -11581,7 +11581,7 @@ char *ecs_strbuf_get_small(
 }
 
 void ecs_strbuf_reset(
-    ecs_strbuf_t *b) 
+    ecs_strbuf_t *b)
 {
     ecs_assert(b != NULL, ECS_INVALID_PARAMETER, NULL);
 
@@ -11625,7 +11625,7 @@ void ecs_strbuf_list_pop(
     ecs_assert(list_close != NULL, ECS_INVALID_PARAMETER, NULL);
 
     b->list_sp --;
-    
+
     if (list_close) {
         ecs_strbuf_appendstr(b, list_close);
     }
@@ -11712,7 +11712,7 @@ int32_t get_bucket_count(
 static
 int32_t get_bucket_id(
     int32_t bucket_count,
-    ecs_map_key_t key) 
+    ecs_map_key_t key)
 {
     ecs_assert(bucket_count > 0, ECS_INTERNAL_ERROR, NULL);
     int32_t result = (int32_t)(key & ((uint64_t)bucket_count - 1));
@@ -11750,7 +11750,7 @@ void ensure_buckets(
         map->bucket_count = new_count;
 
         ecs_os_memset(
-            ECS_OFFSET(map->buckets, bucket_count * ECS_SIZEOF(ecs_bucket_t)), 
+            ECS_OFFSET(map->buckets, bucket_count * ECS_SIZEOF(ecs_bucket_t)),
             0, (new_count - bucket_count) * ECS_SIZEOF(ecs_bucket_t));
     }
 }
@@ -11832,7 +11832,7 @@ void remove_from_bucket(
 
     ecs_assert(bucket->count != 0, ECS_INTERNAL_ERROR, NULL);
     ecs_assert(index < bucket->count, ECS_INTERNAL_ERROR, NULL);
-    
+
     int32_t bucket_count = -- bucket->count;
 
     if (index != bucket->count) {
@@ -11879,7 +11879,7 @@ void rehash(
 
     ecs_bucket_t *buckets = map->buckets;
     ecs_assert(buckets != NULL, ECS_INTERNAL_ERROR, NULL);
-    
+
     int32_t bucket_id;
 
     /* Iterate backwards as elements could otherwise be moved to existing
@@ -12019,7 +12019,7 @@ void* _ecs_map_set(
 
     void *elem = get_from_bucket(bucket, key, elem_size);
     if (!elem) {
-        int32_t index = add_to_bucket(bucket, elem_size, key, payload);        
+        int32_t index = add_to_bucket(bucket, elem_size, key, payload);
         int32_t map_count = ++map->count;
         int32_t target_bucket_count = get_bucket_count(map_count);
         int32_t map_bucket_count = map->bucket_count;
@@ -12030,7 +12030,7 @@ void* _ecs_map_set(
             return get_from_bucket(bucket, key, elem_size);
         } else {
             return GET_ELEM(bucket->payload, elem_size, index);
-        }       
+        }
     } else {
         if (payload) {
             ecs_os_memcpy(elem, payload, elem_size);
@@ -12101,9 +12101,9 @@ void* _ecs_map_next(
     if (!map) {
         return NULL;
     }
-    
+
     ecs_assert(!elem_size || elem_size == map->elem_size, ECS_INVALID_PARAMETER, NULL);
- 
+
     ecs_bucket_t *bucket = iter->bucket;
     int32_t element_index = iter->element_index;
     elem_size = map->elem_size;
@@ -12131,7 +12131,7 @@ void* _ecs_map_next(
             iter->bucket_index ++;
         }
     } while (true);
-    
+
     if (key_out) {
         *key_out = bucket->keys[element_index];
     }
@@ -12152,7 +12152,7 @@ void* _ecs_map_next_ptr(
 }
 
 void ecs_map_grow(
-    ecs_map_t *map, 
+    ecs_map_t *map,
     int32_t element_count)
 {
     ecs_assert(map != NULL, ECS_INVALID_PARAMETER, NULL);
@@ -12165,9 +12165,9 @@ void ecs_map_grow(
 }
 
 void ecs_map_set_size(
-    ecs_map_t *map, 
+    ecs_map_t *map,
     int32_t element_count)
-{    
+{
     ecs_assert(map != NULL, ECS_INVALID_PARAMETER, NULL);
     int32_t bucket_count = get_bucket_count(element_count);
 
@@ -12197,7 +12197,7 @@ ecs_map_t* ecs_map_copy(
 }
 
 void ecs_map_memory(
-    ecs_map_t *map, 
+    ecs_map_t *map,
     int32_t *allocd,
     int32_t *used)
 {
@@ -12231,7 +12231,7 @@ static
 int32_t find_key(
     ecs_hashmap_t map,
     ecs_vector_t *keys,
-    ecs_size_t key_size, 
+    ecs_size_t key_size,
     const void *key)
 {
     int32_t i, count = ecs_vector_count(keys);
@@ -12435,7 +12435,7 @@ void* _flecs_hashmap_next(
     if (key_out) {
         *(void**)key_out = ecs_vector_get_t(bucket->keys, key_size, 8, index);
     }
-    
+
     return ecs_vector_get_t(bucket->values, value_size, 8, index);
 }
 
@@ -12460,14 +12460,14 @@ char *ecs_vasprintf(
 
     va_end(tmpa);
 
-    if ((int32_t)size < 0) { 
-        return NULL; 
+    if ((int32_t)size < 0) {
+        return NULL;
     }
 
     result = (char *) ecs_os_malloc(size + 1);
 
-    if (!result) { 
-        return NULL; 
+    if (!result) {
+        return NULL;
     }
 
     ecs_os_vsprintf(result, fmt, args);
@@ -12620,7 +12620,7 @@ void _ecs_logv(
     char *msg_nocolor = ecs_vasprintf(fmt, args);
     ecs_colorize_buf(msg_nocolor, ecs_os_api.log_with_color_, &msg_buf);
     ecs_os_free(msg_nocolor);
-    
+
     char *msg = ecs_strbuf_get(&msg_buf);
     ecs_os_api.log_(level, file, line, msg);
     ecs_os_free(msg);
@@ -12636,7 +12636,7 @@ void _ecs_log(
     va_list args;
     va_start(args, fmt);
     _ecs_logv(level, file, line, fmt, args);
-    va_end(args);    
+    va_end(args);
 }
 
 void ecs_log_push(void) {
@@ -12649,7 +12649,7 @@ void ecs_log_pop(void) {
 
 void _ecs_parser_errorv(
     const char *name,
-    const char *expr, 
+    const char *expr,
     int64_t column_arg,
     const char *fmt,
     va_list args)
@@ -12680,11 +12680,11 @@ void _ecs_parser_errorv(
                 }
             }
 
-            /* Strip newlines from current statement, if any */            
+            /* Strip newlines from current statement, if any */
             char *newline_ptr = strchr(expr, '\n');
             if (newline_ptr) {
                 /* Strip newline from expr */
-                ecs_strbuf_appendstrn(&msg_buf, expr, 
+                ecs_strbuf_appendstrn(&msg_buf, expr,
                     (int32_t)(newline_ptr - expr));
             } else {
                 ecs_strbuf_appendstr(&msg_buf, expr);
@@ -12705,7 +12705,7 @@ void _ecs_parser_errorv(
 
 void _ecs_parser_error(
     const char *name,
-    const char *expr, 
+    const char *expr,
     int64_t column,
     const char *fmt,
     ...)
@@ -12752,12 +12752,12 @@ bool _ecs_assert(
             va_list args;
             va_start(args, fmt);
             char *msg = ecs_vasprintf(fmt, args);
-            va_end(args);            
-            _ecs_fatal(file, line, "assert: %s %s (%s)", 
+            va_end(args);
+            _ecs_fatal(file, line, "assert: %s %s (%s)",
                 cond_str, msg, ecs_strerror(err));
             ecs_os_free(msg);
         } else {
-            _ecs_fatal(file, line, "assert: %s %s", 
+            _ecs_fatal(file, line, "assert: %s %s",
                 cond_str, ecs_strerror(err));
         }
         ecs_os_api.log_last_error_ = err;
@@ -12836,7 +12836,7 @@ void _ecs_log(
 FLECS_API
 void _ecs_parser_error(
     const char *name,
-    const char *expr, 
+    const char *expr,
     int64_t column,
     const char *fmt,
     ...)
@@ -12850,7 +12850,7 @@ void _ecs_parser_error(
 FLECS_API
 void _ecs_parser_errorv(
     const char *name,
-    const char *expr, 
+    const char *expr,
     int64_t column,
     const char *fmt,
     va_list args)
@@ -12931,9 +12931,9 @@ typedef struct EcsSystem {
 
     ecs_entity_t entity;            /* Entity id of system, used for ordering */
     ecs_query_t *query;             /* System query */
-    ecs_system_status_action_t status_action; /* Status action */   
+    ecs_system_status_action_t status_action; /* Status action */
     ecs_entity_t tick_source;       /* Tick source associated with system */
-    
+
     /* Schedule parameters */
     bool multi_threaded;
     bool no_staging;
@@ -12946,12 +12946,12 @@ typedef struct EcsSystem {
     ecs_entity_t self;              /* Entity associated with system */
 
     void *ctx;                      /* Userdata for system */
-    void *status_ctx;               /* User data for status action */ 
+    void *status_ctx;               /* User data for status action */
     void *binding_ctx;              /* Optional language binding context */
 
     ecs_ctx_free_t ctx_free;
     ecs_ctx_free_t status_ctx_free;
-    ecs_ctx_free_t binding_ctx_free;      
+    ecs_ctx_free_t binding_ctx_free;
 } EcsSystem;
 
 /* Invoked when system becomes active / inactive */
@@ -13008,18 +13008,18 @@ typedef struct EcsPipelineQuery {
 
 /** Update a pipeline (internal function).
  * Before running a pipeline, it must be updated. During this update phase
- * all systems in the pipeline are collected, ordered and sync points are 
+ * all systems in the pipeline are collected, ordered and sync points are
  * inserted where necessary. This operation may only be called when staging is
  * disabled.
  *
- * Because multiple threads may run a pipeline, preparing the pipeline must 
- * happen synchronously, which is why this function is separate from 
+ * Because multiple threads may run a pipeline, preparing the pipeline must
+ * happen synchronously, which is why this function is separate from
  * ecs_run_pipeline. Not running the prepare step may cause systems to not get
  * ran, or ran in the wrong order.
  *
  * If 0 is provided for the pipeline id, the default pipeline will be ran (this
  * is either the builtin pipeline or the pipeline set with set_pipeline()).
- * 
+ *
  * @param world The world.
  * @param pipeline The pipeline to run.
  * @return The number of elements in the pipeline.
@@ -13027,7 +13027,7 @@ typedef struct EcsPipelineQuery {
 bool ecs_pipeline_update(
     ecs_world_t *world,
     ecs_entity_t pipeline,
-    bool start_of_frame); 
+    bool start_of_frame);
 
 int32_t ecs_pipeline_reset_iter(
     ecs_world_t *world,
@@ -13081,10 +13081,10 @@ void* worker(void *arg) {
 
     while (!world->quit_workers) {
         ecs_entity_t old_scope = ecs_set_scope((ecs_world_t*)stage, 0);
- 
+
         ecs_run_pipeline(
-            (ecs_world_t*)stage, 
-            world->pipeline, 
+            (ecs_world_t*)stage,
+            world->pipeline,
             world->stats.delta_time);
 
         ecs_set_scope((ecs_world_t*)stage, old_scope);
@@ -13166,9 +13166,9 @@ void wait_for_sync(
     if (world->workers_waiting != stage_count) {
         ecs_os_cond_wait(world->sync_cond, world->sync_mutex);
     }
-    
+
     /* We should have been signalled unless all workers are waiting on sync */
-    ecs_assert(world->workers_waiting == stage_count, 
+    ecs_assert(world->workers_waiting == stage_count,
         ECS_INTERNAL_ERROR, NULL);
 
     ecs_os_mutex_unlock(world->sync_mutex);
@@ -13238,7 +13238,7 @@ void ecs_worker_begin(
     flecs_stage_from_world(&world);
     int32_t stage_count = ecs_get_stage_count(world);
     ecs_assert(stage_count != 0, ECS_INTERNAL_ERROR, NULL);
-    
+
     if (stage_count == 1) {
         ecs_entity_t pipeline = world->pipeline;
         const EcsPipelineQuery *pq = ecs_get(world, pipeline, EcsPipelineQuery);
@@ -13375,7 +13375,7 @@ void ecs_workers_progress(
 
     if (world->measure_frame_time) {
         world->stats.system_time_total += (float)ecs_time_measure(&start);
-    }    
+    }
 }
 
 /* -- Public functions -- */
@@ -13419,10 +13419,10 @@ static ECS_DTOR(EcsPipelineQuery, ptr, {
 
 static
 int compare_entity(
-    ecs_entity_t e1, 
-    const void *ptr1, 
-    ecs_entity_t e2, 
-    const void *ptr2) 
+    ecs_entity_t e1,
+    const void *ptr1,
+    ecs_entity_t e2,
+    const void *ptr2)
 {
     (void)ptr1;
     (void)ptr2;
@@ -13434,10 +13434,10 @@ uint64_t group_by_phase(
     ecs_world_t *world,
     ecs_type_t type,
     ecs_entity_t pipeline,
-    void *ctx) 
+    void *ctx)
 {
     (void)ctx;
-    
+
     const EcsType *pt = ecs_get(world, pipeline, EcsType);
     ecs_assert(pt != NULL, ECS_INTERNAL_ERROR, NULL);
 
@@ -13539,7 +13539,7 @@ bool check_term_component(
     ecs_term_t *term,
     bool is_active,
     ecs_entity_t component,
-    write_state_t *write_state)    
+    write_state_t *write_state)
 {
     int32_t state = get_write_state(write_state->components, component);
 
@@ -13599,7 +13599,7 @@ bool check_term_component(
             break;
         default:
             break;
-        };   
+        };
 
         if (needs_merge) {
             return true;
@@ -13618,7 +13618,7 @@ bool check_term(
     if (term->oper != EcsOr) {
         return check_term_component(
             term, is_active, term->id, write_state);
-    }  
+    }
 
     return false;
 }
@@ -13694,7 +13694,7 @@ bool build_pipeline(
         EcsSystem *sys = ecs_term(&it, EcsSystem, 1);
 
         int i;
-        for (i = 0; i < it.count; i ++) {      
+        for (i = 0; i < it.count; i ++) {
             ecs_query_t *q = sys[i].query;
             if (!q) {
                 continue;
@@ -13737,7 +13737,7 @@ bool build_pipeline(
 
                 /* The component states were just reset, so if we conclude that
                  * another merge is needed something is wrong. */
-                ecs_assert(needs_merge == false, ECS_INTERNAL_ERROR, NULL);        
+                ecs_assert(needs_merge == false, ECS_INTERNAL_ERROR, NULL);
             }
 
             if (!op) {
@@ -13772,10 +13772,10 @@ bool build_pipeline(
     ecs_dbg("#[green]pipeline#[reset] rebuild:");
     ecs_log_push();
 
-    ecs_dbg("#[green]schedule#[reset]: threading: %d, staging: %d:", 
+    ecs_dbg("#[green]schedule#[reset]: threading: %d, staging: %d:",
         op->multi_threaded, !op->no_staging);
     ecs_log_push();
-    
+
     it = ecs_query_iter(world, pq->query);
     while (ecs_query_next(&it)) {
         EcsSystem *sys = ecs_term(&it, EcsSystem, 1);
@@ -13915,8 +13915,8 @@ void ecs_run_pipeline(
         ecs_poly_assert(world, ecs_stage_t);
     }
 
-    ecs_stage_t *stage = flecs_stage_from_world(&world);  
-    
+    ecs_stage_t *stage = flecs_stage_from_world(&world);
+
     const EcsPipelineQuery *pq = ecs_get(world, pipeline, EcsPipelineQuery);
     ecs_assert(pq != NULL, ECS_INTERNAL_ERROR, NULL);
     ecs_assert(pq->query != NULL, ECS_INTERNAL_ERROR, NULL);
@@ -13949,7 +13949,7 @@ void ecs_run_pipeline(
                     s = stage;
                 }
 
-                ecs_run_intern(world, s, e, &sys[i], stage_index, 
+                ecs_run_intern(world, s, e, &sys[i], stage_index,
                     stage_count, delta_time, 0, 0, NULL);
             }
 
@@ -13986,7 +13986,7 @@ void add_pipeline_tags_to_sig(
     ecs_type_t type)
 {
     (void)world;
-    
+
     int32_t i, count = ecs_vector_count(type);
     ecs_entity_t *entities = ecs_vector_first(type, ecs_entity_t);
 
@@ -14046,7 +14046,7 @@ ecs_query_t* build_pipeline_query(
     }
 
     add_pipeline_tags_to_sig(
-        world, &terms[term_count], type_ptr->normalized->type);    
+        world, &terms[term_count], type_ptr->normalized->type);
 
     ecs_query_t *result = ecs_query_init(world, &(ecs_query_desc_t){
         .filter = {
@@ -14066,7 +14066,7 @@ ecs_query_t* build_pipeline_query(
     return result;
 }
 
-static 
+static
 void OnUpdatePipeline(
     ecs_iter_t *it)
 {
@@ -14076,14 +14076,14 @@ void OnUpdatePipeline(
     int32_t i;
     for (i = it->count - 1; i >= 0; i --) {
         ecs_entity_t pipeline = entities[i];
-        
+
         ecs_trace("#[green]pipeline#[reset] %s created",
             ecs_get_name(world, pipeline));
         ecs_log_push();
 
         /* Build signature for pipeline query that matches EcsSystems, has the
-         * pipeline phases as OR columns, and ignores systems with EcsInactive. 
-         * Note that EcsDisabled is automatically ignored 
+         * pipeline phases as OR columns, and ignores systems with EcsInactive.
+         * Note that EcsDisabled is automatically ignored
          * by the regular query matching */
         ecs_query_t *query = build_pipeline_query(
             world, pipeline, "BuiltinPipelineQuery", true);
@@ -14091,7 +14091,7 @@ void OnUpdatePipeline(
 
         /* Build signature for pipeline build query. The build query includes
          * systems that are inactive, as an inactive system may become active as
-         * a result of another system, and as a result the correct merge 
+         * a result of another system, and as a result the correct merge
          * operations need to be put in place. */
         ecs_query_t *build_query = build_pipeline_query(
             world, pipeline, "BuiltinPipelineBuildQuery", false);
@@ -14196,7 +14196,7 @@ void ecs_set_pipeline(
     ecs_entity_t pipeline)
 {
     ecs_poly_assert(world, ecs_world_t);
-    ecs_check( ecs_get(world, pipeline, EcsPipelineQuery) != NULL, 
+    ecs_check( ecs_get(world, pipeline, EcsPipelineQuery) != NULL,
         ECS_INVALID_PARAMETER, NULL);
 
     world->pipeline = pipeline;
@@ -14316,14 +14316,14 @@ void ProgressTimers(ecs_iter_t *it) {
         const ecs_world_info_t *info = ecs_get_world_info(it->world);
         FLECS_FLOAT time_elapsed = timer[i].time + info->delta_time_raw;
         FLECS_FLOAT timeout = timer[i].timeout;
-        
+
         if (time_elapsed >= timeout) {
             FLECS_FLOAT t = time_elapsed - timeout;
             if (t > timeout) {
                 t = 0;
             }
 
-            timer[i].time = t; /* Initialize with remainder */            
+            timer[i].time = t; /* Initialize with remainder */
             tick_source[i].tick = true;
             tick_source[i].time_elapsed = time_elapsed;
 
@@ -14332,7 +14332,7 @@ void ProgressTimers(ecs_iter_t *it) {
             }
         } else {
             timer[i].time = time_elapsed;
-        }  
+        }
     }
 }
 
@@ -14367,7 +14367,7 @@ void ProgressRateFilters(ecs_iter_t *it) {
 
             if (triggered) {
                 filter[i].time_elapsed = 0;
-            }            
+            }
         } else {
             tick_dst[i].tick = false;
         }
@@ -14440,7 +14440,7 @@ ecs_entity_t ecs_set_interval(
         system_data->tick_source = timer;
     }
 error:
-    return timer;  
+    return timer;
 }
 
 FLECS_FLOAT ecs_get_interval(
@@ -14500,10 +14500,10 @@ ecs_entity_t ecs_set_rate(
     EcsSystem *system_data = ecs_get_mut(world, filter, EcsSystem, NULL);
     if (system_data) {
         system_data->tick_source = filter;
-    }  
+    }
 
 error:
-    return filter;     
+    return filter;
 }
 
 void ecs_set_tick_source(
@@ -14525,7 +14525,7 @@ error:
 
 void FlecsTimerImport(
     ecs_world_t *world)
-{    
+{
     ECS_MODULE(world, FlecsTimer);
 
     ECS_IMPORT(world, FlecsPipeline);
@@ -14597,7 +14597,7 @@ void FlecsTimerImport(
 
 static
 ecs_os_thread_t win_thread_new(
-    ecs_os_thread_callback_t callback, 
+    ecs_os_thread_callback_t callback,
     void *arg)
 {
     HANDLE *thread = ecs_os_malloc_t(HANDLE);
@@ -14621,14 +14621,14 @@ void* win_thread_join(
 
 static
 int32_t win_ainc(
-    int32_t *count) 
+    int32_t *count)
 {
     return InterlockedIncrement(count);
 }
 
 static
 int32_t win_adec(
-    int32_t *count) 
+    int32_t *count)
 {
     return InterlockedDecrement(count);
 }
@@ -14642,7 +14642,7 @@ ecs_os_mutex_t win_mutex_new(void) {
 
 static
 void win_mutex_free(
-    ecs_os_mutex_t m) 
+    ecs_os_mutex_t m)
 {
     CRITICAL_SECTION *mutex = (CRITICAL_SECTION*)(intptr_t)m;
     DeleteCriticalSection(mutex);
@@ -14651,7 +14651,7 @@ void win_mutex_free(
 
 static
 void win_mutex_lock(
-    ecs_os_mutex_t m) 
+    ecs_os_mutex_t m)
 {
     CRITICAL_SECTION *mutex = (CRITICAL_SECTION*)(intptr_t)m;
     EnterCriticalSection(mutex);
@@ -14659,7 +14659,7 @@ void win_mutex_lock(
 
 static
 void win_mutex_unlock(
-    ecs_os_mutex_t m) 
+    ecs_os_mutex_t m)
 {
     CRITICAL_SECTION *mutex = (CRITICAL_SECTION*)(intptr_t)m;
     LeaveCriticalSection(mutex);
@@ -14672,33 +14672,33 @@ ecs_os_cond_t win_cond_new(void) {
     return (ecs_os_cond_t)(uintptr_t)cond;
 }
 
-static 
+static
 void win_cond_free(
-    ecs_os_cond_t c) 
+    ecs_os_cond_t c)
 {
     (void)c;
 }
 
-static 
+static
 void win_cond_signal(
-    ecs_os_cond_t c) 
+    ecs_os_cond_t c)
 {
     CONDITION_VARIABLE *cond = (CONDITION_VARIABLE*)(intptr_t)c;
     WakeConditionVariable(cond);
 }
 
-static 
+static
 void win_cond_broadcast(
-    ecs_os_cond_t c) 
+    ecs_os_cond_t c)
 {
     CONDITION_VARIABLE *cond = (CONDITION_VARIABLE*)(intptr_t)c;
     WakeAllConditionVariable(cond);
 }
 
-static 
+static
 void win_cond_wait(
-    ecs_os_cond_t c, 
-    ecs_os_mutex_t m) 
+    ecs_os_cond_t c,
+    ecs_os_mutex_t m)
 {
     CRITICAL_SECTION *mutex = (CRITICAL_SECTION*)(intptr_t)m;
     CONDITION_VARIABLE *cond = (CONDITION_VARIABLE*)(intptr_t)c;
@@ -14714,7 +14714,7 @@ void win_time_setup(void) {
     if ( win_time_initialized) {
         return;
     }
-    
+
     win_time_initialized = true;
 
     LARGE_INTEGER freq;
@@ -14725,8 +14725,8 @@ void win_time_setup(void) {
 
 static
 void win_sleep(
-    int32_t sec, 
-    int32_t nanosec) 
+    int32_t sec,
+    int32_t nanosec)
 {
     HANDLE timer;
     LARGE_INTEGER ft;
@@ -14838,7 +14838,7 @@ void ecs_set_os_api_impl(void) {
 
 static
 ecs_os_thread_t posix_thread_new(
-    ecs_os_thread_callback_t callback, 
+    ecs_os_thread_callback_t callback,
     void *arg)
 {
     pthread_t *thread = ecs_os_malloc(sizeof(pthread_t));
@@ -14877,7 +14877,7 @@ int32_t posix_ainc(
 
 static
 int32_t posix_adec(
-    int32_t *count) 
+    int32_t *count)
 {
     int value;
 #ifdef __GNUC__
@@ -14900,7 +14900,7 @@ ecs_os_mutex_t posix_mutex_new(void) {
 
 static
 void posix_mutex_free(
-    ecs_os_mutex_t m) 
+    ecs_os_mutex_t m)
 {
     pthread_mutex_t *mutex = (pthread_mutex_t*)(intptr_t)m;
     pthread_mutex_destroy(mutex);
@@ -14909,7 +14909,7 @@ void posix_mutex_free(
 
 static
 void posix_mutex_lock(
-    ecs_os_mutex_t m) 
+    ecs_os_mutex_t m)
 {
     pthread_mutex_t *mutex = (pthread_mutex_t*)(intptr_t)m;
     if (pthread_mutex_lock(mutex)) {
@@ -14919,7 +14919,7 @@ void posix_mutex_lock(
 
 static
 void posix_mutex_unlock(
-    ecs_os_mutex_t m) 
+    ecs_os_mutex_t m)
 {
     pthread_mutex_t *mutex = (pthread_mutex_t*)(intptr_t)m;
     if (pthread_mutex_unlock(mutex)) {
@@ -14936,9 +14936,9 @@ ecs_os_cond_t posix_cond_new(void) {
     return (ecs_os_cond_t)(uintptr_t)cond;
 }
 
-static 
+static
 void posix_cond_free(
-    ecs_os_cond_t c) 
+    ecs_os_cond_t c)
 {
     pthread_cond_t *cond = (pthread_cond_t*)(intptr_t)c;
     if (pthread_cond_destroy(cond)) {
@@ -14947,9 +14947,9 @@ void posix_cond_free(
     ecs_os_free(cond);
 }
 
-static 
+static
 void posix_cond_signal(
-    ecs_os_cond_t c) 
+    ecs_os_cond_t c)
 {
     pthread_cond_t *cond = (pthread_cond_t*)(intptr_t)c;
     if (pthread_cond_signal(cond)) {
@@ -14957,9 +14957,9 @@ void posix_cond_signal(
     }
 }
 
-static 
+static
 void posix_cond_broadcast(
-    ecs_os_cond_t c) 
+    ecs_os_cond_t c)
 {
     pthread_cond_t *cond = (pthread_cond_t*)(intptr_t)c;
     if (pthread_cond_broadcast(cond)) {
@@ -14967,10 +14967,10 @@ void posix_cond_broadcast(
     }
 }
 
-static 
+static
 void posix_cond_wait(
-    ecs_os_cond_t c, 
-    ecs_os_mutex_t m) 
+    ecs_os_cond_t c,
+    ecs_os_mutex_t m)
 {
     pthread_cond_t *cond = (pthread_cond_t*)(intptr_t)c;
     pthread_mutex_t *mutex = (pthread_mutex_t*)(intptr_t)m;
@@ -14993,7 +14993,7 @@ void posix_time_setup(void) {
     if (posix_time_initialized) {
         return;
     }
-    
+
     posix_time_initialized = true;
 
     #if defined(__APPLE__) && defined(__MACH__)
@@ -15002,14 +15002,14 @@ void posix_time_setup(void) {
     #else
         struct timespec ts;
         clock_gettime(CLOCK_MONOTONIC, &ts);
-        posix_time_start = (uint64_t)ts.tv_sec*1000000000 + (uint64_t)ts.tv_nsec; 
+        posix_time_start = (uint64_t)ts.tv_sec*1000000000 + (uint64_t)ts.tv_nsec;
     #endif
 }
 
 static
 void posix_sleep(
-    int32_t sec, 
-    int32_t nanosec) 
+    int32_t sec,
+    int32_t nanosec)
 {
     struct timespec sleepTime;
     ecs_assert(sec >= 0, ECS_INTERNAL_ERROR, NULL);
@@ -15047,8 +15047,8 @@ uint64_t posix_time_now(void) {
 
     #if defined(ECS_TARGET_DARWIN)
         now = (uint64_t) posix_int64_muldiv(
-            (int64_t)mach_absolute_time(), 
-            (int64_t)posix_osx_timebase.numer, 
+            (int64_t)mach_absolute_time(),
+            (int64_t)posix_osx_timebase.numer,
             (int64_t)posix_osx_timebase.denom);
     #elif defined(__EMSCRIPTEN__)
         now = (long long)(emscripten_get_now() * 1000.0 * 1000);
@@ -15204,12 +15204,12 @@ const char* parse_fluff(
         int32_t newline_count = 0;
 
         /* Trim trailing whitespaces */
-        while (len >= 0 && (isspace(comment[len - 1]))) {            
+        while (len >= 0 && (isspace(comment[len - 1]))) {
             if (comment[len - 1] == '\n') {
                 newline_count ++;
                 if (newline_count > 1) {
                     /* If newline separates comment from statement, discard */
-                    len = -1; 
+                    len = -1;
                     break;
                 }
             }
@@ -15221,7 +15221,7 @@ const char* parse_fluff(
             state->comment = ecs_os_calloc_n(char, len + 1);
             ecs_os_strncpy(state->comment, comment, len);
         } else {
-            ecs_parser_error(state->name, expr, ptr - expr, 
+            ecs_parser_error(state->name, expr, ptr - expr,
                 "unused doc comment");
             state->errors ++;
         }
@@ -15248,7 +15248,7 @@ ecs_entity_t ensure_entity(
     ecs_entity_t e = plecs_lookup(world, path, state, is_subject);
     if (!e) {
         if (!is_subject) {
-            /* If this is not a subject create an existing empty id, which 
+            /* If this is not a subject create an existing empty id, which
              * ensures that scope & with are not applied */
             e = ecs_new_id(world);
         }
@@ -15306,7 +15306,7 @@ bool pred_is_subj(
 /* Set masks aren't useful in plecs, so translate them back to entity names */
 static
 const char* set_mask_to_name(
-    ecs_flags32_t flags) 
+    ecs_flags32_t flags)
 {
     if (flags == EcsSelf) {
         return "self";
@@ -15326,7 +15326,7 @@ const char* set_mask_to_name(
 
 static
 int create_term(
-    ecs_world_t *world, 
+    ecs_world_t *world,
     ecs_term_t *term,
     const char *name,
     const char *expr,
@@ -15355,19 +15355,19 @@ int create_term(
     }
 
     if (state->assign_stmt && term->subj.entity != EcsThis) {
-        ecs_parser_error(name, expr, column, 
+        ecs_parser_error(name, expr, column,
             "invalid statement in assign statement");
         return -1;
     }
 
     bool pred_as_subj = pred_is_subj(term, state);
 
-    ecs_entity_t pred = ensure_entity(world, state, pred_name, pred_as_subj); 
+    ecs_entity_t pred = ensure_entity(world, state, pred_name, pred_as_subj);
     ecs_entity_t subj = ensure_entity(world, state, subj_name, true);
     ecs_entity_t obj = 0;
 
     if (ecs_term_id_is_set(&term->obj)) {
-        obj = ensure_entity(world, state, obj_name, 
+        obj = ensure_entity(world, state, obj_name,
             state->assign_stmt == false);
     }
 
@@ -15376,13 +15376,13 @@ int create_term(
     }
 
     if (state->isa_stmt && obj) {
-        ecs_parser_error(name, expr, column, 
+        ecs_parser_error(name, expr, column,
             "invalid object in inheritance statement");
         return -1;
     }
 
     if (state->using_stmt && (obj || subj)) {
-        ecs_parser_error(name, expr, column, 
+        ecs_parser_error(name, expr, column,
             "invalid predicate/object in using statement");
         return -1;
     }
@@ -15406,7 +15406,7 @@ int create_term(
         pred_as_subj = false;
     } else {
         if (!obj) {
-            /* If no subject or object were provided, use predicate as subj 
+            /* If no subject or object were provided, use predicate as subj
              * unless the expression explictly excluded the subject */
             if (pred_as_subj) {
                 state->last_subject = pred;
@@ -15435,7 +15435,7 @@ int create_term(
         }
 
         state->with[state->with_frame ++] = id;
-    
+
     } else if (state->using_stmt) {
         ecs_assert(pred != 0, ECS_INTERNAL_ERROR, NULL);
         ecs_assert(obj == 0, ECS_INTERNAL_ERROR, NULL);
@@ -15479,17 +15479,17 @@ const char* parse_inherit_stmt(
     plecs_state_t *state)
 {
     if (state->isa_stmt) {
-        ecs_parser_error(name, expr, ptr - expr, 
+        ecs_parser_error(name, expr, ptr - expr,
             "cannot nest inheritance");
         return NULL;
     }
 
     if (!state->last_subject) {
-        ecs_parser_error(name, expr, ptr - expr, 
+        ecs_parser_error(name, expr, ptr - expr,
             "missing entity to assign inheritance to");
         return NULL;
     }
-    
+
     state->isa_stmt = true;
     state->assign_to = state->last_subject;
 
@@ -15502,10 +15502,10 @@ const char* parse_assign_expr(
     const char *name,
     const char *expr,
     const char *ptr,
-    plecs_state_t *state) 
+    plecs_state_t *state)
 {
     (void)world;
-    
+
     if (!state->assign_stmt) {
         ecs_parser_error(name, expr, ptr - expr,
             "unexpected value outside of assignment statement");
@@ -15530,7 +15530,7 @@ const char* parse_assign_expr(
     }
 
     if (!assign_to) {
-        ecs_parser_error(name, expr, ptr - expr, 
+        ecs_parser_error(name, expr, ptr - expr,
             "missing entity to assign to");
         return NULL;
     }
@@ -15538,7 +15538,7 @@ const char* parse_assign_expr(
     ecs_entity_t type = ecs_get_typeid(world, assign_id);
     if (!type) {
         char *id_str = ecs_id_str(world, assign_id);
-        ecs_parser_error(name, expr, ptr - expr, 
+        ecs_parser_error(name, expr, ptr - expr,
             "invalid assignment, '%s' is not a type", id_str);
         ecs_os_free(id_str);
         return NULL;
@@ -15547,7 +15547,7 @@ const char* parse_assign_expr(
     void *value_ptr = ecs_get_mut_id(
         world, assign_to, assign_id, NULL);
 
-    ptr = ecs_parse_expr(world, ptr, type, value_ptr, 
+    ptr = ecs_parse_expr(world, ptr, type, value_ptr,
         &(ecs_parse_expr_desc_t) {
             .name = name,
             .expr = expr,
@@ -15570,7 +15570,7 @@ const char* parse_assign_stmt(
     const char *name,
     const char *expr,
     const char *ptr,
-    plecs_state_t *state) 
+    plecs_state_t *state)
 {
     (void)world;
 
@@ -15578,13 +15578,13 @@ const char* parse_assign_stmt(
 
     /* Component scope (add components to entity) */
     if (!state->last_subject) {
-        ecs_parser_error(name, expr, ptr - expr, 
+        ecs_parser_error(name, expr, ptr - expr,
             "missing entity to assign to");
         return NULL;
     }
 
     if (state->assign_stmt) {
-        ecs_parser_error(name, expr, ptr - expr, 
+        ecs_parser_error(name, expr, ptr - expr,
             "invalid assign statement in assign statement");
         return NULL;
     }
@@ -15594,13 +15594,13 @@ const char* parse_assign_stmt(
     }
 
     state->assign_stmt = true;
-    
+
     /* Assignment without a preceding component */
     if (ptr[0] == '{') {
         ecs_entity_t type = 0;
 
         if (state->scope_assign_stmt) {
-            ecs_assert(state->assign_to == ecs_get_scope(world), 
+            ecs_assert(state->assign_to == ecs_get_scope(world),
                 ECS_INTERNAL_ERROR, NULL);
         }
 
@@ -15626,7 +15626,7 @@ const char* parse_assign_stmt(
         }
 
         if (!type) {
-            ecs_parser_error(name, expr, ptr - expr, 
+            ecs_parser_error(name, expr, ptr - expr,
                 "missing type for assignment");
             return NULL;
         }
@@ -15642,10 +15642,10 @@ const char* parse_using_stmt(
     const char *name,
     const char *expr,
     const char *ptr,
-    plecs_state_t *state) 
+    plecs_state_t *state)
 {
     if (state->isa_stmt || state->assign_stmt) {
-        ecs_parser_error(name, expr, ptr - expr, 
+        ecs_parser_error(name, expr, ptr - expr,
             "invalid usage of using keyword");
         return NULL;
     }
@@ -15661,16 +15661,16 @@ const char* parse_with_stmt(
     const char *name,
     const char *expr,
     const char *ptr,
-    plecs_state_t *state) 
+    plecs_state_t *state)
 {
     if (state->isa_stmt) {
-        ecs_parser_error(name, expr, ptr - expr, 
+        ecs_parser_error(name, expr, ptr - expr,
             "invalid with after inheritance");
         return NULL;
     }
 
     if (state->assign_stmt) {
-        ecs_parser_error(name, expr, ptr - expr, 
+        ecs_parser_error(name, expr, ptr - expr,
             "invalid with in assign_stmt");
         return NULL;
     }
@@ -15686,12 +15686,12 @@ const char* parse_scope_open(
     const char *name,
     const char *expr,
     const char *ptr,
-    plecs_state_t *state) 
+    plecs_state_t *state)
 {
     state->isa_stmt = false;
 
     if (state->assign_stmt) {
-        ecs_parser_error(name, expr, ptr - expr, 
+        ecs_parser_error(name, expr, ptr - expr,
             "invalid scope in assign_stmt");
         return NULL;
     }
@@ -15707,7 +15707,7 @@ const char* parse_scope_open(
             ecs_set_scope(world, state->last_subject);
 
             /* Check if scope has a default child component */
-            ecs_entity_t def_type_src = ecs_get_object_for_id(world, scope, 
+            ecs_entity_t def_type_src = ecs_get_object_for_id(world, scope,
                 0, ecs_pair(EcsDefaultChildComponent, EcsWildcard));
 
             if (def_type_src) {
@@ -15731,7 +15731,7 @@ const char* parse_scope_open(
         state->default_scope_type[state->sp] = default_scope_type;
     } else {
         state->scope[state->sp] = state->scope[state->sp - 1];
-        state->default_scope_type[state->sp] = 
+        state->default_scope_type[state->sp] =
             state->default_scope_type[state->sp - 1];
     }
 
@@ -15748,16 +15748,16 @@ const char* parse_scope_close(
     const char *name,
     const char *expr,
     const char *ptr,
-    plecs_state_t *state) 
+    plecs_state_t *state)
 {
     if (state->isa_stmt) {
-        ecs_parser_error(name, expr, ptr - expr, 
+        ecs_parser_error(name, expr, ptr - expr,
             "invalid '}' after inheritance statement");
         return NULL;
     }
 
     if (state->assign_stmt) {
-        ecs_parser_error(name, expr, ptr - expr, 
+        ecs_parser_error(name, expr, ptr - expr,
             "unfinished assignment before }");
         return NULL;
     }
@@ -15802,7 +15802,7 @@ const char *parse_plecs_term(
 
     /* If first character is a (, this should be interpreted as an id assigned
      * to the current scope if:
-     * - this is not already an assignment: "Foo = (Hello, World)" 
+     * - this is not already an assignment: "Foo = (Hello, World)"
      * - this is in a scope
      */
     bool scope_assignment = (ptr[0] == '(') && !state->assign_stmt && scope != 0;
@@ -15835,7 +15835,7 @@ const char *parse_plecs_term(
             if (id && (ecs_get_typeid(world, id) != 0)) {
                 scope_assignment = true;
             }
-        } 
+        }
     }
 
     bool prev = state->assign_stmt;
@@ -15994,7 +15994,7 @@ error:
 int ecs_plecs_from_str(
     ecs_world_t *world,
     const char *name,
-    const char *expr) 
+    const char *expr)
 {
     const char *ptr = expr;
     ecs_term_t term = {0};
@@ -16021,7 +16021,7 @@ int ecs_plecs_from_str(
 
     ecs_set_scope(world, prev_scope);
     ecs_set_with(world, prev_with);
-    
+
     clear_comment(expr, ptr, &state);
 
     if (state.sp != 0) {
@@ -16048,7 +16048,7 @@ error:
 
 int ecs_plecs_from_file(
     ecs_world_t *world,
-    const char *filename) 
+    const char *filename)
 {
     FILE* file;
     char* content = NULL;
@@ -16100,164 +16100,164 @@ error:
 #include <stdio.h>
 
 /** Implementation of the rule query engine.
- * 
- * A rule (terminology borrowed from prolog) is a list of constraints that 
+ *
+ * A rule (terminology borrowed from prolog) is a list of constraints that
  * specify which conditions must be met for an entity to match the rule. While
  * this description matches any kind of ECS query, the rule engine has features
  * that go beyond regular (flecs) ECS queries:
- * 
+ *
  * - query for all components of an entity (vs. all entities for a component)
  * - query for all relationship pairs of an entity
  * - support for query variables that are resolved at evaluation time
  * - automatic traversal of transitive relationships
- * 
+ *
  * Query terms can have the following forms:
- * 
+ *
  * - Component(Subject)
  * - Relation(Subject, Object)
- * 
+ *
  * Additionally the query parser supports the following shorthand notations:
- * 
+ *
  * - Component             // short for Component(This)
  * - (Relation, Object)    // short for Relation(This, Object)
- * 
+ *
  * The subject, or first arugment of a term represents the entity on which the
  * component or relation is matched. By default the subject is set to a builtin
  * This variable, which causes the behavior to match a regular ECS query:
- * 
+ *
  * - Position, Velocity
- * 
+ *
  * Is equivalent to
  *
  * - Position(This), Velocity(This)
- * 
+ *
  * The function of the variable is to ensure that all components are matched on
  * the same entity. Conceptually the query first populates the This variable
  * with all entities that have Position. When the query evaluates the Velocity
  * term, the variable is populated and the entity it contains will be checked
  * for whether it has Velocity.
- * 
+ *
  * The actual implementation is more efficient and does not check per-entity.
- * 
- * Custom variables can be used to join parts of different terms. For example, 
+ *
+ * Custom variables can be used to join parts of different terms. For example,
  * the following query can be used to find entities with a parent that has a
  * Position component (note that variable names start with a _):
- * 
+ *
  * - ChildOf(This, _Parent), Component(_Parent)
- * 
+ *
  * The rule engine uses a backtracking algorithm to find the set of entities
  * and variables that match all terms. As soon as the engine finds a term that
  * does not match with the currently evaluated entity, the entity is discarded.
  * When an entity is found for which all terms match, the entity is yielded to
  * the iterator.
- * 
- * While a rule is being evaluated, a variable can either contain a single 
+ *
+ * While a rule is being evaluated, a variable can either contain a single
  * entity or a table. The engine will attempt to work with tables as much as
  * possible so entities can be eliminated/yielded in bulk. A rule may store
  * both the table and entity version of a variable and only switch from table to
  * entity when necessary.
- * 
- * The rule engine has an algorithm for computing which variables should be 
+ *
+ * The rule engine has an algorithm for computing which variables should be
  * resolved first. This algorithm works by finding a "root" variable, which is
  * the subject variable that occurs in the term with the least dependencies. The
  * remaining variables are then resolved based on their "distance" from the root
  * with the closest variables being resolved first.
- * 
- * This generally results in an ordering that resolves the variables with the 
+ *
+ * This generally results in an ordering that resolves the variables with the
  * least dependencies first and the most dependencies last, which is beneficial
  * for two reasons:
- * 
+ *
  * - it improves the average performance of all queries
  * - it makes performance less dependent on how an application orders the terms
- * 
+ *
  * A possible improvement would be for the query engine to also consider
  * the number of tables that need to be evaluated for each term, as starting
  * with the smallest term reduces the amount of work. Other than static variable
  * analysis however, this can only be determined when the query is executed.
- * 
+ *
  * Rules are "compiled" into a set of instructions that encode the operations
  * the query needs to perform in order to find the right set of entities.
  * Operations can either yield data, which progresses the program, or signal
  * that there is no (more) matching data, which discards the current variables.
- * 
+ *
  * An operation can yield multiple times, if there are multiple matches for its
  * inputs. Operations are called with a redo flag, which can be either true or
  * false. When redo is true the operation will yield the next result. When redo
  * is false, the operation will reset its state and start from the first result.
- * 
+ *
  * Operations can have an input, output and a filter. Most commonly an operation
  * either matches the filter against an input and yields if it matches, or uses
  * the filter to find all matching results and store the result in the output.
  *
- * Variables are resolved by matching a filter against the output of an 
+ * Variables are resolved by matching a filter against the output of an
  * operation. When a term contains variables, they are encoded as register ids
  * in the filter. When the filter is evaluated, the most recent values of the
  * register are used to match/lookup the output.
- * 
+ *
  * For example, a filter could be (ChildOf, _Parent). When the program starts,
  * the _Parent register is initialized with *, so that when this filter is first
  * evaluated, the operation will find all tables with (ChildOf, *). The _Parent
  * register is then populated by taking the actual value of the table. If the
  * table has type [(ChildOf, Sun)], _Parent will be initialized with Sun.
- * 
+ *
  * It is possible that a filter matches multiple times. Consider the filter
  * (Likes, _Food), and a table [(Likes, Apples), (Likes, Pears)]. In this case
  * an operation will yield the table twice, once with _Food=Apples, and once
  * with _Food=Pears.
- * 
+ *
  * If a rule contains a term with a transitive relation, it will automatically
  * substitute the parts of the term to find a fact that matches. The following
  * examples illustrate how transitivity is resolved:
- * 
+ *
  * Query:
  *   LocatedIn(Bob, SanFrancisco)
- *   
+ *
  * Expands to:
  *   LocatedIn(Bob, SanFrancisco:self|subset)
- * 
+ *
  * Explanation:
- *   "Is Bob located in San Francisco" - This term is true if Bob is either 
- *   located in San Francisco, or is located in anything that is itself located 
+ *   "Is Bob located in San Francisco" - This term is true if Bob is either
+ *   located in San Francisco, or is located in anything that is itself located
  *   in (a subset of) San Francisco.
- * 
- * 
+ *
+ *
  * Query:
  *   LocatedIn(Bob, X)
- * 
+ *
  * Expands to:
  *   LocatedIn(Bob, X:self|superset)
- * 
+ *
  * Explanation:
  *   "Where is Bob located?" - This term recursively returns all places that
  *   Bob is located in, which includes his location and the supersets of his
  *   location. When Bob is located in San Francisco, he is also located in
  *   the United States, North America etc.
- * 
- * 
+ *
+ *
  * Query:
  *   LocatedIn(X, NorthAmerica)
- * 
+ *
  * Expands to:
  *   LocatedIn(X, NorthAmerica:self|subset)
- * 
+ *
  * Explanation:
  *   "What is located in North America?" - This term returns everything located
  *   in North America and its subsets, as something located in San Francisco is
- *   located in UnitedStates, which is located in NorthAmerica. 
- * 
- * 
+ *   located in UnitedStates, which is located in NorthAmerica.
+ *
+ *
  * Query:
  *   LocatedIn(X, Y)
- * 
+ *
  * Expands to:
  *   LocatedIn(X, Y)
- * 
+ *
  * Explanation:
  *   "Where is everything located" - This term returns everything that is
  *   located somewhere. No substitution is performed as this would explode the
  *   results while not yielding new information.
- * 
- * 
+ *
+ *
  * In the above terms, the variable indicates the part of the term that is
  * unknown at evaluation time. In an actual rule the picked strategy depends on
  * whether the variable is known when the term is evaluated. For example, if
@@ -16321,7 +16321,7 @@ typedef struct ecs_rule_reg_t {
      * to store an empty entity. */
     ecs_entity_t entity;
 } ecs_rule_reg_t;
- 
+
 /* Operations describe how the rule should be evaluated */
 typedef enum ecs_rule_op_kind_t {
     EcsRuleInput,       /* Input placeholder, first instruction in every rule */
@@ -16427,7 +16427,7 @@ typedef struct ecs_rule_var_t {
 /* Top-level rule datastructure */
 struct ecs_rule_t {
     ecs_header_t hdr;
-    
+
     ecs_world_t *world;         /* Ref to world so rule can be used by itself */
     ecs_rule_op_t *operations;  /* Operations array */
     ecs_rule_var_t *variables;  /* Variable array */
@@ -16554,7 +16554,7 @@ ecs_rule_var_t* create_anonymous_variable(
 }
 
 /* Find variable with specified name and type. If Unknown is provided as type,
- * the function will return any variable with the provided name. The root 
+ * the function will return any variable with the provided name. The root
  * variable can occur both as a table and entity variable, as some rules
  * require that each entity in a table is iterated. In this case, there are two
  * variables, one for the table and one for the entities in the table, that both
@@ -16572,7 +16572,7 @@ ecs_rule_var_t* find_variable(
 
     ecs_rule_var_t *variables = rule->variables;
     int32_t i, count = rule->variable_count;
-    
+
     for (i = 0; i < count; i ++) {
         ecs_rule_var_t *variable = &variables[i];
         if (!ecs_os_strcmp(name, variable->name)) {
@@ -16586,7 +16586,7 @@ ecs_rule_var_t* find_variable(
 }
 
 /* Ensure variable with specified name and type exists. If an existing variable
- * is found with an unknown type, its type will be overwritten with the 
+ * is found with an unknown type, its type will be overwritten with the
  * specified type. During the variable ordering phase it is not yet clear which
  * variable is the root. Which variable is the root determines its type, which
  * is why during this phase variables are still untyped. */
@@ -16625,7 +16625,7 @@ const char *term_id_var_name(
             ecs_check(term_id->name != NULL, ECS_INVALID_PARAMETER, NULL);
         }
     }
-    
+
 error:
     return NULL;
 }
@@ -16745,7 +16745,7 @@ int32_t push_frame(
 static
 ecs_rule_reg_t* get_register_frame(
     const ecs_rule_iter_t *it,
-    int32_t frame)    
+    int32_t frame)
 {
     if (it->registers) {
         return &it->registers[frame * it->rule->variable_count];
@@ -16761,18 +16761,18 @@ ecs_rule_reg_t* get_register_frame(
 static
 ecs_rule_reg_t* get_registers(
     const ecs_rule_iter_t *it,
-    ecs_rule_op_t *op)    
+    ecs_rule_op_t *op)
 {
     return get_register_frame(it, op->frame);
 }
 
-/* Get columns array. Columns store, for each matched column in a table, the 
+/* Get columns array. Columns store, for each matched column in a table, the
  * index at which it occurs. This reduces the amount of searching that
  * operations need to do in a type, since select/with already provide it. */
 static
 int32_t* rule_get_columns_frame(
     ecs_rule_iter_t *it,
-    int32_t frame)    
+    int32_t frame)
 {
     return &it->columns[frame * it->rule->filter.term_count];
 }
@@ -16780,7 +16780,7 @@ int32_t* rule_get_columns_frame(
 static
 int32_t* rule_get_columns(
     ecs_rule_iter_t *it,
-    ecs_rule_op_t *op)    
+    ecs_rule_op_t *op)
 {
     return rule_get_columns_frame(it, op->frame);
 }
@@ -16806,7 +16806,7 @@ void entity_reg_set(
     ecs_entity_t entity)
 {
     (void)rule;
-    ecs_assert(rule->variables[r].kind == EcsRuleVarKindEntity, 
+    ecs_assert(rule->variables[r].kind == EcsRuleVarKindEntity,
         ECS_INTERNAL_ERROR, NULL);
     ecs_check(ecs_is_valid(rule->world, entity), ECS_INVALID_PARAMETER, NULL);
     regs[r].entity = entity;
@@ -16825,8 +16825,8 @@ ecs_entity_t entity_reg_get(
     if (!e) {
         return EcsWildcard;
     }
-    
-    ecs_check(ecs_is_valid(rule->world, e), ECS_INVALID_PARAMETER, NULL);   
+
+    ecs_check(ecs_is_valid(rule->world, e), ECS_INVALID_PARAMETER, NULL);
     return e;
 error:
     return 0;
@@ -16840,7 +16840,7 @@ void table_reg_set(
     ecs_table_t *table)
 {
     (void)rule;
-    ecs_assert(rule->variables[r].kind == EcsRuleVarKindTable, 
+    ecs_assert(rule->variables[r].kind == EcsRuleVarKindTable,
         ECS_INTERNAL_ERROR, NULL);
 
     regs[r].table = table;
@@ -16849,17 +16849,17 @@ void table_reg_set(
     regs[r].entity = 0;
 }
 
-static 
+static
 ecs_table_t* table_reg_get(
     const ecs_rule_t *rule,
     ecs_rule_reg_t *regs,
     int32_t r)
 {
     (void)rule;
-    ecs_assert(rule->variables[r].kind == EcsRuleVarKindTable, 
+    ecs_assert(rule->variables[r].kind == EcsRuleVarKindTable,
         ECS_INTERNAL_ERROR, NULL);
 
-    return regs[r].table;       
+    return regs[r].table;
 }
 
 static
@@ -16875,7 +16875,7 @@ ecs_entity_t reg_get_entity(
         /* The subject is referenced from the query string by string identifier.
          * If subject entity is not valid, it could have been deletd by the
          * application after the rule was created */
-        ecs_check(ecs_is_valid(rule->world, op->subject), 
+        ecs_check(ecs_is_valid(rule->world, op->subject),
             ECS_INVALID_PARAMETER, NULL);
 
         return op->subject;
@@ -16888,11 +16888,11 @@ ecs_entity_t reg_get_entity(
         ecs_assert(data != NULL, ECS_INTERNAL_ERROR, NULL);
         ecs_entity_t *entities = ecs_vector_first(data->entities, ecs_entity_t);
         ecs_assert(entities != NULL, ECS_INTERNAL_ERROR, NULL);
-        ecs_assert(offset < ecs_vector_count(data->entities), 
+        ecs_assert(offset < ecs_vector_count(data->entities),
             ECS_INTERNAL_ERROR, NULL);
-        ecs_check(ecs_is_valid(rule->world, entities[offset]), 
-            ECS_INVALID_PARAMETER, NULL);            
-        
+        ecs_check(ecs_is_valid(rule->world, entities[offset]),
+            ECS_INVALID_PARAMETER, NULL);
+
         return entities[offset];
     }
     if (rule->variables[r].kind == EcsRuleVarKindEntity) {
@@ -16915,7 +16915,7 @@ ecs_table_t* reg_get_table(
 {
     if (r == UINT8_MAX) {
         ecs_assert(op->subject != 0, ECS_INTERNAL_ERROR, NULL);
-        ecs_check(ecs_is_valid(rule->world, op->subject), 
+        ecs_check(ecs_is_valid(rule->world, op->subject),
             ECS_INVALID_PARAMETER, NULL);
 
         return table_from_entity(rule->world, op->subject);
@@ -16925,7 +16925,7 @@ ecs_table_t* reg_get_table(
     }
     if (rule->variables[r].kind == EcsRuleVarKindEntity) {
         return table_from_entity(rule->world, entity_reg_get(rule, regs, r));
-    } 
+    }
 error:
     return NULL;
 }
@@ -16983,7 +16983,7 @@ ecs_rule_pair_t term_to_pair(
 
             /* Variables should have been declared */
             ecs_assert(var != NULL, ECS_INTERNAL_ERROR, NULL);
-            ecs_assert(var->kind == EcsRuleVarKindEntity, 
+            ecs_assert(var->kind == EcsRuleVarKindEntity,
                 ECS_INTERNAL_ERROR, NULL);
             result.pred.reg = var->id;
 
@@ -17022,7 +17022,7 @@ ecs_rule_pair_t term_to_pair(
     }
 
     /* The pair doesn't do anything with the subject (subjects are the things that
-     * are matched against pairs) so if the column does not have a object, 
+     * are matched against pairs) so if the column does not have a object,
      * there is nothing left to do. */
     if (!obj_is_set(term)) {
         return result;
@@ -17039,7 +17039,7 @@ ecs_rule_pair_t term_to_pair(
 
             /* Variables should have been declared */
             ecs_assert(var != NULL, ECS_INTERNAL_ERROR, NULL);
-            ecs_assert(var->kind == EcsRuleVarKindEntity, ECS_INTERNAL_ERROR, 
+            ecs_assert(var->kind == EcsRuleVarKindEntity, ECS_INTERNAL_ERROR,
                 NULL);
 
             result.obj.reg = var->id;
@@ -17121,8 +17121,8 @@ ecs_rule_filter_t pair_to_filter(
     return result;
 }
 
-/* This function is responsible for reifying the variables (filling them out 
- * with their actual values as soon as they are known). It uses the pair 
+/* This function is responsible for reifying the variables (filling them out
+ * with their actual values as soon as they are known). It uses the pair
  * expression returned by pair_get_most_specific_var, and attempts to fill out each of the
  * wildcards in the pair. If a variable isn't reified yet, the pair expression
  * will still contain one or more wildcards, which is harmless as the respective
@@ -17147,19 +17147,19 @@ void reify_variables(
     int32_t pred_var = filter->hi_var;
 
     if (obj_var != -1) {
-        ecs_assert(vars[obj_var].kind == EcsRuleVarKindEntity, 
+        ecs_assert(vars[obj_var].kind == EcsRuleVarKindEntity,
             ECS_INTERNAL_ERROR, NULL);
 
-        entity_reg_set(rule, regs, obj_var, 
+        entity_reg_set(rule, regs, obj_var,
             ecs_get_alive(rule->world, ECS_PAIR_OBJECT(*elem)));
     }
 
     if (pred_var != -1) {
-        ecs_assert(vars[pred_var].kind == EcsRuleVarKindEntity, 
-            ECS_INTERNAL_ERROR, NULL);            
+        ecs_assert(vars[pred_var].kind == EcsRuleVarKindEntity,
+            ECS_INTERNAL_ERROR, NULL);
 
-        entity_reg_set(rule, regs, pred_var, 
-            ecs_get_alive(rule->world, 
+        entity_reg_set(rule, regs, pred_var,
+            ecs_get_alive(rule->world,
                 ECS_PAIR_RELATION(*elem)));
     }
 }
@@ -17207,7 +17207,7 @@ int32_t crawl_variable(
     ecs_rule_t *rule,
     ecs_rule_var_t *var,
     ecs_rule_var_t *root,
-    int recur)    
+    int recur)
 {
     ecs_term_t *terms = rule->filter.terms;
     int32_t i, count = rule->filter.term_count;
@@ -17217,8 +17217,8 @@ int32_t crawl_variable(
         if (skip_term(term)) {
             continue;
         }
-        
-        ecs_rule_var_t 
+
+        ecs_rule_var_t
         *pred = term_pred(rule, term),
         *subj = term_subj(rule, term),
         *obj = term_obj(rule, term);
@@ -17260,8 +17260,8 @@ int32_t get_depth_from_var(
     if (var->marked) {
         return 0;
     }
-    
-    /* Variable is not yet being evaluated and depth has not yet been set. 
+
+    /* Variable is not yet being evaluated and depth has not yet been set.
      * Calculate depth. */
     int32_t depth = get_variable_depth(rule, var, root, recur + 1);
     if (depth == UINT8_MAX) {
@@ -17287,7 +17287,7 @@ int32_t get_depth_from_term(
     if (!pred && !obj) {
         result = 0;
     } else {
-        /* If this is a variable that is not the same as the current, 
+        /* If this is a variable that is not the same as the current,
          * we can use it to determine dependency depth. */
         if (pred && cur != pred) {
             int32_t depth = get_depth_from_var(rule, pred, root, recur);
@@ -17341,7 +17341,7 @@ int32_t get_variable_depth(
             continue;
         }
 
-        ecs_rule_var_t 
+        ecs_rule_var_t
         *pred = term_pred(rule, term),
         *subj = term_subj(rule, term),
         *obj = term_obj(rule, term);
@@ -17368,11 +17368,11 @@ int32_t get_variable_depth(
         result = 0;
     }
 
-    var->depth = result;    
+    var->depth = result;
 
     /* Dependencies are calculated from subject to (pred, obj). If there were
      * subjects that are only related by object (like (X, Y), (Z, Y)) it is
-     * possible that those have not yet been found yet. To make sure those 
+     * possible that those have not yet been found yet. To make sure those
      * variables are found, loop again & follow predicate & object links */
     for (i = 0; i < count; i ++) {
         ecs_term_t *term = &terms[i];
@@ -17380,7 +17380,7 @@ int32_t get_variable_depth(
             continue;
         }
 
-        ecs_rule_var_t 
+        ecs_rule_var_t
         *subj = term_subj(rule, term),
         *pred = term_pred(rule, term),
         *obj = term_obj(rule, term);
@@ -17400,7 +17400,7 @@ int32_t get_variable_depth(
 
         if (obj && obj != var) {
             crawl_variable(rule, obj, root, recur);
-        }        
+        }
     }
 
     return var->depth;
@@ -17410,7 +17410,7 @@ int32_t get_variable_depth(
  * by depth, followed by how often they occur. */
 static
 int compare_variable(
-    const void* ptr1, 
+    const void* ptr1,
     const void *ptr2)
 {
     const ecs_rule_var_t *v1 = ptr1;
@@ -17437,9 +17437,9 @@ int compare_variable(
     return (v1->id < v2->id) - (v1->id > v2->id);
 }
 
-/* After all subject variables have been found, inserted and sorted, the 
+/* After all subject variables have been found, inserted and sorted, the
  * remaining variables (predicate & object) still need to be inserted. This
- * function serves two purposes. The first purpose is to ensure that all 
+ * function serves two purposes. The first purpose is to ensure that all
  * variables are known before operations are emitted. This ensures that the
  * variables array won't be reallocated while emitting, which simplifies code.
  * The second purpose of the function is to ensure that if the root variable
@@ -17464,7 +17464,7 @@ void ensure_all_variables(
             ensure_term_id_variable(rule, &term->pred);
         }
 
-        /* If subject is a variable and it is not This, make sure it is 
+        /* If subject is a variable and it is not This, make sure it is
          * registered as an entity variable. This ensures that the program will
          * correctly return all permutations */
         if (term->subj.var == EcsVarIsVariable) {
@@ -17477,7 +17477,7 @@ void ensure_all_variables(
         if (obj_is_set(term) && (term->obj.var == EcsVarIsVariable)) {
             ensure_term_id_variable(rule, &term->obj);
         }
-    }    
+    }
 }
 
 /* Scan for variables, put them in optimal dependency order. */
@@ -17503,11 +17503,11 @@ int scan_variables(
     for (i = 0; i < term_count; i ++) {
         ecs_term_t *term = &terms[i];
 
-        /* Evaluate the subject. The predicate and object are not evaluated, 
+        /* Evaluate the subject. The predicate and object are not evaluated,
          * since they never can be elected as root. */
         if (term_id_is_variable(&term->subj)) {
             const char *subj_name = term_id_var_name(&term->subj);
-            
+
             ecs_rule_var_t *subj = find_variable(
                 rule, EcsRuleVarKindTable, subj_name);
             if (!subj) {
@@ -17538,7 +17538,7 @@ int scan_variables(
         ecs_term_t *term = &terms[i];
 
         if (term->subj.var == EcsVarIsEntity) {
-            ecs_rule_var_t 
+            ecs_rule_var_t
             *pred = term_pred(rule, term),
             *obj = term_obj(rule, term);
 
@@ -17558,7 +17558,7 @@ int scan_variables(
         root_var = max_occur_var;
         if (root_var == UINT8_MAX) {
             /* If no subject variables have been found, the rule expression only
-             * operates on a fixed set of entities, in which case no root 
+             * operates on a fixed set of entities, in which case no root
              * election is required. */
             goto done;
         }
@@ -17571,10 +17571,10 @@ int scan_variables(
      * are variables that are unreachable from the root. */
     for (i = 0; i < rule->subject_variable_count; i ++) {
         if (rule->variables[i].depth == UINT8_MAX) {
-            rule_error(rule, "unconstrained variable '%s'", 
+            rule_error(rule, "unconstrained variable '%s'",
                 rule->variables[i].name);
             goto error;
-        } 
+        }
     }
 
     /* For each Not term, verify that variables are known */
@@ -17584,17 +17584,17 @@ int scan_variables(
             continue;
         }
 
-        ecs_rule_var_t 
+        ecs_rule_var_t
         *pred = term_pred(rule, term),
         *obj = term_obj(rule, term);
 
         if (!pred && term_id_is_variable(&term->pred)) {
-            rule_error(rule, "missing predicate variable '%s'", 
+            rule_error(rule, "missing predicate variable '%s'",
                 term_id_var_name(&term->pred));
             goto error;
         }
         if (!obj && term_id_is_variable(&term->obj)) {
-            rule_error(rule, "missing object variable '%s'", 
+            rule_error(rule, "missing object variable '%s'",
                 term_id_var_name(&term->obj));
             goto error;
         }
@@ -17610,7 +17610,7 @@ int scan_variables(
     for (i = 0; i < rule->variable_count; i ++) {
         rule->variables[i].id = i;
     }
-    
+
 done:
     return 0;
 error:
@@ -17662,7 +17662,7 @@ ecs_rule_var_t* most_specific_var(
         tvar = find_variable(rule, EcsRuleVarKindTable, var->name);
     }
 
-    /* If variable is used as predicate or object, it should have been 
+    /* If variable is used as predicate or object, it should have been
      * registered as an entity. */
     ecs_assert(evar != NULL, ECS_INTERNAL_ERROR, NULL);
 
@@ -17747,7 +17747,7 @@ ecs_rule_var_t* ensure_entity_written(
 
     /* Make sure the variable has been written */
     ecs_assert(written[evar->id] == true, ECS_INTERNAL_ERROR, NULL);
-    
+
     return evar;
 }
 
@@ -17761,7 +17761,7 @@ ecs_rule_op_t* insert_operation(
 
     /* Parse the term's type into a pair. A pair extracts the ids from
      * the term, and replaces variables with wildcards which can then
-     * be matched against actual relationships. A pair retains the 
+     * be matched against actual relationships. A pair retains the
      * information about the variables, so that when a match happens,
      * the pair can be used to reify the variable. */
     if (term_index != -1) {
@@ -17772,7 +17772,7 @@ ecs_rule_op_t* insert_operation(
         /* If the pair contains entity variables that have not yet been written,
          * insert each instructions in case their tables are known. Variables in
          * a pair that are truly unknown will be populated by the operation,
-         * but an operation should never overwrite an entity variable if the 
+         * but an operation should never overwrite an entity variable if the
          * corresponding table variable has already been resolved. */
         if (pair.reg_mask & RULE_PAIR_PREDICATE) {
             ecs_rule_var_t *pred = &rule->variables[pair.pred.reg];
@@ -17816,7 +17816,7 @@ void insert_input(
 
     /* When Input is evaluated with redo = true it will return false, which will
      * finish the program as op becomes -1. */
-    op->on_fail = -1;  
+    op->on_fail = -1;
 
     push_frame(rule);
 }
@@ -17869,7 +17869,7 @@ void insert_reflexive_set(
 
     /* If the operation to be inserted is a superset, the output variable needs
      * to be an entity as a superset is always resolved one at a time */
-    ecs_assert((op_kind != EcsRuleSuperSet) || 
+    ecs_assert((op_kind != EcsRuleSuperSet) ||
         out->kind == EcsRuleVarKindEntity, ECS_INTERNAL_ERROR, NULL);
 
     int32_t setjmp_lbl = rule->operation_count;
@@ -17970,11 +17970,11 @@ void insert_reflexive_set(
 
     if (reflexive) {
         /* The jump operation jumps to either the store or subset operation,
-        * depending on whether the store operation already yielded. The 
-        * operation is inserted last, so that the on_fail label of the next 
+        * depending on whether the store operation already yielded. The
+        * operation is inserted last, so that the on_fail label of the next
         * operation will point to it */
         jump->kind = EcsRuleJump;
-        
+
         /* The pass/fail labels of the Jump operation are not used, since it
         * jumps to a variable location. Instead, the pass label is (ab)used to
         * store the label of the SetJmp operation, so that the jump can access
@@ -17999,7 +17999,7 @@ ecs_rule_var_t* store_reflexive_set(
 
     /* The superset operation returns entities */
     if (op_kind == EcsRuleSuperSet) {
-        var_kind = EcsRuleVarKindEntity;   
+        var_kind = EcsRuleVarKindEntity;
     }
 
     /* Create anonymous variable for storing the set */
@@ -18065,14 +18065,14 @@ void set_input_to_subj(
     ecs_rule_var_t *var)
 {
     (void)rule;
-    
+
     op->has_in = true;
     if (!var) {
         op->r_in = UINT8_MAX;
         op->subject = term->subj.entity;
 
         /* Invalid entities should have been caught during parsing */
-        ecs_assert(ecs_is_valid(rule->world, op->subject), 
+        ecs_assert(ecs_is_valid(rule->world, op->subject),
             ECS_INTERNAL_ERROR, NULL);
     } else {
         op->r_in = var->id;
@@ -18094,7 +18094,7 @@ void set_output_to_subj(
         op->subject = term->subj.entity;
 
         /* Invalid entities should have been caught during parsing */
-        ecs_assert(ecs_is_valid(rule->world, op->subject), 
+        ecs_assert(ecs_is_valid(rule->world, op->subject),
             ECS_INTERNAL_ERROR, NULL);
     } else {
         op->r_out = var->id;
@@ -18148,7 +18148,7 @@ void insert_select_or_with(
     if (!pair) {
         op = insert_operation(rule, c, written);
 
-    /* If an explicit pair is provided, override the default one from the 
+    /* If an explicit pair is provided, override the default one from the
      * term. This allows for using a predicate or object variable different
      * from what is in the term. One application of this is to substitute a
      * predicate with its subsets, if it is non final */
@@ -18173,7 +18173,7 @@ void insert_select_or_with(
         op->r_in = tvar->id;
         set_input_to_subj(rule, op, term, subj);
 
-    /* If subject is neither table nor entitiy, with operates on literal */        
+    /* If subject is neither table nor entitiy, with operates on literal */
     } else if (!tvar && !evar) {
         op->kind = EcsRuleWith;
         set_input_to_subj(rule, op, term, subj);
@@ -18211,7 +18211,7 @@ static
 void prepare_predicate(
     ecs_rule_t *rule,
     ecs_rule_pair_t *pair,
-    bool *written)  
+    bool *written)
 {
     /* If pair is not final, resolve term for all IsA relationships of the
      * predicate. Note that if the pair has final set to true, it is guaranteed
@@ -18294,10 +18294,10 @@ void insert_term_2(
                         set_pair.obj.ent = term->subj.entity;
                     }
 
-                    insert_reflexive_set(rule, EcsRuleSuperSet, obj, set_pair, 
+                    insert_reflexive_set(rule, EcsRuleSuperSet, obj, set_pair,
                         c, written, filter->reflexive);
 
-                /* If subject is variable, first find matching pair for the 
+                /* If subject is variable, first find matching pair for the
                  * evaluated entity(s) and return supersets */
                 } else {
                     ecs_rule_var_t *av = create_anonymous_variable(
@@ -18320,7 +18320,7 @@ void insert_term_2(
                     /* Find supersets for returned initial object. Make sure
                      * this is always reflexive since it needs to return the
                      * object from the pair that the entity has itself. */
-                    insert_reflexive_set(rule, EcsRuleSuperSet, obj, set_pair, 
+                    insert_reflexive_set(rule, EcsRuleSuperSet, obj, set_pair,
                         c, written, true);
                 }
             }
@@ -18340,7 +18340,7 @@ void insert_term_2(
                     set_pair.obj.ent = term->obj.entity;
                 }
 
-                insert_reflexive_set(rule, EcsRuleSubSet, subj, set_pair, c, 
+                insert_reflexive_set(rule, EcsRuleSubSet, subj, set_pair, c,
                     written, filter->reflexive);
             } else if (subj == obj) {
                 insert_select_or_with(rule, c, term, subj, filter, written);
@@ -18379,7 +18379,7 @@ void insert_term_2(
                 /* Insert superset instruction to find all supersets */
                 if (filter->reflexive) {
                     subj = ensure_most_specific_var(rule, subj, written);
-                    ecs_assert(subj->kind == EcsRuleVarKindEntity, 
+                    ecs_assert(subj->kind == EcsRuleVarKindEntity,
                         ECS_INTERNAL_ERROR, NULL);
                     ecs_assert(written[subj->id] == true,
                         ECS_INTERNAL_ERROR, NULL);
@@ -18389,10 +18389,10 @@ void insert_term_2(
                     super_filter.obj.reg = subj->id;
                     super_filter.reg_mask = filter->reg_mask & RULE_PAIR_OBJECT;
 
-                    insert_reflexive_set(rule, EcsRuleSuperSet, obj, 
+                    insert_reflexive_set(rule, EcsRuleSuperSet, obj,
                         super_filter, c, written, true);
                 } else {
-                    insert_reflexive_set(rule, EcsRuleSuperSet, obj, 
+                    insert_reflexive_set(rule, EcsRuleSuperSet, obj,
                         op->filter, c, written, true);
                 }
             }
@@ -18402,7 +18402,7 @@ void insert_term_2(
     if (same_obj_subj) {
         /* Can't have relation with same variables that is acyclic and not
          * reflexive, this should've been caught earlier. */
-        ecs_assert(!filter->acyclic || filter->reflexive, 
+        ecs_assert(!filter->acyclic || filter->reflexive,
             ECS_INTERNAL_ERROR, NULL);
 
         /* If relation is reflexive and entity has an instance of R, no checks
@@ -18414,11 +18414,11 @@ void insert_term_2(
              * of the entities in the table with the pair. */
             ecs_rule_op_t *op = insert_operation(rule, -1, written);
             obj = get_most_specific_var(rule, obj, written);
-            ecs_assert(obj->kind == EcsRuleVarKindEntity, 
+            ecs_assert(obj->kind == EcsRuleVarKindEntity,
                 ECS_INTERNAL_ERROR, NULL);
             ecs_assert(written[subj->id] == true, ECS_INTERNAL_ERROR, NULL);
             ecs_assert(written[obj->id] == true, ECS_INTERNAL_ERROR, NULL);
-            
+
             set_input_to_subj(rule, op, term, subj);
             op->filter.obj.reg = obj->id;
             op->filter.reg_mask = RULE_PAIR_OBJECT;
@@ -18596,15 +18596,15 @@ void compile_program(
         insert_term(rule, term, c, written);
     }
 
-    /* Insert terms with Optional operators last, as optional terms cannot 
-     * eliminate results, and would just add overhead to evaluation of 
+    /* Insert terms with Optional operators last, as optional terms cannot
+     * eliminate results, and would just add overhead to evaluation of
      * non-matching entities. */
     for (c = 0; c < term_count; c ++) {
         ecs_term_t *term = &terms[c];
         if (term->oper != EcsOptional) {
             continue;
         }
-        
+
         insert_term(rule, term, c, written);
     }
 
@@ -18634,14 +18634,14 @@ void compile_program(
     for (; v < rule->variable_count; v ++) {
         if (!written[v]) {
             ecs_rule_var_t *var = &rule->variables[v];
-            ecs_assert(var->kind == EcsRuleVarKindEntity, 
+            ecs_assert(var->kind == EcsRuleVarKindEntity,
                 ECS_INTERNAL_ERROR, NULL);
 
             ecs_rule_var_t *table_var = find_variable(
                 rule, EcsRuleVarKindTable, var->name);
-            
+
             /* A table variable must exist if the variable hasn't been resolved
-             * yet. If there doesn't exist one, this could indicate an 
+             * yet. If there doesn't exist one, this could indicate an
              * unconstrained variable which should have been caught earlier */
             ecs_assert(table_var != NULL, ECS_INTERNAL_ERROR, var->name);
 
@@ -18655,10 +18655,10 @@ void compile_program(
             op->has_in = true;
             op->has_out = true;
             written[var->id] = true;
-            
+
             push_frame(rule);
         }
-    }     
+    }
 
     /* Insert yield, which is always the last operation */
     insert_yield(rule);
@@ -18774,7 +18774,7 @@ ecs_rule_t* ecs_rule_init(
     /* Generate the opcode array */
     compile_program(result);
 
-    /* Create array with variable names so this can be easily accessed by 
+    /* Create array with variable names so this can be easily accessed by
      * iterators without requiring access to the ecs_rule_t */
     create_variable_name_array(result);
 
@@ -18794,7 +18794,7 @@ ecs_rule_t* ecs_rule_init(
             if (subj) {
                 result->subject_variables[i] = subj->id;
                 continue;
-            }          
+            }
         }
 
         result->subject_variables[i] = -1;
@@ -18829,7 +18829,7 @@ void ecs_rule_fini(
 const ecs_filter_t* ecs_rule_get_filter(
     const ecs_rule_t *rule)
 {
-    return &rule->filter; 
+    return &rule->filter;
 }
 
 /* Quick convenience function to get a variable from an id */
@@ -18851,7 +18851,7 @@ char* ecs_rule_str(
     ecs_rule_t *rule)
 {
     ecs_check(rule != NULL, ECS_INVALID_PARAMETER, NULL);
-    
+
     ecs_world_t *world = rule->world;
     ecs_strbuf_t buf = ECS_STRBUF_INIT;
     char filter_expr[256];
@@ -18885,7 +18885,7 @@ char* ecs_rule_str(
             obj_name = "0";
         }
 
-        ecs_strbuf_append(&buf, "%2d: [S:%2d, P:%2d, F:%2d] ", i, 
+        ecs_strbuf_append(&buf, "%2d: [S:%2d, P:%2d, F:%2d] ", i,
             op->frame, op->on_pass, op->on_fail);
 
         bool has_filter = false;
@@ -18905,11 +18905,11 @@ char* ecs_rule_str(
         case EcsRuleSuperSet:
             ecs_strbuf_append(&buf, "superset ");
             has_filter = true;
-            break;             
+            break;
         case EcsRuleSubSet:
             ecs_strbuf_append(&buf, "subset   ");
             has_filter = true;
-            break;            
+            break;
         case EcsRuleEach:
             ecs_strbuf_append(&buf, "each     ");
             break;
@@ -18929,7 +18929,7 @@ char* ecs_rule_str(
         case EcsRuleEq:
             ecs_strbuf_append(&buf, "eq       ");
             has_filter = true;
-            break;            
+            break;
         case EcsRuleYield:
             ecs_strbuf_append(&buf, "yield    ");
             break;
@@ -18940,7 +18940,7 @@ char* ecs_rule_str(
         if (op->has_out) {
             ecs_rule_var_t *r_out = get_variable(rule, op->r_out);
             if (r_out) {
-                ecs_strbuf_append(&buf, "O:%s%s ", 
+                ecs_strbuf_append(&buf, "O:%s%s ",
                     r_out->kind == EcsRuleVarKindTable ? "t" : "",
                     r_out->name);
             } else if (op->subject) {
@@ -18953,7 +18953,7 @@ char* ecs_rule_str(
         if (op->has_in) {
             ecs_rule_var_t *r_in = get_variable(rule, op->r_in);
             if (r_in) {
-                ecs_strbuf_append(&buf, "I:%s%s ", 
+                ecs_strbuf_append(&buf, "I:%s%s ",
                     r_in->kind == EcsRuleVarKindTable ? "t" : "",
                     r_in->name);
             }
@@ -19067,7 +19067,7 @@ void ecs_rule_set_var(
     ecs_rule_var_t *var = &r->variables[var_id];
     if (var->other != -1) {
         ecs_rule_var_t *tvar = &r->variables[var->other];
-        ecs_assert(tvar->kind == EcsRuleVarKindTable, 
+        ecs_assert(tvar->kind == EcsRuleVarKindTable,
             ECS_INTERNAL_ERROR, NULL);
         (void)tvar;
         reg_set_entity(r, iter->registers, var->other, value);
@@ -19110,16 +19110,16 @@ ecs_iter_t ecs_rule_iter(
 
     if (rule->operation_count) {
         if (rule->variable_count) {
-            it->registers = ecs_os_malloc_n(ecs_rule_reg_t, 
+            it->registers = ecs_os_malloc_n(ecs_rule_reg_t,
                 rule->operation_count * rule->variable_count);
 
             it->variables = ecs_os_malloc_n(ecs_entity_t, rule->variable_count);
         }
-        
+
         it->op_ctx = ecs_os_calloc_n(ecs_rule_op_ctx_t, rule->operation_count);
 
         if (rule->filter.term_count) {
-            it->columns = ecs_os_malloc_n(int32_t, 
+            it->columns = ecs_os_malloc_n(int32_t,
                 rule->operation_count * rule->filter.term_count);
         }
 
@@ -19151,7 +19151,7 @@ ecs_iter_t ecs_rule_iter(
 }
 
 /* Edge case: if the filter has the same variable for both predicate and
- * object, they are both resolved at the same time but at the time of 
+ * object, they are both resolved at the same time but at the time of
  * evaluating the filter they're still wildcards which would match columns
  * that have different predicates/objects. Do an additional scan to make
  * sure the column we're returning actually matches. */
@@ -19164,10 +19164,10 @@ int32_t find_next_same_var(
     /* If same_var is true, this has to be a wildcard pair. We cannot have
      * the same variable in a pair, and one part of a pair resolved with
      * another part unresolved. */
-    ecs_assert(pattern == ecs_pair(EcsWildcard, EcsWildcard), 
+    ecs_assert(pattern == ecs_pair(EcsWildcard, EcsWildcard),
         ECS_INTERNAL_ERROR, NULL);
     (void)pattern;
-    
+
     /* Keep scanning for an id where rel and obj are the same */
     ecs_id_t *ids = ecs_vector_first(type, ecs_id_t);
     int32_t i, count = ecs_vector_count(type);
@@ -19205,7 +19205,7 @@ int32_t find_next_column(
             return -1;
         }
         column = tr->column;
-    } else {   
+    } else {
         column ++;
 
         if (ecs_vector_count(table->type) <= column) {
@@ -19375,7 +19375,7 @@ bool eval_superset(
     ecs_assert(r != UINT8_MAX, ECS_INTERNAL_ERROR, NULL);
 
     /* Superset results are always stored in an entity variable */
-    ecs_assert(rule->variables[r].kind == EcsRuleVarKindEntity,    
+    ecs_assert(rule->variables[r].kind == EcsRuleVarKindEntity,
         ECS_INTERNAL_ERROR, NULL);
 
     /* Get queried for id, fill out potential variables */
@@ -19383,8 +19383,8 @@ bool eval_superset(
 
     ecs_rule_filter_t filter = pair_to_filter(iter, op, pair);
     ecs_entity_t rel = ECS_PAIR_RELATION(filter.mask);
-    ecs_rule_filter_t super_filter = { 
-        .mask = ecs_pair(rel, EcsWildcard) 
+    ecs_rule_filter_t super_filter = {
+        .mask = ecs_pair(rel, EcsWildcard)
     };
     ecs_table_t *table = NULL;
 
@@ -19394,7 +19394,7 @@ bool eval_superset(
     bool output_is_input = result != EcsWildcard;
 
     if (output_is_input && !redo) {
-        ecs_assert(regs[r].entity == iter->registers[r].entity, 
+        ecs_assert(regs[r].entity == iter->registers[r].entity,
             ECS_INTERNAL_ERROR, NULL);
     }
 
@@ -19420,7 +19420,7 @@ bool eval_superset(
         if (output_is_input) {
             ecs_id_t id = ecs_pair(rel, result);
             ecs_entity_t subj = 0;
-            column = ecs_search_relation(world, table, 0, id, rel, 
+            column = ecs_search_relation(world, table, 0, id, rel,
                 0, 0, &subj, 0, NULL);
             if (column != -1) {
                 if (subj != 0) {
@@ -19481,7 +19481,7 @@ bool eval_superset(
             entity_reg_set(rule, regs, r, col_obj);
             set_column(it, op, table->type, column);
 
-            return true;        
+            return true;
         }
 
         sp --;
@@ -19527,7 +19527,7 @@ bool eval_subset(
 
         frame->with_ctx.table_index = 0;
         table_record = find_next_table(&filter, &frame->with_ctx);
-        
+
         /* If first table set has no non-empty table, yield nothing */
         if (!table_record.table) {
             return false;
@@ -19666,13 +19666,13 @@ bool eval_select(
     /* If this is a redo, we already looked up the table set */
     if (redo) {
         idr = op_ctx->idr;
-    
+
     /* If this is not a redo lookup the table set. Even though this may not be
      * the first time the operation is evaluated, variables may have changed
      * since last time, which could change the table set to lookup. */
     } else {
-        /* A table set is a set of tables that all contain at least the 
-         * requested look_for expression. What is returned is a table record, 
+        /* A table set is a set of tables that all contain at least the
+         * requested look_for expression. What is returned is a table record,
          * which in addition to the table also stores the first occurrance at
          * which the requested expression occurs in the table. This reduces (and
          * in most cases eliminates) any searching that needs to occur in a
@@ -19693,14 +19693,14 @@ bool eval_select(
     bool output_is_input = table != NULL;
 
     if (output_is_input && !redo) {
-        ecs_assert(regs[r].table == iter->registers[r].table, 
+        ecs_assert(regs[r].table == iter->registers[r].table,
             ECS_INTERNAL_ERROR, NULL);
 
         table = iter->registers[r].table;
 
-        /* Check if table can be found in the id record. If not, the provided 
+        /* Check if table can be found in the id record. If not, the provided
         * table does not match with the query. */
-        ecs_table_record_t *tr = ecs_table_cache_get(&idr->cache, 
+        ecs_table_record_t *tr = ecs_table_cache_get(&idr->cache,
             ecs_table_record_t, table);
         if (!tr) {
             return false;
@@ -19716,7 +19716,7 @@ bool eval_select(
 
             /* Return the first table_record in the table set. */
             table_record = find_next_table(&filter, op_ctx);
-        
+
             /* If no table record was found, there are no results. */
             if (!table_record.table) {
                 return false;
@@ -19730,10 +19730,10 @@ bool eval_select(
             /* Store table in register */
             table_reg_set(rule, regs, r, table);
         }
-    
+
     /* If this is a redo, progress to the next match */
     } else {
-        /* First test if there are any more matches for the current table, in 
+        /* First test if there are any more matches for the current table, in
          * case we're looking for a wildcard. */
         if (filter.wildcard) {
             table = table_reg_get(rule, regs, r);
@@ -19772,7 +19772,7 @@ bool eval_select(
     if (filter.wildcard) {
         reify_variables(iter, op, &filter, table->type, column);
     }
-    
+
     if (!pair.obj_0) {
         set_column(it, op, table->type, column);
     }
@@ -19820,7 +19820,7 @@ bool eval_with(
     /* If this is a redo, we already looked up the table set */
     if (redo) {
         idr = op_ctx->idr;
-    
+
     /* If this is not a redo lookup the table set. Even though this may not be
      * the first time the operation is evaluated, variables may have changed
      * since last time, which could change the table set to lookup. */
@@ -19829,7 +19829,7 @@ bool eval_with(
          * transitive predicate which is provided with the same subject and
          * object, it should return true. By default with will not return true
          * as the subject likely does not have itself as a relationship, which
-         * is why this is a special case. 
+         * is why this is a special case.
          *
          * TODO: might want to move this code to a separate with_reflexive
          * instruction to limit branches for non-transitive queries (and to keep
@@ -19837,7 +19837,7 @@ bool eval_with(
          */
         if (pair.transitive && pair.reflexive) {
             ecs_entity_t subj = 0, obj = 0;
-            
+
             if (r == UINT8_MAX) {
                 subj = op->subject;
             } else {
@@ -19850,7 +19850,7 @@ bool eval_with(
                 }
             }
 
-            /* If subj is set, it means that it is an entity. Try to also 
+            /* If subj is set, it means that it is an entity. Try to also
              * resolve the object. */
             if (subj) {
                 /* If the object is not a wildcard, it has been reified. Get the
@@ -19871,7 +19871,7 @@ bool eval_with(
         idr = op_ctx->idr = find_tables(world, filter.mask);
     }
 
-    /* If no table set was found for queried for entity, there are no results. 
+    /* If no table set was found for queried for entity, there are no results.
      * If this result is a transitive query, the table we're evaluating may not
      * be in the returned table set. Regardless, if the filter that contains a
      * transitive predicate does not have any tables associated with it, there
@@ -19888,13 +19888,13 @@ bool eval_with(
     /* If this is not a redo, start at the beginning */
     if (!redo) {
         column = find_next_column(world, table, -1, &filter);
-    
+
     /* If this is a redo, progress to the next match */
-    } else {        
+    } else {
         if (!filter.wildcard) {
             return false;
         }
-        
+
         /* Find the next match for the expression in the column. The columns
          * array keeps track of the state for each With operation, so that
          * even after redoing a With, the search doesn't have to start from
@@ -19948,15 +19948,15 @@ bool eval_each(
     ecs_entity_t e;
 
     /* Make sure in/out registers are of the correct kind */
-    ecs_assert(iter->rule->variables[r_in].kind == EcsRuleVarKindTable, 
+    ecs_assert(iter->rule->variables[r_in].kind == EcsRuleVarKindTable,
         ECS_INTERNAL_ERROR, NULL);
-    ecs_assert(iter->rule->variables[r_out].kind == EcsRuleVarKindEntity, 
+    ecs_assert(iter->rule->variables[r_out].kind == EcsRuleVarKindEntity,
         ECS_INTERNAL_ERROR, NULL);
 
     /* Get table, make sure that it contains data. The select operation should
      * ensure that empty tables are never forwarded. */
     ecs_table_t *table = table_reg_get(iter->rule, regs, r_in);
-    if (table) {       
+    if (table) {
         int32_t row, count = regs[r_in].count;
         int32_t offset = regs[r_in].offset;
 
@@ -19991,7 +19991,7 @@ bool eval_each(
             if (row == count) {
                 return false;
             }
-            e = entities[row];      
+            e = entities[row];
         }
     } else {
         if (!redo) {
@@ -20007,7 +20007,7 @@ bool eval_each(
     return true;
 }
 
-/* Store operation. Stores entity in register. This can either be an entity 
+/* Store operation. Stores entity in register. This can either be an entity
  * literal or an entity variable that will be stored in a table register. The
  * latter facilitates scenarios where an iterator only need to return a single
  * entity but where the Yield returns tables. */
@@ -20036,7 +20036,7 @@ bool eval_store(
     bool output_is_input = out && out != EcsWildcard;
 
     if (output_is_input && !redo) {
-        ecs_assert(regs[r_out].entity == iter->registers[r_out].entity, 
+        ecs_assert(regs[r_out].entity == iter->registers[r_out].entity,
             ECS_INTERNAL_ERROR, NULL);
 
         if (out != in) {
@@ -20079,7 +20079,7 @@ bool eval_setjmp(
 }
 
 /* The jump operation jumps to an operation label. The operation always returns
- * true. Since the operation modifies the control flow of the program directly, 
+ * true. Since the operation modifies the control flow of the program directly,
  * the dispatcher does not look at the on_pass or on_fail labels of the jump
  * instruction. Instead, the on_pass label is used to store the label of the
  * operation that contains the label to jump to. */
@@ -20122,7 +20122,7 @@ bool eval_intable(
     bool redo)
 {
     (void)op_index;
-    
+
     if (redo) {
         return false;
     }
@@ -20219,7 +20219,7 @@ void push_registers(
     ecs_rule_reg_t *src_regs = get_register_frame(it, cur);
     ecs_rule_reg_t *dst_regs = get_register_frame(it, next);
 
-    ecs_os_memcpy_n(dst_regs, src_regs, 
+    ecs_os_memcpy_n(dst_regs, src_regs,
         ecs_rule_reg_t, it->rule->variable_count);
 }
 
@@ -20274,7 +20274,7 @@ void populate_iterator(
         } else {
             /* If a single entity is returned, simply return the
              * iterator with count 1 and a pointer to the entity id */
-            ecs_assert(var->kind == EcsRuleVarKindEntity, 
+            ecs_assert(var->kind == EcsRuleVarKindEntity,
                 ECS_INTERNAL_ERROR, NULL);
 
             ecs_entity_t e = reg->entity;
@@ -20326,7 +20326,7 @@ void populate_iterator(
         }
     }
 
-    flecs_iter_populate_data(world, iter, table, offset, count, 
+    flecs_iter_populate_data(world, iter, table, offset, count,
         iter->ptrs, iter->sizes);
 }
 
@@ -20396,7 +20396,7 @@ bool ecs_rule_next_instanced(
 
         for (i = 0; i < rule->filter.term_count; i ++) {
             ecs_term_t *term = &rule->filter.terms[i];
-            if (term->subj.set.mask & EcsNothing || 
+            if (term->subj.set.mask & EcsNothing ||
                 term->oper == EcsNot ||
                 term->oper == EcsOptional ||
                 term->id == ecs_pair(EcsChildOf, 0)) {
@@ -20407,7 +20407,7 @@ bool ecs_rule_next_instanced(
 
     do {
         /* Evaluate an operation. The result of an operation determines the
-         * flow of the program. If an operation returns true, the program 
+         * flow of the program. If an operation returns true, the program
          * continues to the operation pointed to by 'on_pass'. If the operation
          * returns false, the program continues to the operation pointed to by
          * 'on_fail'.
@@ -20505,7 +20505,7 @@ ecs_entity_t ecs_import(
     char *path = ecs_module_path_from_c(module_name);
     ecs_entity_t e = ecs_lookup_fullpath(world, path);
     ecs_os_free(path);
-    
+
     if (!e) {
         ecs_trace("#[magenta]import#[reset] %s", module_name);
         ecs_log_push();
@@ -20551,7 +20551,7 @@ ecs_entity_t ecs_import_from_library(
     if (!import_func) {
         import_func = ecs_os_malloc(ecs_os_strlen(library_name) + ECS_SIZEOF("Import"));
         ecs_assert(import_func != NULL, ECS_OUT_OF_MEMORY, NULL);
-        
+
         const char *ptr;
         char ch, *bptr = import_func;
         bool capitalize = true;
@@ -20586,24 +20586,24 @@ ecs_entity_t ecs_import_from_library(
         }
         return 0;
     } else {
-        ecs_trace("found file '%s' for library '%s'", 
+        ecs_trace("found file '%s' for library '%s'",
             library_filename, library_name);
     }
 
     ecs_os_dl_t dl = ecs_os_dlopen(library_filename);
     if (!dl) {
-        ecs_err("failed to load library '%s' ('%s')", 
+        ecs_err("failed to load library '%s' ('%s')",
             library_name, library_filename);
-        
+
         ecs_os_free(library_filename);
 
         if (module != module_name) {
             ecs_os_free(module);
-        }    
+        }
 
         return 0;
     } else {
-        ecs_trace("library '%s' ('%s') loaded", 
+        ecs_trace("library '%s' ('%s') loaded",
             library_name, library_filename);
     }
 
@@ -20613,7 +20613,7 @@ ecs_entity_t ecs_import_from_library(
         ecs_err("failed to load import function %s from library %s",
             import_func, library_name);
         ecs_os_free(library_filename);
-        ecs_os_dlclose(dl);            
+        ecs_os_dlclose(dl);
         return 0;
     } else {
         ecs_trace("found import function '%s' in library '%s' for module '%s'",
@@ -20688,7 +20688,7 @@ void ecs_meta_dtor_serialized(
     EcsMetaTypeSerialized *ptr);
 
 #endif
-    
+
 #endif
 
 
@@ -20721,7 +20721,7 @@ ecs_entity_t ecs_enum_init(
         if (!m_desc->value) {
             ecs_add_id(world, c, EcsConstant);
         } else {
-            ecs_set_pair_object(world, c, EcsConstant, ecs_i32_t, 
+            ecs_set_pair_object(world, c, EcsConstant, ecs_i32_t,
                 {m_desc->value});
         }
     }
@@ -20764,7 +20764,7 @@ ecs_entity_t ecs_bitmask_init(
         if (!m_desc->value) {
             ecs_add_id(world, c, EcsConstant);
         } else {
-            ecs_set_pair_object(world, c, EcsConstant, ecs_u32_t, 
+            ecs_set_pair_object(world, c, EcsConstant, ecs_u32_t,
                 {m_desc->value});
         }
     }
@@ -20832,7 +20832,7 @@ ecs_entity_t ecs_struct_init(
         }
 
         if (!m_desc->name) {
-            ecs_err("member %d of struct '%s' does not have a name", i, 
+            ecs_err("member %d of struct '%s' does not have a name", i,
                 ecs_get_name(world, t));
             ecs_delete(world, t);
             return 0;
@@ -20843,7 +20843,7 @@ ecs_entity_t ecs_struct_init(
         });
 
         ecs_set(world, m, EcsMember, {
-            .type = m_desc->type, 
+            .type = m_desc->type,
             .count = m_desc->count
         });
     }
@@ -20930,7 +20930,7 @@ ecs_vector_t* serialize_enum(
     ecs_vector_t *ops)
 {
     (void)world;
-    
+
     ecs_meta_type_op_t *op = ops_add(&ops, EcsOpEnum);
     op->offset = offset,
     op->type = type;
@@ -20947,7 +20947,7 @@ ecs_vector_t* serialize_bitmask(
     ecs_vector_t *ops)
 {
     (void)world;
-    
+
     ecs_meta_type_op_t *op = ops_add(&ops, EcsOpBitmask);
     op->offset = offset,
     op->type = type;
@@ -21049,7 +21049,7 @@ ecs_vector_t* serialize_struct(
         if (op->count <= 1) {
             op->count = member->count;
         }
-        
+
         const char *member_name = member->name;
         op->name = member_name;
         op->op_count = ecs_vector_count(ops) - cur;
@@ -21168,11 +21168,11 @@ void ecs_meta_type_serialized_init(
 /* EcsMetaTypeSerialized lifecycle */
 
 void ecs_meta_dtor_serialized(
-    EcsMetaTypeSerialized *ptr) 
+    EcsMetaTypeSerialized *ptr)
 {
     int32_t i, count = ecs_vector_count(ptr->ops);
     ecs_meta_type_op_t *ops = ecs_vector_first(ptr->ops, ecs_meta_type_op_t);
-    
+
     for (i = 0; i < count; i ++) {
         ecs_meta_type_op_t *op = &ops[i];
         if (op->members) {
@@ -21181,7 +21181,7 @@ void ecs_meta_dtor_serialized(
         }
     }
 
-    ecs_vector_free(ptr->ops); 
+    ecs_vector_free(ptr->ops);
 }
 
 static ECS_COPY(EcsMetaTypeSerialized, dst, src, {
@@ -21191,7 +21191,7 @@ static ECS_COPY(EcsMetaTypeSerialized, dst, src, {
 
     int32_t o, count = ecs_vector_count(src->ops);
     ecs_meta_type_op_t *ops = ecs_vector_first(src->ops, ecs_meta_type_op_t);
-    
+
     for (o = 0; o < count; o ++) {
         ecs_meta_type_op_t *op = &ops[o];
         if (op->members) {
@@ -21207,7 +21207,7 @@ static ECS_MOVE(EcsMetaTypeSerialized, dst, src, {
     src->ops = NULL;
 })
 
-static ECS_DTOR(EcsMetaTypeSerialized, ptr, { 
+static ECS_DTOR(EcsMetaTypeSerialized, ptr, {
     ecs_meta_dtor_serialized(ptr);
 })
 
@@ -21215,7 +21215,7 @@ static ECS_DTOR(EcsMetaTypeSerialized, ptr, {
 /* EcsStruct lifecycle */
 
 static void dtor_struct(
-    EcsStruct *ptr) 
+    EcsStruct *ptr)
 {
     ecs_member_t *members = ecs_vector_first(ptr->members, ecs_member_t);
     int32_t i, count = ecs_vector_count(ptr->members);
@@ -21250,7 +21250,7 @@ static ECS_DTOR(EcsStruct, ptr, { dtor_struct(ptr); })
 /* EcsEnum lifecycle */
 
 static void dtor_enum(
-    EcsEnum *ptr) 
+    EcsEnum *ptr)
 {
     ecs_map_iter_t it = ecs_map_iter(ptr->constants);
     ecs_enum_constant_t *c;
@@ -21286,7 +21286,7 @@ static ECS_DTOR(EcsEnum, ptr, { dtor_enum(ptr); })
 /* EcsBitmask lifecycle */
 
 static void dtor_bitmask(
-    EcsBitmask *ptr) 
+    EcsBitmask *ptr)
 {
     ecs_map_iter_t it = ecs_map_iter(ptr->constants);
     ecs_bitmask_constant_t *c;
@@ -21332,7 +21332,7 @@ int init_type(
 
     EcsMetaType *meta_type = ecs_get_mut(world, type, EcsMetaType, NULL);
     if (meta_type->kind && meta_type->kind != kind) {
-        ecs_err("type '%s' reregistered with different kind", 
+        ecs_err("type '%s' reregistered with different kind",
             ecs_get_name(world, type));
         return -1;
     }
@@ -21539,13 +21539,13 @@ int add_member_to_struct(
 
 static
 int add_constant_to_enum(
-    ecs_world_t *world, 
-    ecs_entity_t type, 
+    ecs_world_t *world,
+    ecs_entity_t type,
     ecs_entity_t e,
     ecs_id_t constant_id)
 {
     EcsEnum *ptr = ecs_get_mut(world, type, EcsEnum, NULL);
-    
+
     /* Remove constant from map if it was already added */
     ecs_map_iter_t it = ecs_map_iter(ptr->constants);
     ecs_enum_constant_t *c;
@@ -21612,13 +21612,13 @@ int add_constant_to_enum(
 
 static
 int add_constant_to_bitmask(
-    ecs_world_t *world, 
-    ecs_entity_t type, 
+    ecs_world_t *world,
+    ecs_entity_t type,
     ecs_entity_t e,
     ecs_id_t constant_id)
 {
     EcsBitmask *ptr = ecs_get_mut(world, type, EcsBitmask, NULL);
-    
+
     /* Remove constant from map if it was already added */
     ecs_map_iter_t it = ecs_map_iter(ptr->constants);
     ecs_bitmask_constant_t *c;
@@ -21687,87 +21687,87 @@ void set_primitive(ecs_iter_t *it) {
         ecs_entity_t e = it->entities[i];
         switch(type->kind) {
         case EcsBool:
-            init_component(world, e, 
+            init_component(world, e,
                 ECS_SIZEOF(bool), ECS_ALIGNOF(bool));
             init_type(world, e, EcsPrimitiveType);
             break;
         case EcsChar:
-            init_component(world, e, 
+            init_component(world, e,
                 ECS_SIZEOF(char), ECS_ALIGNOF(char));
             init_type(world, e, EcsPrimitiveType);
             break;
         case EcsByte:
-            init_component(world, e, 
+            init_component(world, e,
                 ECS_SIZEOF(bool), ECS_ALIGNOF(bool));
             init_type(world, e, EcsPrimitiveType);
             break;
         case EcsU8:
-            init_component(world, e, 
+            init_component(world, e,
                 ECS_SIZEOF(uint8_t), ECS_ALIGNOF(uint8_t));
             init_type(world, e, EcsPrimitiveType);
             break;
         case EcsU16:
-            init_component(world, e, 
+            init_component(world, e,
                 ECS_SIZEOF(uint16_t), ECS_ALIGNOF(uint16_t));
             init_type(world, e, EcsPrimitiveType);
             break;
         case EcsU32:
-            init_component(world, e, 
+            init_component(world, e,
                 ECS_SIZEOF(uint32_t), ECS_ALIGNOF(uint32_t));
             init_type(world, e, EcsPrimitiveType);
             break;
         case EcsU64:
-            init_component(world, e, 
+            init_component(world, e,
                 ECS_SIZEOF(uint64_t), ECS_ALIGNOF(uint64_t));
             init_type(world, e, EcsPrimitiveType);
             break;
         case EcsI8:
-            init_component(world, e, 
+            init_component(world, e,
                 ECS_SIZEOF(int8_t), ECS_ALIGNOF(int8_t));
             init_type(world, e, EcsPrimitiveType);
             break;
         case EcsI16:
-            init_component(world, e, 
+            init_component(world, e,
                 ECS_SIZEOF(int16_t), ECS_ALIGNOF(int16_t));
             init_type(world, e, EcsPrimitiveType);
             break;
         case EcsI32:
-            init_component(world, e, 
+            init_component(world, e,
                 ECS_SIZEOF(int32_t), ECS_ALIGNOF(int32_t));
             init_type(world, e, EcsPrimitiveType);
             break;
         case EcsI64:
-            init_component(world, e, 
+            init_component(world, e,
                 ECS_SIZEOF(int64_t), ECS_ALIGNOF(int64_t));
             init_type(world, e, EcsPrimitiveType);
             break;
         case EcsF32:
-            init_component(world, e, 
+            init_component(world, e,
                 ECS_SIZEOF(float), ECS_ALIGNOF(float));
             init_type(world, e, EcsPrimitiveType);
             break;
         case EcsF64:
-            init_component(world, e, 
+            init_component(world, e,
                 ECS_SIZEOF(double), ECS_ALIGNOF(double));
             init_type(world, e, EcsPrimitiveType);
             break;
         case EcsUPtr:
-            init_component(world, e, 
+            init_component(world, e,
                 ECS_SIZEOF(uintptr_t), ECS_ALIGNOF(uintptr_t));
             init_type(world, e, EcsPrimitiveType);
             break;
         case EcsIPtr:
-            init_component(world, e, 
+            init_component(world, e,
                 ECS_SIZEOF(intptr_t), ECS_ALIGNOF(intptr_t));
             init_type(world, e, EcsPrimitiveType);
             break;
         case EcsString:
-            init_component(world, e, 
+            init_component(world, e,
                 ECS_SIZEOF(char*), ECS_ALIGNOF(char*));
             init_type(world, e, EcsPrimitiveType);
             break;
         case EcsEntity:
-            init_component(world, e, 
+            init_component(world, e,
                 ECS_SIZEOF(ecs_entity_t), ECS_ALIGNOF(ecs_entity_t));
             init_type(world, e, EcsPrimitiveType);
             break;
@@ -21800,7 +21800,7 @@ void add_enum(ecs_iter_t *it) {
     int i, count = it->count;
     for (i = 0; i < count; i ++) {
         ecs_entity_t e = it->entities[i];
-        
+
         if (init_component(
             world, e, ECS_SIZEOF(ecs_i32_t), ECS_ALIGNOF(ecs_i32_t)))
         {
@@ -21820,7 +21820,7 @@ void add_bitmask(ecs_iter_t *it) {
     int i, count = it->count;
     for (i = 0; i < count; i ++) {
         ecs_entity_t e = it->entities[i];
-        
+
         if (init_component(
             world, e, ECS_SIZEOF(ecs_u32_t), ECS_ALIGNOF(ecs_u32_t)))
         {
@@ -21903,7 +21903,7 @@ void set_vector(ecs_iter_t *it) {
             continue;
         }
 
-        if (init_component(world, e, 
+        if (init_component(world, e,
             ECS_SIZEOF(ecs_vector_t*), ECS_ALIGNOF(ecs_vector_t*)))
         {
             continue;
@@ -21924,12 +21924,12 @@ void ecs_meta_type_init_default_ctor(ecs_iter_t *it) {
         ecs_entity_t type = it->entities[i];
 
         /* If component has no component actions (which is typical if a type is
-         * created with reflection data) make sure its values are always 
-         * initialized with zero. This prevents the injection of invalid data 
+         * created with reflection data) make sure its values are always
+         * initialized with zero. This prevents the injection of invalid data
          * through generic APIs after adding a component without setting it. */
         if (!ecs_component_has_actions(world, type)) {
-            ecs_set_component_actions_w_id(world, type, 
-                &(EcsComponentLifecycle){ 
+            ecs_set_component_actions_w_id(world, type,
+                &(EcsComponentLifecycle){
                     .ctor = ecs_default_ctor
                 });
         }
@@ -21965,33 +21965,33 @@ void FlecsMetaImport(
 
     ecs_set_component_actions(world, EcsMetaType, { .ctor = ecs_default_ctor });
 
-    ecs_set_component_actions(world, EcsMetaTypeSerialized, { 
+    ecs_set_component_actions(world, EcsMetaTypeSerialized, {
         .ctor = ecs_default_ctor,
         .move = ecs_move(EcsMetaTypeSerialized),
         .copy = ecs_copy(EcsMetaTypeSerialized),
         .dtor = ecs_dtor(EcsMetaTypeSerialized)
     });
 
-    ecs_set_component_actions(world, EcsStruct, { 
+    ecs_set_component_actions(world, EcsStruct, {
         .ctor = ecs_default_ctor,
         .move = ecs_move(EcsStruct),
         .copy = ecs_copy(EcsStruct),
         .dtor = ecs_dtor(EcsStruct)
     });
 
-    ecs_set_component_actions(world, EcsMember, { 
+    ecs_set_component_actions(world, EcsMember, {
         .ctor = ecs_default_ctor,
         .on_set = member_on_set
     });
 
-    ecs_set_component_actions(world, EcsEnum, { 
+    ecs_set_component_actions(world, EcsEnum, {
         .ctor = ecs_default_ctor,
         .move = ecs_move(EcsEnum),
         .copy = ecs_copy(EcsEnum),
         .dtor = ecs_dtor(EcsEnum)
     });
 
-    ecs_set_component_actions(world, EcsBitmask, { 
+    ecs_set_component_actions(world, EcsBitmask, {
         .ctor = ecs_default_ctor,
         .move = ecs_move(EcsBitmask),
         .copy = ecs_copy(EcsBitmask),
@@ -22100,16 +22100,16 @@ void FlecsMetaImport(
     #undef ECS_PRIMITIVE
 
     /* Set default child components */
-    ecs_add_pair(world, ecs_id(EcsStruct), 
+    ecs_add_pair(world, ecs_id(EcsStruct),
         EcsDefaultChildComponent, ecs_id(EcsMember));
 
-    ecs_add_pair(world, ecs_id(EcsMember), 
+    ecs_add_pair(world, ecs_id(EcsMember),
         EcsDefaultChildComponent, ecs_id(EcsMember));
 
-    ecs_add_pair(world, ecs_id(EcsEnum), 
+    ecs_add_pair(world, ecs_id(EcsEnum),
         EcsDefaultChildComponent, EcsConstant);
 
-    ecs_add_pair(world, ecs_id(EcsBitmask), 
+    ecs_add_pair(world, ecs_id(EcsBitmask),
         EcsDefaultChildComponent, EcsConstant);
 
     /* Initialize reflection data for meta components */
@@ -22135,22 +22135,22 @@ void FlecsMetaImport(
     ecs_entity_t primitive_kind = ecs_enum_init(world, &(ecs_enum_desc_t) {
         .entity.name = "PrimitiveKind",
         .constants = {
-            {.name = "Bool", 1}, 
-            {.name = "Char"}, 
-            {.name = "Byte"}, 
-            {.name = "U8"}, 
-            {.name = "U16"}, 
-            {.name = "U32"}, 
+            {.name = "Bool", 1},
+            {.name = "Char"},
+            {.name = "Byte"},
+            {.name = "U8"},
+            {.name = "U16"},
+            {.name = "U32"},
             {.name = "U64"},
-            {.name = "I8"}, 
-            {.name = "I16"}, 
-            {.name = "I32"}, 
-            {.name = "I64"}, 
-            {.name = "F32"}, 
-            {.name = "F64"}, 
+            {.name = "I8"},
+            {.name = "I16"},
+            {.name = "I32"},
+            {.name = "I64"},
+            {.name = "F32"},
+            {.name = "F64"},
             {.name = "UPtr"},
-            {.name = "IPtr"}, 
-            {.name = "String"}, 
+            {.name = "IPtr"},
+            {.name = "String"},
             {.name = "Entity"}
         }
     });
@@ -22193,7 +22193,7 @@ void FlecsMetaImport(
 
 static
 const char* op_kind_str(
-    ecs_meta_type_op_kind_t kind) 
+    ecs_meta_type_op_kind_t kind)
 {
     switch(kind) {
 
@@ -22291,7 +22291,7 @@ ecs_size_t get_alignment(
 static
 int32_t get_elem_count(
     ecs_meta_scope_t *scope)
-{    
+{
     if (scope->vector) {
         return ecs_vector_count(*(scope->vector));
     }
@@ -22387,7 +22387,7 @@ int ecs_meta_next(
             ecs_err("out of collection bounds (%d)", scope->elem_cur);
             return -1;
         }
-        
+
         return 0;
     }
 
@@ -22415,7 +22415,7 @@ int ecs_meta_member(
     const ecs_world_t *world = cursor->world;
 
     ecs_assert(push_op->kind == EcsOpPush, ECS_INTERNAL_ERROR, NULL);
-    
+
     if (!push_op->members) {
         ecs_err("cannot move to member '%s' for non-struct type", name);
         return -1;
@@ -22454,7 +22454,7 @@ int ecs_meta_push(
 
     void *ptr = get_ptr(world, scope);
     cursor->depth ++;
-    ecs_check(cursor->depth < ECS_META_MAX_SCOPE_DEPTH, 
+    ecs_check(cursor->depth < ECS_META_MAX_SCOPE_DEPTH,
         ECS_INVALID_PARAMETER, NULL);
 
     ecs_meta_scope_t *next_scope = get_scope(cursor);
@@ -22521,7 +22521,7 @@ int ecs_meta_push(
     }
 
     if (scope->is_collection) {
-        next_scope[0].ptr = ECS_OFFSET(next_scope[0].ptr, 
+        next_scope[0].ptr = ECS_OFFSET(next_scope[0].ptr,
             scope->elem_cur * get_size(world, scope));
     }
 
@@ -22735,9 +22735,9 @@ int ecs_meta_set_float(
 
 static
 int add_bitmask_constant(
-    ecs_meta_cursor_t *cursor, 
+    ecs_meta_cursor_t *cursor,
     ecs_meta_type_op_t *op,
-    void *out, 
+    void *out,
     const char *value)
 {
     ecs_assert(op->type != 0, ECS_INTERNAL_ERROR, NULL);
@@ -22770,9 +22770,9 @@ int add_bitmask_constant(
 
 static
 int parse_bitmask(
-    ecs_meta_cursor_t *cursor, 
+    ecs_meta_cursor_t *cursor,
     ecs_meta_type_op_t *op,
-    void *out, 
+    void *out,
     const char *value)
 {
     char token[ECS_MAX_TOKEN_SIZE];
@@ -22885,7 +22885,7 @@ int ecs_meta_set_string(
         if (ecs_os_strcmp(value, "0")) {
             if (cursor->lookup_action) {
                 e = cursor->lookup_action(
-                    cursor->world, value, 
+                    cursor->world, value,
                     cursor->lookup_ctx);
             } else {
                 e = ecs_lookup_path(cursor->world, 0, value);
@@ -22904,7 +22904,7 @@ int ecs_meta_set_string(
         ecs_err("excess element '%s' in scope", value);
         return -1;
     default:
-        ecs_err("unsupported conversion from string '%s' to '%s'", 
+        ecs_err("unsupported conversion from string '%s' to '%s'",
             value, op_kind_str(op->kind));
         return -1;
     }
@@ -22930,7 +22930,7 @@ int ecs_meta_set_string_literal(
     case EcsOpChar:
         set_T(ecs_char_t, ptr, value[1]);
         break;
-    
+
     default:
     case EcsOpEntity:
     case EcsOpString:
@@ -23001,8 +23001,8 @@ int ecs_meta_set_null(
 static
 int expr_ser_type(
     const ecs_world_t *world,
-    ecs_vector_t *ser, 
-    const void *base, 
+    ecs_vector_t *ser,
+    const void *base,
     ecs_strbuf_t *str);
 
 static
@@ -23010,13 +23010,13 @@ int expr_ser_type_ops(
     const ecs_world_t *world,
     ecs_meta_type_op_t *ops,
     int32_t op_count,
-    const void *base, 
+    const void *base,
     ecs_strbuf_t *str);
 
 static
 int expr_ser_type_op(
     const ecs_world_t *world,
-    ecs_meta_type_op_t *op, 
+    ecs_meta_type_op_t *op,
     const void *base,
     ecs_strbuf_t *str);
 
@@ -23030,8 +23030,8 @@ static
 int expr_ser_primitive(
     const ecs_world_t *world,
     ecs_primitive_kind_t kind,
-    const void *base, 
-    ecs_strbuf_t *str) 
+    const void *base,
+    ecs_strbuf_t *str)
 {
     const char *bool_str[] = { "false", "true" };
 
@@ -23136,15 +23136,15 @@ int expr_ser_primitive(
 static
 int expr_ser_enum(
     const ecs_world_t *world,
-    ecs_meta_type_op_t *op, 
-    const void *base, 
-    ecs_strbuf_t *str) 
+    ecs_meta_type_op_t *op,
+    const void *base,
+    ecs_strbuf_t *str)
 {
     const EcsEnum *enum_type = ecs_get(world, op->type, EcsEnum);
     ecs_check(enum_type != NULL, ECS_INVALID_PARAMETER, NULL);
 
     int32_t value = *(int32_t*)base;
-    
+
     /* Enumeration constants are stored in a map that is keyed on the
      * enumeration value. */
     ecs_enum_constant_t *constant = ecs_map_get(
@@ -23167,9 +23167,9 @@ error:
 static
 int expr_ser_bitmask(
     const ecs_world_t *world,
-    ecs_meta_type_op_t *op, 
-    const void *ptr, 
-    ecs_strbuf_t *str) 
+    ecs_meta_type_op_t *op,
+    const void *ptr,
+    ecs_strbuf_t *str)
 {
     const EcsBitmask *bitmask_type = ecs_get(world, op->type, EcsBitmask);
     ecs_check(bitmask_type != NULL, ECS_INVALID_PARAMETER, NULL);
@@ -23186,7 +23186,7 @@ int expr_ser_bitmask(
     ecs_map_iter_t it = ecs_map_iter(bitmask_type->constants);
     while ((constant = ecs_map_next(&it, ecs_bitmask_constant_t, &key))) {
         if ((value & key) == key) {
-            ecs_strbuf_list_appendstr(str, 
+            ecs_strbuf_list_appendstr(str,
                 ecs_get_name(world, constant->constant));
             count ++;
             value -= (uint32_t)key;
@@ -23197,7 +23197,7 @@ int expr_ser_bitmask(
         /* All bits must have been matched by a constant */
         char *path = ecs_get_fullpath(world, op->type);
         ecs_err(
-            "value for bitmask %s contains bits (%u) that cannot be mapped to constant", 
+            "value for bitmask %s contains bits (%u) that cannot be mapped to constant",
             path, value);
         ecs_os_free(path);
         goto error;
@@ -23218,10 +23218,10 @@ error:
 static
 int expr_ser_elements(
     const ecs_world_t *world,
-    ecs_meta_type_op_t *ops, 
+    ecs_meta_type_op_t *ops,
     int32_t op_count,
-    const void *base, 
-    int32_t elem_count, 
+    const void *base,
+    int32_t elem_count,
     int32_t elem_size,
     ecs_strbuf_t *str)
 {
@@ -23246,9 +23246,9 @@ int expr_ser_elements(
 static
 int expr_ser_type_elements(
     const ecs_world_t *world,
-    ecs_entity_t type, 
-    const void *base, 
-    int32_t elem_count, 
+    ecs_entity_t type,
+    const void *base,
+    int32_t elem_count,
     ecs_strbuf_t *str)
 {
     const EcsMetaTypeSerialized *ser = ecs_get(
@@ -23269,9 +23269,9 @@ int expr_ser_type_elements(
 static
 int expr_ser_array(
     const ecs_world_t *world,
-    ecs_meta_type_op_t *op, 
-    const void *ptr, 
-    ecs_strbuf_t *str) 
+    ecs_meta_type_op_t *op,
+    const void *ptr,
+    ecs_strbuf_t *str)
 {
     const EcsArray *a = ecs_get(world, op->type, EcsArray);
     ecs_assert(a != NULL, ECS_INTERNAL_ERROR, NULL);
@@ -23284,9 +23284,9 @@ int expr_ser_array(
 static
 int expr_ser_vector(
     const ecs_world_t *world,
-    ecs_meta_type_op_t *op, 
-    const void *base, 
-    ecs_strbuf_t *str) 
+    ecs_meta_type_op_t *op,
+    const void *base,
+    ecs_strbuf_t *str)
 {
     ecs_vector_t *value = *(ecs_vector_t**)base;
     if (!value) {
@@ -23311,9 +23311,9 @@ int expr_ser_vector(
 static
 int expr_ser_type_op(
     const ecs_world_t *world,
-    ecs_meta_type_op_t *op, 
+    ecs_meta_type_op_t *op,
     const void *ptr,
-    ecs_strbuf_t *str) 
+    ecs_strbuf_t *str)
 {
     switch(op->kind) {
     case EcsOpPush:
@@ -23342,8 +23342,8 @@ int expr_ser_type_op(
         }
         break;
     default:
-        if (expr_ser_primitive(world, expr_op_to_primitive_kind(op->kind), 
-            ECS_OFFSET(ptr, op->offset), str)) 
+        if (expr_ser_primitive(world, expr_op_to_primitive_kind(op->kind),
+            ECS_OFFSET(ptr, op->offset), str))
         {
             /* Unknown operation */
             ecs_err("unknown serializer operation kind (%d)", op->kind);
@@ -23364,7 +23364,7 @@ int expr_ser_type_ops(
     ecs_meta_type_op_t *ops,
     int32_t op_count,
     const void *base,
-    ecs_strbuf_t *str) 
+    ecs_strbuf_t *str)
 {
     for (int i = 0; i < op_count; i ++) {
         ecs_meta_type_op_t *op = &ops[i];
@@ -23388,7 +23388,7 @@ int expr_ser_type_ops(
                 continue;
             }
         }
-        
+
         switch(op->kind) {
         case EcsOpPush:
             ecs_strbuf_list_push(str, "{", ", ");
@@ -23414,8 +23414,8 @@ static
 int expr_ser_type(
     const ecs_world_t *world,
     ecs_vector_t *v_ops,
-    const void *base, 
-    ecs_strbuf_t *str) 
+    const void *base,
+    ecs_strbuf_t *str)
 {
     ecs_meta_type_op_t *ops = ecs_vector_first(v_ops, ecs_meta_type_op_t);
     int32_t count = ecs_vector_count(v_ops);
@@ -23447,8 +23447,8 @@ error:
 }
 
 char* ecs_ptr_to_expr(
-    const ecs_world_t *world, 
-    ecs_entity_t type, 
+    const ecs_world_t *world,
+    ecs_entity_t type,
     const void* ptr)
 {
     ecs_strbuf_t str = ECS_STRBUF_INIT;
@@ -23464,7 +23464,7 @@ char* ecs_ptr_to_expr(
 int ecs_primitive_to_expr_buf(
     const ecs_world_t *world,
     ecs_primitive_kind_t kind,
-    const void *base, 
+    const void *base,
     ecs_strbuf_t *str)
 {
     return expr_ser_primitive(world, kind, base, str);
@@ -23477,9 +23477,9 @@ int ecs_primitive_to_expr_buf(
 #ifdef FLECS_EXPR
 
 char* ecs_chresc(
-    char *out, 
-    char in, 
-    char delimiter) 
+    char *out,
+    char in,
+    char delimiter)
 {
     char *bptr = out;
     switch(in) {
@@ -23531,8 +23531,8 @@ char* ecs_chresc(
 }
 
 const char* ecs_chrparse(
-    const char *in, 
-    char *out) 
+    const char *in,
+    char *out)
 {
     const char *result = in + 1;
     char ch;
@@ -23594,17 +23594,17 @@ error:
 }
 
 ecs_size_t ecs_stresc(
-    char *out, 
-    ecs_size_t n, 
-    char delimiter, 
-    const char *in) 
+    char *out,
+    ecs_size_t n,
+    char delimiter,
+    const char *in)
 {
     const char *ptr = in;
     char ch, *bptr = out, buff[3];
     ecs_size_t written = 0;
     while ((ch = *ptr++)) {
         if ((written += (ecs_size_t)(ecs_chresc(
-            buff, ch, delimiter) - buff)) <= n) 
+            buff, ch, delimiter) - buff)) <= n)
         {
             /* If size != 0, an out buffer must be provided. */
             ecs_check(out != NULL, ECS_INVALID_PARAMETER, NULL);
@@ -23629,7 +23629,7 @@ error:
 }
 
 char* ecs_astresc(
-    char delimiter, 
+    char delimiter,
     const char *in)
 {
     if (!in) {
@@ -23713,7 +23713,7 @@ const char* ecs_parse_expr(
 
             if (ecs_meta_is_collection(&cur)) {
                 char *path = ecs_get_fullpath(world, scope_type);
-                ecs_parser_error(name, expr, ptr - expr, 
+                ecs_parser_error(name, expr, ptr - expr,
                     "expected '[' for collection type '%s'", path);
                 ecs_os_free(path);
                 return NULL;
@@ -23982,8 +23982,8 @@ void ecs_get_world_stats(
         if (entity_count == 1) {
             ecs_entity_t *entities = ecs_vector_first(
                 table->storage.entities, ecs_entity_t);
-            if (ecs_search_relation(world, table, 0, entities[0], EcsIsA, 
-                0, 0, 0, 0, 0) != -1) 
+            if (ecs_search_relation(world, table, 0, entities[0], EcsIsA,
+                0, 0, 0, 0, 0) != -1)
             {
                 singleton_table_count ++;
             }
@@ -23992,7 +23992,7 @@ void ecs_get_world_stats(
 
     record_gauge(&s->matched_table_count, t, matched_table_count);
     record_gauge(&s->matched_entity_count, t, matched_entity_count);
-    
+
     record_gauge(&s->table_count, t, count);
     record_gauge(&s->empty_table_count, t, empty_table_count);
     record_gauge(&s->singleton_table_count, t, singleton_table_count);
@@ -24016,7 +24016,7 @@ void ecs_get_query_stats(
     ecs_iter_t it = ecs_query_iter(world, (ecs_query_t*)query);
     record_gauge(&s->matched_entity_count, t, ecs_iter_count(&it));
     record_gauge(&s->matched_table_count, t, ecs_query_table_count(query));
-    record_gauge(&s->matched_empty_table_count, t, 
+    record_gauge(&s->matched_empty_table_count, t,
         ecs_query_empty_table_count(query));
 error:
     return;
@@ -24056,7 +24056,7 @@ error:
 
 #ifdef FLECS_PIPELINE
 
-static 
+static
 ecs_system_stats_t* get_system_stats(
     ecs_map_t *systems,
     ecs_entity_t system)
@@ -24102,7 +24102,7 @@ bool ecs_get_pipeline_stats(
     it = ecs_query_iter(stage, pq->build_query);
     while (ecs_query_next(&it)) {
         sys_count += it.count;
-    }   
+    }
 
     /* Also count synchronization points */
     ecs_vector_t *ops = pq->ops;
@@ -24132,7 +24132,7 @@ bool ecs_get_pipeline_stats(
 
         /* Populate systems vector, keep track of sync points */
         it = ecs_query_iter(stage, pq->query);
-        
+
         int32_t i, i_system = 0, ran_since_merge = 0;
         while (ecs_query_next(&it)) {
             for (i = 0; i < it.count; i ++) {
@@ -24188,8 +24188,8 @@ void ecs_dump_world_stats(
     ecs_check(world != NULL, ECS_INVALID_PARAMETER, NULL);
     ecs_check(s != NULL, ECS_INVALID_PARAMETER, NULL);
 
-    world = ecs_get_world(world);    
-    
+    world = ecs_get_world(world);
+
     print_counter("Frame", t, &s->frame_count_total);
     printf("-------------------------------------\n");
     print_counter("pipeline rebuilds", t, &s->pipeline_build_count_total);
@@ -24221,7 +24221,7 @@ void ecs_dump_world_stats(
     print_counter("deferred set operations", t, &s->set_count);
     print_counter("discarded operations", t, &s->discard_count);
     printf("\n");
-    
+
 error:
     return;
 }
@@ -24292,15 +24292,15 @@ ecs_data_t* duplicate_data(
             ecs_vector_set_count_t(&dst_vec, size, alignment, count);
             void *dst_ptr = ecs_vector_first_t(dst_vec, size, alignment);
             void *ctx = cdata->lifecycle.ctx;
-            
+
             ecs_xtor_t ctor = cdata->lifecycle.ctor;
             if (ctor) {
-                ctor((ecs_world_t*)world, component, entities, dst_ptr, 
+                ctor((ecs_world_t*)world, component, entities, dst_ptr,
                     flecs_itosize(size), count, ctx);
             }
 
             void *src_ptr = ecs_vector_first_t(column->data, size, alignment);
-            copy((ecs_world_t*)world, component, entities, entities, dst_ptr, 
+            copy((ecs_world_t*)world, component, entities, entities, dst_ptr,
                 src_ptr, flecs_itosize(size), count, ctx);
 
             column->data = dst_vec;
@@ -24325,7 +24325,7 @@ void snapshot_table(
     ecs_table_leaf_t *l = ecs_vector_get(
         snapshot->tables, ecs_table_leaf_t, (int32_t)table->id);
     ecs_assert(l != NULL, ECS_INTERNAL_ERROR, NULL);
-    
+
     l->table = table;
     l->type = ecs_vector_copy(table->type, ecs_id_t);
     l->data = duplicate_data(world, table, &table->storage);
@@ -24424,7 +24424,7 @@ void restore_unfiltered(
 {
     flecs_sparse_restore(world->store.entity_index, snapshot->entity_index);
     flecs_sparse_free(snapshot->entity_index);
-    
+
     world->stats.last_id = snapshot->last_id;
 
     ecs_table_leaf_t *leafs = ecs_vector_first(
@@ -24462,7 +24462,7 @@ void restore_unfiltered(
             if (snapshot_table->data) {
                 flecs_table_replace_data(world, table, snapshot_table->data);
             }
-        
+
         /* If the world table still exists, replace its data */
         } else if (world_table && snapshot_table) {
             if (snapshot_table->data) {
@@ -24473,7 +24473,7 @@ void restore_unfiltered(
                     world, world_table, &world_table->storage);
                 flecs_table_init_data(world, world_table);
             }
-        
+
         /* If the snapshot table doesn't exist, this table was created after the
          * snapshot was taken and needs to be deleted */
         } else if (world_table && !snapshot_table) {
@@ -24485,7 +24485,7 @@ void restore_unfiltered(
              * the table. */
             flecs_table_clear_data(world, world_table, &world_table->storage);
             flecs_delete_table(world, world_table);
-        
+
         /* If there is no world & snapshot table, nothing needs to be done */
         } else { }
 
@@ -24546,7 +24546,7 @@ void restore_filtered(
             ecs_entity_t e = entities[i];
             ecs_record_t *r = ecs_eis_get(world, e);
             if (r && r->table) {
-                flecs_table_delete(world, r->table, &r->table->storage, 
+                flecs_table_delete(world, r->table, &r->table->storage,
                     ECS_RECORD_TO_ROW(r->row), true);
             } else {
                 /* Make sure that the entity has the same generation count */
@@ -24585,7 +24585,7 @@ void ecs_snapshot_restore(
         restore_filtered(world, snapshot);
     }
 
-    ecs_vector_free(snapshot->tables);   
+    ecs_vector_free(snapshot->tables);
 
     ecs_os_free(snapshot);
 }
@@ -24632,7 +24632,7 @@ bool ecs_snapshot_next(
 
         it->is_valid = true;
         iter->index = i + 1;
-        
+
         goto yield;
     }
 
@@ -24641,7 +24641,7 @@ bool ecs_snapshot_next(
 
 yield:
     it->is_valid = true;
-    return true;    
+    return true;
 }
 
 /** Cleanup snapshot */
@@ -24663,7 +24663,7 @@ void ecs_snapshot_free(
             }
             ecs_vector_free(snapshot_table->type);
         }
-    }    
+    }
 
     ecs_vector_free(snapshot->tables);
     ecs_os_free(snapshot);
@@ -24701,7 +24701,7 @@ void ecs_system_activate(
         /* If activating system, ensure that it doesn't have the Inactive tag.
          * Systems are implicitly activated so they are kept out of the main
          * loop as long as they aren't used. They are not implicitly deactivated
-         * to prevent overhead in case of oscillating app behavior. 
+         * to prevent overhead in case of oscillating app behavior.
          * After activation, systems that aren't matched with anything can be
          * deactivated again by explicitly calling ecs_deactivate_systems.
          */
@@ -24722,15 +24722,15 @@ void ecs_system_activate(
                  * any active tables, there is nothing to deactivate. */
                 return;
             }
-        }            
+        }
     }
 
     /* Invoke system status action */
-    invoke_status_action(world, system, system_data, 
+    invoke_status_action(world, system, system_data,
         activate ? EcsSystemActivated : EcsSystemDeactivated);
 
-    ecs_dbg_1("#[green]system#[reset] %s %s", 
-        ecs_get_name(world, system), 
+    ecs_dbg_1("#[green]system#[reset] %s %s",
+        ecs_get_name(world, system),
         activate ? "activated" : "deactivated");
 }
 
@@ -24755,7 +24755,7 @@ void ecs_enable_system(
         ecs_system_activate(world, system, enabled, system_data);
         system_data = ecs_get_mut(world, system, EcsSystem, NULL);
     }
-    
+
     /* Invoke action for enable/disable status */
     invoke_status_action(
         world, system, system_data,
@@ -24770,11 +24770,11 @@ ecs_entity_t ecs_run_intern(
     ecs_entity_t system,
     EcsSystem *system_data,
     int32_t stage_current,
-    int32_t stage_count,    
+    int32_t stage_count,
     FLECS_FLOAT delta_time,
     int32_t offset,
     int32_t limit,
-    void *param) 
+    void *param)
 {
     FLECS_FLOAT time_elapsed = delta_time;
     ecs_entity_t tick_source = system_data->tick_source;
@@ -24880,7 +24880,7 @@ ecs_entity_t ecs_run_w_filter(
         world, system, EcsSystem);
     assert(system_data != NULL);
 
-    return ecs_run_intern(world, stage, system, system_data, 0, 0, delta_time, 
+    return ecs_run_intern(world, stage, system, system_data, 0, 0, delta_time,
         offset, limit, param);
 }
 
@@ -24899,7 +24899,7 @@ ecs_entity_t ecs_run_worker(
     assert(system_data != NULL);
 
     return ecs_run_intern(
-        world, stage, system, system_data, stage_current, stage_count, 
+        world, stage, system, system_data, stage_current, stage_count,
         delta_time, 0, 0, param);
 }
 
@@ -24938,7 +24938,7 @@ void* ecs_get_system_ctx(
         return s->ctx;
     } else {
         return NULL;
-    }   
+    }
 }
 
 void* ecs_get_system_binding_ctx(
@@ -24950,7 +24950,7 @@ void* ecs_get_system_binding_ctx(
         return s->binding_ctx;
     } else {
         return NULL;
-    }   
+    }
 }
 
 /* Generic constructor to initialize a component to 0 */
@@ -25020,7 +25020,7 @@ void ecs_colsystem_dtor(
 
         if (system->binding_ctx_free) {
             system->binding_ctx_free(system->binding_ctx);
-        }  
+        }
 
         if (system->query) {
             ecs_query_fini(system->query);
@@ -25116,8 +25116,8 @@ ecs_entity_t ecs_system_init(
         }
 
         if (!ecs_has_id(world, result, EcsDisabled)) {
-            /* If system is already enabled, generate enable status. The API 
-            * should guarantee that it exactly matches enable-disable 
+            /* If system is already enabled, generate enable status. The API
+            * should guarantee that it exactly matches enable-disable
             * notifications and activate-deactivate notifications. */
             invoke_status_action(world, result, system, EcsSystemEnabled);
 
@@ -25147,11 +25147,11 @@ ecs_entity_t ecs_system_init(
         ecs_modified(world, result, EcsSystem);
 
         if (desc->entity.name) {
-            ecs_trace("#[green]system#[reset] %s created", 
+            ecs_trace("#[green]system#[reset] %s created",
                 ecs_get_name(world, result));
         }
 
-        ecs_defer_end(world);            
+        ecs_defer_end(world);
     } else {
         const char *expr_desc = desc->query.filter.expr;
         const char *expr_sys = system->query->filter.expr;
@@ -25225,7 +25225,7 @@ void FlecsSystemImport(
     ecs_set_scope(world, old_scope);
 
     /* Bootstrap ctor and dtor for EcsSystem */
-    ecs_set_component_actions_w_id(world, ecs_id(EcsSystem), 
+    ecs_set_component_actions_w_id(world, ecs_id(EcsSystem),
         &(EcsComponentLifecycle) {
             .ctor = sys_ctor_init_zero,
             .dtor = ecs_colsystem_dtor
@@ -25397,7 +25397,7 @@ void json_id(
 }
 
 ecs_primitive_kind_t json_op_to_primitive_kind(
-    ecs_meta_type_op_kind_t kind) 
+    ecs_meta_type_op_kind_t kind)
 {
     return kind - EcsOpPrimitive;
 }
@@ -25411,8 +25411,8 @@ ecs_primitive_kind_t json_op_to_primitive_kind(
 static
 int json_ser_type(
     const ecs_world_t *world,
-    ecs_vector_t *ser, 
-    const void *base, 
+    ecs_vector_t *ser,
+    const void *base,
     ecs_strbuf_t *str);
 
 static
@@ -25420,13 +25420,13 @@ int json_ser_type_ops(
     const ecs_world_t *world,
     ecs_meta_type_op_t *ops,
     int32_t op_count,
-    const void *base, 
+    const void *base,
     ecs_strbuf_t *str);
 
 static
 int json_ser_type_op(
     const ecs_world_t *world,
-    ecs_meta_type_op_t *op, 
+    ecs_meta_type_op_t *op,
     const void *base,
     ecs_strbuf_t *str);
 
@@ -25434,15 +25434,15 @@ int json_ser_type_op(
 static
 int json_ser_enum(
     const ecs_world_t *world,
-    ecs_meta_type_op_t *op, 
-    const void *base, 
-    ecs_strbuf_t *str) 
+    ecs_meta_type_op_t *op,
+    const void *base,
+    ecs_strbuf_t *str)
 {
     const EcsEnum *enum_type = ecs_get(world, op->type, EcsEnum);
     ecs_check(enum_type != NULL, ECS_INVALID_PARAMETER, NULL);
 
     int32_t value = *(int32_t*)base;
-    
+
     /* Enumeration constants are stored in a map that is keyed on the
      * enumeration value. */
     ecs_enum_constant_t *constant = ecs_map_get(
@@ -25464,9 +25464,9 @@ error:
 static
 int json_ser_bitmask(
     const ecs_world_t *world,
-    ecs_meta_type_op_t *op, 
-    const void *ptr, 
-    ecs_strbuf_t *str) 
+    ecs_meta_type_op_t *op,
+    const void *ptr,
+    ecs_strbuf_t *str)
 {
     const EcsBitmask *bitmask_type = ecs_get(world, op->type, EcsBitmask);
     ecs_check(bitmask_type != NULL, ECS_INVALID_PARAMETER, NULL);
@@ -25487,7 +25487,7 @@ int json_ser_bitmask(
     ecs_map_iter_t it = ecs_map_iter(bitmask_type->constants);
     while ((constant = ecs_map_next(&it, ecs_bitmask_constant_t, &key))) {
         if ((value & key) == key) {
-            ecs_strbuf_list_appendstr(str, 
+            ecs_strbuf_list_appendstr(str,
                 ecs_get_name(world, constant->constant));
             value -= (uint32_t)key;
         }
@@ -25509,10 +25509,10 @@ error:
 static
 int json_ser_elements(
     const ecs_world_t *world,
-    ecs_meta_type_op_t *ops, 
+    ecs_meta_type_op_t *ops,
     int32_t op_count,
-    const void *base, 
-    int32_t elem_count, 
+    const void *base,
+    int32_t elem_count,
     int32_t elem_size,
     ecs_strbuf_t *str)
 {
@@ -25537,9 +25537,9 @@ int json_ser_elements(
 static
 int json_ser_type_elements(
     const ecs_world_t *world,
-    ecs_entity_t type, 
-    const void *base, 
-    int32_t elem_count, 
+    ecs_entity_t type,
+    const void *base,
+    int32_t elem_count,
     ecs_strbuf_t *str)
 {
     const EcsMetaTypeSerialized *ser = ecs_get(
@@ -25560,9 +25560,9 @@ int json_ser_type_elements(
 static
 int json_ser_array(
     const ecs_world_t *world,
-    ecs_meta_type_op_t *op, 
-    const void *ptr, 
-    ecs_strbuf_t *str) 
+    ecs_meta_type_op_t *op,
+    const void *ptr,
+    ecs_strbuf_t *str)
 {
     const EcsArray *a = ecs_get(world, op->type, EcsArray);
     ecs_assert(a != NULL, ECS_INTERNAL_ERROR, NULL);
@@ -25575,9 +25575,9 @@ int json_ser_array(
 static
 int json_ser_vector(
     const ecs_world_t *world,
-    ecs_meta_type_op_t *op, 
-    const void *base, 
-    ecs_strbuf_t *str) 
+    ecs_meta_type_op_t *op,
+    const void *base,
+    ecs_strbuf_t *str)
 {
     ecs_vector_t *value = *(ecs_vector_t**)base;
     if (!value) {
@@ -25602,9 +25602,9 @@ int json_ser_vector(
 static
 int json_ser_type_op(
     const ecs_world_t *world,
-    ecs_meta_type_op_t *op, 
+    ecs_meta_type_op_t *op,
     const void *ptr,
-    ecs_strbuf_t *str) 
+    ecs_strbuf_t *str)
 {
     switch(op->kind) {
     case EcsOpPush:
@@ -25646,9 +25646,9 @@ int json_ser_type_op(
     }
 
     default:
-        if (ecs_primitive_to_expr_buf(world, 
-            json_op_to_primitive_kind(op->kind), 
-            ECS_OFFSET(ptr, op->offset), str)) 
+        if (ecs_primitive_to_expr_buf(world,
+            json_op_to_primitive_kind(op->kind),
+            ECS_OFFSET(ptr, op->offset), str))
         {
             /* Unknown operation */
             ecs_throw(ECS_INTERNAL_ERROR, NULL);
@@ -25669,7 +25669,7 @@ int json_ser_type_ops(
     ecs_meta_type_op_t *ops,
     int32_t op_count,
     const void *base,
-    ecs_strbuf_t *str) 
+    ecs_strbuf_t *str)
 {
     for (int i = 0; i < op_count; i ++) {
         ecs_meta_type_op_t *op = &ops[i];
@@ -25692,7 +25692,7 @@ int json_ser_type_ops(
                 continue;
             }
         }
-        
+
         switch(op->kind) {
         case EcsOpPush:
             json_object_push(str);
@@ -25718,8 +25718,8 @@ static
 int json_ser_type(
     const ecs_world_t *world,
     ecs_vector_t *v_ops,
-    const void *base, 
-    ecs_strbuf_t *str) 
+    const void *base,
+    ecs_strbuf_t *str)
 {
     ecs_meta_type_op_t *ops = ecs_vector_first(v_ops, ecs_meta_type_op_t);
     int32_t count = ecs_vector_count(v_ops);
@@ -25787,8 +25787,8 @@ int ecs_array_to_json_buf(
 }
 
 char* ecs_array_to_json(
-    const ecs_world_t *world, 
-    ecs_entity_t type, 
+    const ecs_world_t *world,
+    ecs_entity_t type,
     const void* ptr,
     int32_t count)
 {
@@ -25812,8 +25812,8 @@ int ecs_ptr_to_json_buf(
 }
 
 char* ecs_ptr_to_json(
-    const ecs_world_t *world, 
-    ecs_entity_t type, 
+    const ecs_world_t *world,
+    ecs_entity_t type,
     const void* ptr)
 {
     return ecs_array_to_json(world, type, ptr, 0);
@@ -25821,11 +25821,11 @@ char* ecs_ptr_to_json(
 
 static
 int append_type(
-    const ecs_world_t *world, 
-    ecs_strbuf_t *buf, 
-    ecs_entity_t ent, 
+    const ecs_world_t *world,
+    ecs_strbuf_t *buf,
+    ecs_entity_t ent,
     ecs_entity_t inst,
-    const ecs_entity_to_json_desc_t *desc) 
+    const ecs_entity_to_json_desc_t *desc)
 {
     ecs_type_t type = ecs_get_type(world, ent);
     ecs_id_t *ids = ecs_vector_first(type, ecs_id_t);
@@ -25874,12 +25874,12 @@ int append_type(
         }
         if (obj) {
             char *str = ecs_get_fullpath(world, obj);
-            json_member(buf, "obj"); 
+            json_member(buf, "obj");
             json_string(buf, str);
             ecs_os_free(str);
         }
         if (role) {
-            json_member(buf, "obj"); 
+            json_member(buf, "obj");
             json_string(buf, ecs_role_str(role));
         }
 
@@ -25910,7 +25910,7 @@ int append_type(
                         if (desc && desc->serialize_type_info) {
                             json_member(buf, "type_info");
                             if (ecs_type_info_to_json_buf(
-                                world, typeid, buf) != 0) 
+                                world, typeid, buf) != 0)
                             {
                                 return -1;
                             }
@@ -25924,17 +25924,17 @@ int append_type(
     }
 
     json_array_pop(buf);
-    
+
     return 0;
 }
 
 static
 int append_base(
-    const ecs_world_t *world, 
-    ecs_strbuf_t *buf, 
-    ecs_entity_t ent, 
+    const ecs_world_t *world,
+    ecs_strbuf_t *buf,
+    ecs_entity_t ent,
     ecs_entity_t inst,
-    const ecs_entity_to_json_desc_t *desc) 
+    const ecs_entity_to_json_desc_t *desc)
 {
     ecs_type_t type = ecs_get_type(world, ent);
     ecs_id_t *ids = ecs_vector_first(type, ecs_id_t);
@@ -25943,7 +25943,7 @@ int append_base(
     for (i = 0; i < count; i ++) {
         ecs_id_t id = ids[i];
         if (ECS_HAS_RELATION(id, EcsIsA)) {
-            if (append_base(world, buf, ecs_pair_object(world, id), inst, desc)) 
+            if (append_base(world, buf, ecs_pair_object(world, id), inst, desc))
             {
                 return -1;
             }
@@ -25997,7 +25997,7 @@ int ecs_entity_to_json_buf(
                 ecs_id_t id = ids[i];
                 if (ECS_HAS_RELATION(id, EcsIsA)) {
                     if (append_base(
-                        world, buf, ecs_pair_object(world, id), entity, desc)) 
+                        world, buf, ecs_pair_object(world, id), entity, desc))
                     {
                         return -1;
                     }
@@ -26049,7 +26049,7 @@ static
 void serialize_id(
     const ecs_world_t *world,
     ecs_id_t id,
-    ecs_strbuf_t *buf) 
+    ecs_strbuf_t *buf)
 {
     json_id(buf, world, id);
 }
@@ -26057,8 +26057,8 @@ void serialize_id(
 static
 void serialize_iter_ids(
     const ecs_world_t *world,
-    const ecs_iter_t *it, 
-    ecs_strbuf_t *buf) 
+    const ecs_iter_t *it,
+    ecs_strbuf_t *buf)
 {
     int32_t term_count = it->term_count;
     if (!term_count) {
@@ -26079,8 +26079,8 @@ void serialize_iter_ids(
 static
 void serialize_type_info(
     const ecs_world_t *world,
-    const ecs_iter_t *it, 
-    ecs_strbuf_t *buf) 
+    const ecs_iter_t *it,
+    ecs_strbuf_t *buf)
 {
     int32_t term_count = it->term_count;
     if (!term_count) {
@@ -26161,7 +26161,7 @@ void serialize_iter_result_subjects(
     for (int i = 0; i < it->term_count; i ++) {
         json_next(buf);
         ecs_entity_t subj = it->subjects[i];
-        if (subj) {            
+        if (subj) {
             json_path(buf, world, subj);
         } else {
             json_literal(buf, "0");
@@ -26195,7 +26195,7 @@ static
 void serialize_iter_result_variables(
     const ecs_world_t *world,
     const ecs_iter_t *it,
-    ecs_strbuf_t *buf) 
+    ecs_strbuf_t *buf)
 {
     char **variable_names = it->variable_names;
     ecs_entity_t *variables = it->variables;
@@ -26225,7 +26225,7 @@ static
 void serialize_iter_result_entities(
     const ecs_world_t *world,
     const ecs_iter_t *it,
-    ecs_strbuf_t *buf) 
+    ecs_strbuf_t *buf)
 {
     int32_t count = it->count;
     if (!it->count) {
@@ -26249,7 +26249,7 @@ static
 void serialize_iter_result_values(
     const ecs_world_t *world,
     const ecs_iter_t *it,
-    ecs_strbuf_t *buf) 
+    ecs_strbuf_t *buf)
 {
     int32_t count = it->count;
     if (!it->count) {
@@ -26262,7 +26262,7 @@ void serialize_iter_result_values(
     int32_t i, term_count = it->term_count;
     for (i = 0; i < term_count; i ++) {
         ecs_strbuf_list_next(buf);
-        
+
         const void *ptr = it->ptrs[i];
         if (!ptr) {
             /* No data in column */
@@ -26306,10 +26306,10 @@ void serialize_iter_result_values(
 
 static
 void serialize_iter_result(
-    const ecs_world_t *world, 
-    const ecs_iter_t *it, 
+    const ecs_world_t *world,
+    const ecs_iter_t *it,
     ecs_strbuf_t *buf,
-    const ecs_iter_to_json_desc_t *desc) 
+    const ecs_iter_to_json_desc_t *desc)
 {
     json_next(buf);
     json_object_push(buf);
@@ -26428,7 +26428,7 @@ int json_typeinfo_ser_type(
 static
 int json_typeinfo_ser_primitive(
     ecs_primitive_kind_t kind,
-    ecs_strbuf_t *str) 
+    ecs_strbuf_t *str)
 {
     json_array_push(str);
 
@@ -26575,8 +26575,8 @@ error:
 static
 int json_typeinfo_ser_type_op(
     const ecs_world_t *world,
-    ecs_meta_type_op_t *op, 
-    ecs_strbuf_t *str) 
+    ecs_meta_type_op_t *op,
+    ecs_strbuf_t *str)
 {
     switch(op->kind) {
     case EcsOpPush:
@@ -26597,7 +26597,7 @@ int json_typeinfo_ser_type_op(
         json_typeinfo_ser_vector(world, op->type, str);
         break;
     default:
-        if (json_typeinfo_ser_primitive( 
+        if (json_typeinfo_ser_primitive(
             json_op_to_primitive_kind(op->kind), str))
         {
             /* Unknown operation */
@@ -26618,7 +26618,7 @@ int json_typeinfo_ser_type_ops(
     const ecs_world_t *world,
     ecs_meta_type_op_t *ops,
     int32_t op_count,
-    ecs_strbuf_t *str) 
+    ecs_strbuf_t *str)
 {
     for (int i = 0; i < op_count; i ++) {
         ecs_meta_type_op_t *op = &ops[i];
@@ -26635,7 +26635,7 @@ int json_typeinfo_ser_type_ops(
                 continue;
             }
         }
-        
+
         switch(op->kind) {
         case EcsOpPush:
             json_object_push(str);
@@ -26869,7 +26869,7 @@ static ECS_MOVE(EcsRest, dst, src, {
     src->impl = NULL;
 })
 
-static ECS_DTOR(EcsRest, ptr, { 
+static ECS_DTOR(EcsRest, ptr, {
     ecs_rest_ctx_t *impl = ptr->impl;
     if (impl) {
         impl->rc --;
@@ -26883,11 +26883,11 @@ static ECS_DTOR(EcsRest, ptr, {
 
 static char *rest_last_err;
 
-static 
+static
 void rest_capture_log(
-    int32_t level, 
-    const char *file, 
-    int32_t line, 
+    int32_t level,
+    const char *file,
+    int32_t line,
     const char *msg)
 {
     (void)file; (void)line;
@@ -26989,7 +26989,7 @@ bool rest_reply(
 
             ecs_entity_to_json_buf(world, e, &reply->body, &desc);
             return true;
-        
+
         /* Query endpoint */
         } else if (!ecs_os_strcmp(req->path, "query")) {
             const char *q = ecs_http_get_param(req, "q");
@@ -27016,7 +27016,7 @@ bool rest_reply(
             } else {
                 ecs_iter_to_json_desc_t desc = ECS_ITER_TO_JSON_INIT;
                 rest_parse_json_ser_iter_params(&desc, req);
-                
+
                 ecs_iter_t it = ecs_rule_iter(world, r);
                 ecs_iter_to_json_buf(world, &it, &reply->body, &desc);
                 ecs_rule_fini(r);
@@ -27053,7 +27053,7 @@ void on_set_rest(ecs_iter_t *it)
 
         if (!srv) {
             const char *ipaddr = rest[i].ipaddr ? rest[i].ipaddr : "0.0.0.0";
-            ecs_err("failed to create REST server on %s:%u", 
+            ecs_err("failed to create REST server on %s:%u",
                 ipaddr, rest[i].port);
             ecs_os_free(srv_ctx);
             continue;
@@ -27086,7 +27086,7 @@ void DequeueRest(ecs_iter_t *it) {
         if (ctx) {
             ecs_http_server_dequeue(ctx->srv, it->delta_time);
         }
-    } 
+    }
 }
 
 void FlecsRestImport(
@@ -27098,7 +27098,7 @@ void FlecsRestImport(
 
     flecs_bootstrap_component(world, EcsRest);
 
-    ecs_set_component_actions(world, EcsRest, { 
+    ecs_set_component_actions(world, EcsRest, {
         .ctor = ecs_default_ctor,
         .move = ecs_move(EcsRest),
         .copy = ecs_copy(EcsRest),
@@ -27119,7 +27119,7 @@ void FlecsRestImport(
 
 void FlecsCoreDocImport(
     ecs_world_t *world)
-{    
+{
     ECS_MODULE(world, FlecsCoreDoc);
 
     ECS_IMPORT(world, FlecsMeta);
@@ -27199,8 +27199,8 @@ void FlecsCoreDocImport(
     ecs_doc_set_link(world, EcsDelete, URL_ROOT "#relation-cleanup-properties");
     ecs_doc_set_link(world, EcsThrow, URL_ROOT "#relation-cleanup-properties");
     ecs_doc_set_link(world, EcsIsA, URL_ROOT "#the-isa-relation");
-    ecs_doc_set_link(world, EcsChildOf, URL_ROOT "#the-childof-relation"); 
-    
+    ecs_doc_set_link(world, EcsChildOf, URL_ROOT "#the-childof-relation");
+
     /* Initialize documentation for meta components */
     ecs_entity_t meta = ecs_lookup_fullpath(world, "flecs.meta");
     ecs_doc_set_brief(world, meta, "Flecs module with reflection components");
@@ -27250,31 +27250,31 @@ void FlecsCoreDocImport(
  * for receiving/replying to simple HTTP requests, and has been modified to use
  * the Flecs OS API. */
 
-/* EmbeddableWebServer Copyright (c) 2016, 2019, 2020 Forrest Heller, and 
+/* EmbeddableWebServer Copyright (c) 2016, 2019, 2020 Forrest Heller, and
  * CONTRIBUTORS (see below) - All rights reserved.
  *
  * CONTRIBUTORS:
  * Martin Pulec - bug fixes, warning fixes, IPv6 support
  * Daniel Barry - bug fix (ifa_addr != NULL)
- * 
+ *
  * Released under the BSD 2-clause license:
- * Redistribution and use in source and binary forms, with or without 
+ * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
- * 1. Redistributions of source code must retain the above copyright notice, 
+ * 1. Redistributions of source code must retain the above copyright notice,
  * this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright notice, 
- * this list of conditions and the following disclaimer in the documentation 
- * and/or other materials provided with the distribution. THIS SOFTWARE IS 
- * PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS 
- * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN 
- * NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY 
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution. THIS SOFTWARE IS
+ * PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 
@@ -27300,7 +27300,7 @@ typedef int ecs_http_socket_t;
 #endif
 
 /* Max length of request method */
-#define ECS_HTTP_METHOD_LEN_MAX (8) 
+#define ECS_HTTP_METHOD_LEN_MAX (8)
 
 /* Timeout (s) before connection purge */
 #define ECS_HTTP_CONNECTION_PURGE_TIMEOUT (1.0)
@@ -27392,9 +27392,9 @@ typedef struct {
 
 static
 ecs_size_t http_send(
-    ecs_http_socket_t sock, 
-    const void *buf, 
-    ecs_size_t size, 
+    ecs_http_socket_t sock,
+    const void *buf,
+    ecs_size_t size,
     int flags)
 {
 #ifndef ECS_TARGET_MSVC
@@ -27443,7 +27443,7 @@ int http_getnameinfo(
     ecs_assert(addr_len > 0, ECS_INTERNAL_ERROR, NULL);
     ecs_assert(host_len > 0, ECS_INTERNAL_ERROR, NULL);
     ecs_assert(port_len > 0, ECS_INTERNAL_ERROR, NULL);
-    return getnameinfo(addr, (uint32_t)addr_len, host, (uint32_t)host_len, 
+    return getnameinfo(addr, (uint32_t)addr_len, host, (uint32_t)host_len,
         port, (uint32_t)port_len, flags);
 }
 
@@ -27481,7 +27481,7 @@ ecs_http_socket_t http_accept(
     return result;
 }
 
-static 
+static
 void reply_free(ecs_http_reply_t* response) {
     ecs_os_free(response->body.content);
 }
@@ -27510,7 +27510,7 @@ char hex_2_int(char a, char b){
 
 static
 void decode_url_str(
-    char *str) 
+    char *str)
 {
     char ch, *ptr, *dst = str;
     for (ptr = str; (ch = *ptr); ptr++) {
@@ -27562,8 +27562,8 @@ void header_buf_append(
     ecs_http_fragment_t *frag,
     char ch)
 {
-    if ((frag->header_buf_ptr - frag->header_buf) < 
-        ECS_SIZEOF(frag->header_buf)) 
+    if ((frag->header_buf_ptr - frag->header_buf) <
+        ECS_SIZEOF(frag->header_buf))
     {
         frag->header_buf_ptr[0] = ch;
         frag->header_buf_ptr ++;
@@ -27618,8 +27618,8 @@ void enqueue_request(
 static
 bool parse_request(
     ecs_http_connection_impl_t *conn,
-    const char* req_frag, 
-    ecs_size_t req_frag_len) 
+    const char* req_frag,
+    ecs_size_t req_frag_len)
 {
     ecs_http_fragment_t *frag = &conn->frag;
 
@@ -27668,7 +27668,7 @@ bool parse_request(
             break;
         case HttpFragStateHeaderStart:
             if (header_writable(frag)) {
-                frag->header_offsets[frag->header_count] = 
+                frag->header_offsets[frag->header_count] =
                     ecs_strbuf_written(&frag->buf);
             }
             header_buf_reset(frag);
@@ -27762,8 +27762,8 @@ bool parse_request(
             break;
         case HttpFragStateBody: {
                 ecs_strbuf_appendch(&frag->buf, c);
-                if ((ecs_strbuf_written(&frag->buf) - frag->body_offset) == 
-                    frag->content_length) 
+                if ((ecs_strbuf_written(&frag->buf) - frag->body_offset) ==
+                    frag->content_length)
                 {
                     frag->state = HttpFragStateDone;
                 }
@@ -27786,11 +27786,11 @@ bool parse_request(
 static
 void append_send_headers(
     ecs_strbuf_t *hdrs,
-    int code, 
-    const char* status, 
-    const char* content_type,  
+    int code,
+    const char* status,
+    const char* content_type,
     ecs_strbuf_t *extra_headers,
-    ecs_size_t content_len) 
+    ecs_size_t content_len)
 {
     ecs_strbuf_appendstr(hdrs, "HTTP/1.1 ");
     ecs_strbuf_append(hdrs, "%d ", code);
@@ -27814,8 +27814,8 @@ void append_send_headers(
 
 static
 void send_reply(
-    ecs_http_connection_impl_t* conn, 
-    ecs_http_reply_t* reply) 
+    ecs_http_connection_impl_t* conn,
+    ecs_http_reply_t* reply)
 {
     char hdrs[ECS_HTTP_REPLY_HEADER_SIZE];
     ecs_strbuf_t hdr_buf = ECS_STRBUF_INIT;
@@ -27827,7 +27827,7 @@ void send_reply(
     int32_t content_length = reply->body.length - 1;
 
     /* First, send the response HTTP headers */
-    append_send_headers(&hdr_buf, reply->code, reply->status, 
+    append_send_headers(&hdr_buf, reply->code, reply->status,
         reply->content_type, &reply->headers, content_length);
 
     ecs_size_t hdrs_len = ecs_strbuf_written(&hdr_buf);
@@ -27858,7 +27858,7 @@ void recv_request(
     char recv_buf[ECS_HTTP_SEND_RECV_BUFFER_SIZE];
 
     while ((bytes_read = http_recv(
-        conn->sock, recv_buf, ECS_SIZEOF(recv_buf), 0)) > 0) 
+        conn->sock, recv_buf, ECS_SIZEOF(recv_buf), 0)) > 0)
     {
         if (parse_request(conn, recv_buf, bytes_read)) {
             return;
@@ -27868,10 +27868,10 @@ void recv_request(
 
 static
 void init_connection(
-    ecs_http_server_t *srv, 
+    ecs_http_server_t *srv,
     ecs_http_socket_t sock_conn,
-    struct sockaddr_storage *remote_addr, 
-    ecs_size_t remote_addr_len) 
+    struct sockaddr_storage *remote_addr,
+    ecs_size_t remote_addr_len)
 {
     /* Create new connection */
     ecs_os_mutex_lock(srv->lock);
@@ -27893,22 +27893,22 @@ void init_connection(
         ecs_os_strcpy(remote_port, "unknown");
     }
 
-    ecs_dbg("http: connection established from '%s:%s'", 
+    ecs_dbg("http: connection established from '%s:%s'",
         remote_host, remote_port);
 
     conn->pub.server = srv;
     conn->sock = sock_conn;
     recv_request(conn);
 
-    ecs_dbg("http: request received from '%s:%s'", 
+    ecs_dbg("http: request received from '%s:%s'",
         remote_host, remote_port);
 }
 
 static
 int accept_connections(
-    ecs_http_server_t* srv, 
-    const struct sockaddr* addr, 
-    ecs_size_t addr_len) 
+    ecs_http_server_t* srv,
+    const struct sockaddr* addr,
+    ecs_size_t addr_len)
 {
 #ifdef ECS_TARGET_WINDOWS
     /* If on Windows, test if winsock needs to be initialized */
@@ -27917,7 +27917,7 @@ int accept_connections(
         WSADATA data = { 0 };
         int result = WSAStartup(MAKEWORD(2, 2), &data);
         if (result) {
-            ecs_warn("WSAStartup failed with GetLastError = %d\n", 
+            ecs_warn("WSAStartup failed with GetLastError = %d\n",
                 GetLastError());
             return -1;
         }
@@ -27931,7 +27931,7 @@ int accept_connections(
     char addr_port[20];
 
     if (http_getnameinfo(
-        addr, addr_len, addr_host, ECS_SIZEOF(addr_host), addr_port, 
+        addr, addr_len, addr_host, ECS_SIZEOF(addr_host), addr_port,
         ECS_SIZEOF(addr_port), NI_NUMERICHOST | NI_NUMERICSERV))
     {
         ecs_os_strcpy(addr_host, "unknown");
@@ -27940,37 +27940,37 @@ int accept_connections(
 
     srv->sock = socket(addr->sa_family, SOCK_STREAM, IPPROTO_TCP);
     if (srv->sock <= 0) {
-        ecs_err("unable to create new connection socket: %s", 
+        ecs_err("unable to create new connection socket: %s",
             ecs_os_strerror(errno));
         return -1;
     }
 
     int reuse = 1;
-    int result = setsockopt(srv->sock, SOL_SOCKET, SO_REUSEADDR, 
-        (char*)&reuse, ECS_SIZEOF(reuse)); 
+    int result = setsockopt(srv->sock, SOL_SOCKET, SO_REUSEADDR,
+        (char*)&reuse, ECS_SIZEOF(reuse));
     if (result) {
         ecs_warn("failed to setsockopt: %s", ecs_os_strerror(errno));
     }
 
     if (addr->sa_family == AF_INET6) {
         int ipv6only = 0;
-        if (setsockopt(srv->sock, IPPROTO_IPV6, IPV6_V6ONLY, 
+        if (setsockopt(srv->sock, IPPROTO_IPV6, IPV6_V6ONLY,
             (char*)&ipv6only, ECS_SIZEOF(ipv6only)))
         {
             ecs_warn("failed to setsockopt: %s", ecs_os_strerror(errno));
         }
     }
-    
+
     result = http_bind(srv->sock, addr, addr_len);
     if (result) {
-        ecs_err("http: failed to bind to '%s:%s': %s", 
+        ecs_err("http: failed to bind to '%s:%s': %s",
             addr_host, addr_port, ecs_os_strerror(errno));
         return -1;
     }
 
     result = listen(srv->sock, SOMAXCONN);
     if (result) {
-        ecs_warn("http: could not listen for SOMAXCONN (%d) connections: %s", 
+        ecs_warn("http: could not listen for SOMAXCONN (%d) connections: %s",
             SOMAXCONN, ecs_os_strerror(errno));
     }
 
@@ -27983,11 +27983,11 @@ int accept_connections(
 
     while (srv->should_run) {
         remote_addr_len = ECS_SIZEOF(remote_addr);
-        sock_conn = http_accept(srv->sock, (struct sockaddr*) &remote_addr, 
+        sock_conn = http_accept(srv->sock, (struct sockaddr*) &remote_addr,
             &remote_addr_len);
 
         if (sock_conn == -1) {
-            ecs_dbg("http: connection attempt failed: %s", 
+            ecs_dbg("http: connection attempt failed: %s",
                 ecs_os_strerror(errno));
             continue;
         }
@@ -28025,7 +28025,7 @@ void handle_request(
     ecs_http_request_impl_t *req)
 {
     ecs_http_reply_t reply = ECS_HTTP_REPLY_INIT;
-    ecs_http_connection_impl_t *conn = 
+    ecs_http_connection_impl_t *conn =
         (ecs_http_connection_impl_t*)req->pub.conn;
 
     if (srv->callback((ecs_http_request_t*)req, &reply, srv->ctx) == 0) {
@@ -28060,10 +28060,10 @@ void dequeue_requests(
         ecs_http_connection_impl_t *conn = flecs_sparse_get_dense(
             srv->connections, ecs_http_connection_impl_t, i);
         conn->dequeue_timeout += delta_time;
-        if (conn->dequeue_timeout > 
-            (FLECS_FLOAT)ECS_HTTP_CONNECTION_PURGE_TIMEOUT) 
+        if (conn->dequeue_timeout >
+            (FLECS_FLOAT)ECS_HTTP_CONNECTION_PURGE_TIMEOUT)
         {
-            ecs_dbg("http: purging connection '%s:%s' (sock = %d)", 
+            ecs_dbg("http: purging connection '%s:%s' (sock = %d)",
                 conn->pub.host, conn->pub.port, conn->sock);
             connection_free(conn);
         }
@@ -28074,7 +28074,7 @@ void dequeue_requests(
 
 const char* ecs_http_get_header(
     const ecs_http_request_t* req,
-    const char* name) 
+    const char* name)
 {
     for (ecs_size_t i = 0; i < req->header_count; i++) {
         if (!ecs_os_strcmp(req->headers[i].key, name)) {
@@ -28086,7 +28086,7 @@ const char* ecs_http_get_header(
 
 const char* ecs_http_get_param(
     const ecs_http_request_t* req,
-    const char* name) 
+    const char* name)
 {
     for (ecs_size_t i = 0; i < req->param_count; i++) {
         if (!ecs_os_strcmp(req->params[i].key, name)) {
@@ -28097,9 +28097,9 @@ const char* ecs_http_get_param(
 }
 
 ecs_http_server_t* ecs_http_server_init(
-    const ecs_http_server_desc_t *desc) 
+    const ecs_http_server_desc_t *desc)
 {
-    ecs_check(ecs_os_has_threading(), ECS_UNSUPPORTED, 
+    ecs_check(ecs_os_has_threading(), ECS_UNSUPPORTED,
         "missing OS API implementation");
 
     ecs_http_server_t* srv = ecs_os_calloc_t(ecs_http_server_t);
@@ -28128,7 +28128,7 @@ error:
 }
 
 void ecs_http_server_fini(
-    ecs_http_server_t* srv) 
+    ecs_http_server_t* srv)
 {
     ecs_http_server_stop(srv);
     ecs_os_mutex_free(srv->lock);
@@ -28158,7 +28158,7 @@ error:
 }
 
 void ecs_http_server_stop(
-    ecs_http_server_t* srv) 
+    ecs_http_server_t* srv)
 {
     ecs_check(srv != NULL, ECS_INVALID_PARAMETER, NULL);
     ecs_check(srv->initialized, ECS_INVALID_OPERATION, NULL);
@@ -28187,9 +28187,9 @@ void ecs_http_server_stop(
             srv->requests, ecs_http_request_impl_t, i));
     }
 
-    ecs_assert(flecs_sparse_count(srv->connections) == 0, 
+    ecs_assert(flecs_sparse_count(srv->connections) == 0,
         ECS_INTERNAL_ERROR, NULL);
-    ecs_assert(flecs_sparse_count(srv->requests) == 0, 
+    ecs_assert(flecs_sparse_count(srv->requests) == 0,
         ECS_INTERNAL_ERROR, NULL);
 
     srv->thread = 0;
@@ -28204,7 +28204,7 @@ void ecs_http_server_dequeue(
     ecs_check(srv != NULL, ECS_INVALID_PARAMETER, NULL);
     ecs_check(srv->initialized, ECS_INVALID_PARAMETER, NULL);
     ecs_check(srv->should_run, ECS_INVALID_PARAMETER, NULL);
-    
+
     srv->delta_time += delta_time;
     if ((1000 * srv->delta_time) > (FLECS_FLOAT)ECS_HTTP_MIN_DEQUEUE_INTERVAL) {
         dequeue_requests(srv, srv->delta_time);
@@ -28232,7 +28232,7 @@ static ECS_MOVE(EcsDocDescription, dst, src, {
     src->value = NULL;
 })
 
-static ECS_DTOR(EcsDocDescription, ptr, { 
+static ECS_DTOR(EcsDocDescription, ptr, {
     ecs_os_free((char*)ptr->value);
 })
 
@@ -28307,7 +28307,7 @@ const char* ecs_doc_get_link(
 
 void FlecsDocImport(
     ecs_world_t *world)
-{    
+{
     ECS_MODULE(world, FlecsDoc);
 
     ecs_set_name_prefix(world, "EcsDoc");
@@ -28317,7 +28317,7 @@ void FlecsDocImport(
     flecs_bootstrap_tag(world, EcsDocDetail);
     flecs_bootstrap_tag(world, EcsDocLink);
 
-    ecs_set_component_actions(world, EcsDocDescription, { 
+    ecs_set_component_actions(world, EcsDocDescription, {
         .ctor = ecs_default_ctor,
         .move = ecs_move(EcsDocDescription),
         .copy = ecs_copy(EcsDocDescription),
@@ -28384,7 +28384,7 @@ const char* ecs_parse_eol_and_whitespace(
         ptr ++;
     }
 
-    return ptr;    
+    return ptr;
 }
 
 /** Skip spaces when parsing signature */
@@ -28424,7 +28424,7 @@ const char* ecs_parse_digit(
     }
 
     tptr[0] = '\0';
-    
+
     return ptr;
 }
 
@@ -28479,7 +28479,7 @@ bool valid_identifier_start_char(
     char ch)
 {
     if (ch && (isalpha(ch) || (ch == '.') || (ch == '_') || (ch == '*') ||
-        (ch == '0') || (ch == TOK_AS_ENTITY) || isdigit(ch))) 
+        (ch == '0') || (ch == TOK_AS_ENTITY) || isdigit(ch)))
     {
         return true;
     }
@@ -28504,8 +28504,8 @@ static
 bool valid_token_char(
     char ch)
 {
-    if (ch && 
-        (isalpha(ch) || isdigit(ch) || ch == '_' || ch == '.' || ch == '"')) 
+    if (ch &&
+        (isalpha(ch) || isdigit(ch) || ch == '_' || ch == '.' || ch == '"'))
     {
         return true;
     }
@@ -28547,10 +28547,10 @@ const char* ecs_parse_token(
 
     if (!valid_token_start_char(ch)) {
         if (ch == '\0' || ch == '\n') {
-            ecs_parser_error(name, expr, column, 
+            ecs_parser_error(name, expr, column,
                 "unexpected end of expression");
         } else {
-            ecs_parser_error(name, expr, column, 
+            ecs_parser_error(name, expr, column,
                 "invalid start of token '%s'", ptr);
         }
         return NULL;
@@ -28590,7 +28590,7 @@ const char* ecs_parse_token(
     tptr[0] = '\0';
 
     if (tmpl_nesting != 0) {
-        ecs_parser_error(name, expr, column, 
+        ecs_parser_error(name, expr, column,
             "identifier '%s' has mismatching < > pairs", ptr);
         return NULL;
     }
@@ -28614,7 +28614,7 @@ const char* ecs_parse_identifier(
     char *token_out)
 {
     if (!valid_identifier_start_char(ptr[0])) {
-        ecs_parser_error(name, expr, (ptr - expr), 
+        ecs_parser_error(name, expr, (ptr - expr),
             "expected start of identifier");
         return NULL;
     }
@@ -28652,9 +28652,9 @@ ecs_entity_t parse_role(
     int64_t column,
     const char *token)
 {
-    if        (!ecs_os_strcmp(token, TOK_ROLE_PAIR)) 
+    if        (!ecs_os_strcmp(token, TOK_ROLE_PAIR))
     {
-        return ECS_PAIR;            
+        return ECS_PAIR;
     } else if (!ecs_os_strcmp(token, TOK_ROLE_AND)) {
         return ECS_AND;
     } else if (!ecs_os_strcmp(token, TOK_ROLE_OR)) {
@@ -28670,7 +28670,7 @@ ecs_entity_t parse_role(
     } else if (!ecs_os_strcmp(token, TOK_OWNED)) {
         return ECS_OVERRIDE;
     } else if (!ecs_os_strcmp(token, TOK_ROLE_DISABLED)) {
-        return ECS_DISABLED;        
+        return ECS_DISABLED;
     } else {
         ecs_parser_error(name, sig, column, "invalid role '%s'", token);
         return 0;
@@ -28695,7 +28695,7 @@ const char* parse_annotation(
     const char *name,
     const char *sig,
     int64_t column,
-    const char *ptr, 
+    const char *ptr,
     ecs_inout_kind_t *inout_kind_out)
 {
     char token[ECS_MAX_TOKEN_SIZE];
@@ -28771,25 +28771,25 @@ const char* parse_set_expr(
     do {
         uint8_t tok = parse_set_token(token);
         if (!tok) {
-            ecs_parser_error(name, expr, column, 
+            ecs_parser_error(name, expr, column,
                 "invalid set token '%s'", token);
             return NULL;
         }
 
         if (id->set.mask & tok) {
-            ecs_parser_error(name, expr, column, 
+            ecs_parser_error(name, expr, column,
                 "duplicate set token '%s'", token);
-            return NULL;            
+            return NULL;
         }
 
         if ((tok == EcsSubSet && id->set.mask & EcsSuperSet) ||
             (tok == EcsSuperSet && id->set.mask & EcsSubSet))
         {
-            ecs_parser_error(name, expr, column, 
+            ecs_parser_error(name, expr, column,
                 "cannot mix super and sub", token);
-            return NULL;            
+            return NULL;
         }
-        
+
         id->set.mask |= tok;
 
         if (ptr[0] == TOK_PAREN_OPEN) {
@@ -28800,11 +28800,11 @@ const char* parse_set_expr(
                 ptr = ecs_parse_identifier(name, expr, ptr, token);
                 if (!ptr) {
                     return NULL;
-                }         
+                }
 
                 id->set.relation = ecs_lookup_fullpath(world, token);
                 if (!id->set.relation) {
-                    ecs_parser_error(name, expr, column, 
+                    ecs_parser_error(name, expr, column,
                         "unresolved identifier '%s'", token);
                     return NULL;
                 }
@@ -28812,7 +28812,7 @@ const char* parse_set_expr(
                 if (ptr[0] == TOK_AND) {
                     ptr = ecs_parse_whitespace(ptr + 1);
                 } else if (ptr[0] != TOK_PAREN_CLOSE) {
-                    ecs_parser_error(name, expr, column, 
+                    ecs_parser_error(name, expr, column,
                         "expected ',' or ')'");
                     return NULL;
                 }
@@ -28827,9 +28827,9 @@ const char* parse_set_expr(
 
                 id->set.max_depth = atoi(token);
                 if (id->set.max_depth < 0) {
-                    ecs_parser_error(name, expr, column, 
+                    ecs_parser_error(name, expr, column,
                         "invalid negative depth");
-                    return NULL;  
+                    return NULL;
                 }
 
                 if (ptr[0] == ',') {
@@ -28847,20 +28847,20 @@ const char* parse_set_expr(
                 id->set.min_depth = id->set.max_depth;
                 id->set.max_depth = atoi(token);
                 if (id->set.max_depth < 0) {
-                    ecs_parser_error(name, expr, column, 
+                    ecs_parser_error(name, expr, column,
                         "invalid negative depth");
-                    return NULL;  
+                    return NULL;
                 }
             }
 
             if (ptr[0] != TOK_PAREN_CLOSE) {
                 ecs_parser_error(name, expr, column, "expected ')', got '%c'",
                     ptr[0]);
-                return NULL;                
+                return NULL;
             } else {
                 ptr = ecs_parse_whitespace(ptr + 1);
                 if (ptr[0] != tok_end && ptr[0] != TOK_AND && ptr[0] != 0) {
-                    ecs_parser_error(name, expr, column, 
+                    ecs_parser_error(name, expr, column,
                         "expected end of set expr");
                     return NULL;
                 }
@@ -28883,7 +28883,7 @@ const char* parse_set_expr(
         }
     } while (true);
 
-    if (id->set.mask & EcsCascade && !(id->set.mask & EcsSuperSet) && 
+    if (id->set.mask & EcsCascade && !(id->set.mask & EcsSuperSet) &&
         !(id->set.mask & EcsSubSet))
     {
         /* If cascade is used without specifying super or sub, assume
@@ -28892,9 +28892,9 @@ const char* parse_set_expr(
     }
 
     if (id->set.mask & EcsSelf && id->set.min_depth != 0) {
-        ecs_parser_error(name, expr, column, 
+        ecs_parser_error(name, expr, column,
             "min_depth must be zero for set expression with 'self'");
-        return NULL;        
+        return NULL;
     }
 
     return ptr;
@@ -28917,7 +28917,7 @@ const char* parse_arguments(
     do {
         if (valid_token_start_char(ptr[0])) {
             if (arg == 2) {
-                ecs_parser_error(name, expr, (ptr - expr), 
+                ecs_parser_error(name, expr, (ptr - expr),
                     "too many arguments in term");
                 return NULL;
             }
@@ -28939,7 +28939,7 @@ const char* parse_arguments(
              * set expression. */
             if (ptr[0] == TOK_COLON) {
                 if (parse_identifier(token, term_id)) {
-                    ecs_parser_error(name, expr, (ptr - expr), 
+                    ecs_parser_error(name, expr, (ptr - expr),
                         "invalid identifier '%s'", token);
                     return NULL;
                 }
@@ -28955,12 +28955,12 @@ const char* parse_arguments(
              * expression */
             } else if (!ecs_os_strcmp(token, TOK_ALL) ||
                 !ecs_os_strcmp(token, TOK_CASCADE) ||
-                !ecs_os_strcmp(token, TOK_SELF) || 
-                !ecs_os_strcmp(token, TOK_SUPERSET) || 
+                !ecs_os_strcmp(token, TOK_SELF) ||
+                !ecs_os_strcmp(token, TOK_SUPERSET) ||
                 !ecs_os_strcmp(token, TOK_SUBSET) ||
                 !(ecs_os_strcmp(token, TOK_PARENT)))
             {
-                ptr = parse_set_expr(world, name, expr, (ptr - expr), ptr, 
+                ptr = parse_set_expr(world, name, expr, (ptr - expr), ptr,
                     token, term_id, TOK_PAREN_CLOSE);
                 if (!ptr) {
                     return NULL;
@@ -28968,7 +28968,7 @@ const char* parse_arguments(
 
             /* Regular identifier */
             } else if (parse_identifier(token, term_id)) {
-                ecs_parser_error(name, expr, (ptr - expr), 
+                ecs_parser_error(name, expr, (ptr - expr),
                     "invalid identifier '%s'", token);
                 return NULL;
             }
@@ -28983,13 +28983,13 @@ const char* parse_arguments(
                 break;
 
             } else {
-                ecs_parser_error(name, expr, (ptr - expr), 
+                ecs_parser_error(name, expr, (ptr - expr),
                     "expected ',' or ')'");
                 return NULL;
             }
 
         } else {
-            ecs_parser_error(name, expr, (ptr - expr), 
+            ecs_parser_error(name, expr, (ptr - expr),
                 "expected identifier or set expression");
             return NULL;
         }
@@ -29009,10 +29009,10 @@ void parser_unexpected_char(
     char ch)
 {
     if (ch && (ch != '\n')) {
-        ecs_parser_error(name, expr, (ptr - expr), 
+        ecs_parser_error(name, expr, (ptr - expr),
             "unexpected character '%c'", ch);
     } else {
-        ecs_parser_error(name, expr, (ptr - expr), 
+        ecs_parser_error(name, expr, (ptr - expr),
             "unexpected end of term");
     }
 }
@@ -29060,7 +29060,7 @@ const char* parse_term(
 
         /* Is token a predicate? */
         if (ptr[0] == TOK_PAREN_OPEN) {
-            goto parse_predicate;    
+            goto parse_predicate;
         }
 
         /* Next token must be a predicate */
@@ -29078,7 +29078,7 @@ const char* parse_term(
             goto parse_singleton;
 
         } else {
-            ecs_parser_error(name, expr, (ptr - expr), 
+            ecs_parser_error(name, expr, (ptr - expr),
                 "expected identifier after singleton operator");
             goto error;
         }
@@ -29114,22 +29114,22 @@ parse_role:
     } else if (ptr[0] == TOK_PAREN_OPEN) {
         goto parse_pair;
     } else {
-        ecs_parser_error(name, expr, (ptr - expr), 
+        ecs_parser_error(name, expr, (ptr - expr),
             "expected identifier after role");
         goto error;
     }
 
 parse_predicate:
     if (parse_identifier(token, &term.pred)) {
-        ecs_parser_error(name, expr, (ptr - expr), 
-            "invalid identifier '%s'", token); 
+        ecs_parser_error(name, expr, (ptr - expr),
+            "invalid identifier '%s'", token);
         goto error;
     }
 
     /* Set expression */
     if (ptr[0] == TOK_COLON) {
         ptr = ecs_parse_whitespace(ptr + 1);
-        ptr = parse_set_expr(world, name, expr, (ptr - expr), ptr, NULL, 
+        ptr = parse_set_expr(world, name, expr, (ptr - expr), ptr, NULL,
             &term.pred, TOK_COLON);
         if (!ptr) {
             goto error;
@@ -29142,7 +29142,7 @@ parse_predicate:
         }
 
         if (ptr[0] != TOK_COLON) {
-            ecs_parser_error(name, expr, (ptr - expr), 
+            ecs_parser_error(name, expr, (ptr - expr),
                 "unexpected token '%c' after predicate set expression", ptr[0]);
             goto error;
         }
@@ -29151,7 +29151,7 @@ parse_predicate:
     } else {
         ptr = ecs_parse_whitespace(ptr);
     }
-    
+
     if (ptr[0] == TOK_PAREN_OPEN) {
         ptr ++;
         if (ptr[0] == TOK_PAREN_CLOSE) {
@@ -29188,8 +29188,8 @@ parse_pair:
 
 parse_pair_predicate:
     if (parse_identifier(token, &term.pred)) {
-        ecs_parser_error(name, expr, (ptr - expr), 
-            "invalid identifier '%s'", token); 
+        ecs_parser_error(name, expr, (ptr - expr),
+            "invalid identifier '%s'", token);
         goto error;
     }
 
@@ -29212,22 +29212,22 @@ parse_pair_predicate:
         ptr ++;
         goto parse_done;
     } else {
-        ecs_parser_error(name, expr, (ptr - expr), 
+        ecs_parser_error(name, expr, (ptr - expr),
             "expected pair object or ')'");
         goto error;
     }
 
 parse_pair_object:
     if (parse_identifier(token, &term.obj)) {
-        ecs_parser_error(name, expr, (ptr - expr), 
-            "invalid identifier '%s'", token); 
+        ecs_parser_error(name, expr, (ptr - expr),
+            "invalid identifier '%s'", token);
         goto error;
     }
 
     if (term.role != 0) {
         if (term.role != ECS_PAIR && term.role != ECS_CASE) {
-            ecs_parser_error(name, expr, (ptr - expr), 
-                "invalid combination of role '%s' with pair", 
+            ecs_parser_error(name, expr, (ptr - expr),
+                "invalid combination of role '%s' with pair",
                     ecs_role_str(term.role));
             goto error;
         }
@@ -29236,13 +29236,13 @@ parse_pair_object:
     }
 
     ptr = ecs_parse_whitespace(ptr);
-    goto parse_done; 
+    goto parse_done;
 
 parse_singleton:
     if (parse_identifier(token, &term.pred)) {
-        ecs_parser_error(name, expr, (ptr - expr), 
-            "invalid identifier '%s'", token); 
-        goto error; 
+        ecs_parser_error(name, expr, (ptr - expr),
+            "invalid identifier '%s'", token);
+        goto error;
     }
 
     parse_identifier(token, &term.subj);
@@ -29299,12 +29299,12 @@ char* ecs_parse_term(
                 ptr += 2;
                 prev_or = true;
             } else {
-                ecs_parser_error(name, expr, (ptr - expr), 
+                ecs_parser_error(name, expr, (ptr - expr),
                     "invalid preceding token");
             }
         }
     }
-    
+
     ptr = ecs_parse_eol_and_whitespace(ptr);
     if (!ptr[0]) {
         *term = (ecs_term_t){0};
@@ -29329,7 +29329,7 @@ char* ecs_parse_term(
     if (!ecs_os_strncmp(ptr, TOK_OR, 2) || prev_or) {
         /* An OR operator must always follow an AND or another OR */
         if (term->oper != EcsAnd) {
-            ecs_parser_error(name, expr, (ptr - expr), 
+            ecs_parser_error(name, expr, (ptr - expr),
                 "cannot combine || with other operators");
             goto error;
         }
@@ -29339,7 +29339,7 @@ char* ecs_parse_term(
 
     /* Term must either end in end of expression, AND or OR token */
     if (!is_valid_end_of_term(ptr)) {
-        ecs_parser_error(name, expr, (ptr - expr), 
+        ecs_parser_error(name, expr, (ptr - expr),
             "expected end of expression or next term");
         goto error;
     }
@@ -29348,16 +29348,16 @@ char* ecs_parse_term(
      * that after the 0 nothing else follows */
     if (!ecs_os_strcmp(term->pred.name, "0")) {
         if (ptr[0]) {
-            ecs_parser_error(name, expr, (ptr - expr), 
-                "unexpected term after 0"); 
+            ecs_parser_error(name, expr, (ptr - expr),
+                "unexpected term after 0");
             goto error;
         }
 
-        if (subj->set.mask != EcsDefaultSet || 
+        if (subj->set.mask != EcsDefaultSet ||
            (subj->entity && subj->entity != EcsThis) ||
            (subj->name && ecs_os_strcmp(subj->name, "This")))
         {
-            ecs_parser_error(name, expr, (ptr - expr), 
+            ecs_parser_error(name, expr, (ptr - expr),
                 "invalid combination of 0 with non-default subject");
             goto error;
         }
@@ -29369,8 +29369,8 @@ char* ecs_parse_term(
 
     /* Cannot combine EcsNothing with operators other than AND */
     if (term->oper != EcsAnd && subj->set.mask == EcsNothing) {
-        ecs_parser_error(name, expr, (ptr - expr), 
-            "invalid operator for empty source"); 
+        ecs_parser_error(name, expr, (ptr - expr),
+            "invalid operator for empty source");
         goto error;
     }
 
@@ -29378,7 +29378,7 @@ char* ecs_parse_term(
     if (prev_or && term->oper == EcsOr) {
         /* Set expressions must be the same for all OR terms */
         if (subj->set.mask != prev_set) {
-            ecs_parser_error(name, expr, (ptr - expr), 
+            ecs_parser_error(name, expr, (ptr - expr),
                 "cannot combine different sources in OR expression");
             goto error;
         }
@@ -29485,11 +29485,11 @@ const char* skip_scope(const char *ptr, meta_parse_ctx_t *ctx) {
             if (sp >= 256) {
                 ecs_meta_error(ctx, ptr, "maximum level of nesting reached");
                 goto error;
-            }            
+            }
         } else if (ch == ')' || ch == '>') {
             sp --;
-            if ((sp < 0) || (ch == '>' && stack[sp] != '<') || 
-                (ch == ')' && stack[sp] != '(')) 
+            if ((sp < 0) || (ch == '>' && stack[sp] != '<') ||
+                (ch == ')' && stack[sp] != '('))
             {
                 ecs_meta_error(ctx, ptr, "mismatching %c in identifier", ch);
                 goto error;
@@ -29529,10 +29529,10 @@ error:
 
 static
 const char* parse_c_identifier(
-    const char *ptr, 
+    const char *ptr,
     char *buff,
     char *params,
-    meta_parse_ctx_t *ctx) 
+    meta_parse_ctx_t *ctx)
 {
     ecs_assert(ptr != NULL, ECS_INTERNAL_ERROR, NULL);
     ecs_assert(buff != NULL, ECS_INTERNAL_ERROR, NULL);
@@ -29548,7 +29548,7 @@ const char* parse_c_identifier(
     ptr = ecs_parse_eol_and_whitespace(ptr);
 
     if (!isalpha(*ptr)) {
-        ecs_meta_error(ctx, ptr, 
+        ecs_meta_error(ctx, ptr,
             "invalid identifier (starts with '%c')", *ptr);
         goto error;
     }
@@ -29588,7 +29588,7 @@ error:
 static
 const char * meta_open_scope(
     const char *ptr,
-    meta_parse_ctx_t *ctx)    
+    meta_parse_ctx_t *ctx)
 {
     /* Skip initial whitespaces */
     ptr = ecs_parse_eol_and_whitespace(ptr);
@@ -29597,7 +29597,7 @@ const char * meta_open_scope(
     if (ctx->desc == ptr) {
         if (*ptr != '{') {
             ecs_meta_error(ctx, ptr, "missing '{' in struct definition");
-            goto error; 
+            goto error;
         }
 
         ptr ++;
@@ -29608,13 +29608,13 @@ const char * meta_open_scope(
     if (!*ptr) {
         ecs_meta_error(ctx, ptr, "missing '}' at end of struct definition");
         goto error;
-    }   
+    }
 
     /* Is this the end of the type definition? */
     if (*ptr == '}') {
         ptr = ecs_parse_eol_and_whitespace(ptr + 1);
         if (*ptr) {
-            ecs_meta_error(ctx, ptr, 
+            ecs_meta_error(ctx, ptr,
                 "stray characters after struct definition");
             goto error;
         }
@@ -29631,7 +29631,7 @@ const char* meta_parse_constant(
     const char *ptr,
     meta_constant_t *token,
     meta_parse_ctx_t *ctx)
-{    
+{
     ptr = meta_open_scope(ptr, ctx);
     if (!ptr) {
         return NULL;
@@ -29795,7 +29795,7 @@ int meta_parse_desc(
 
     ptr = ecs_parse_eol_and_whitespace(ptr);
     if (*ptr != '(' && *ptr != '<') {
-        ecs_meta_error(ctx, ptr, 
+        ecs_meta_error(ctx, ptr,
             "expected '(' at start of collection definition");
         goto error;
     }
@@ -29813,7 +29813,7 @@ int meta_parse_desc(
     /* If next token is a ',' the first type was a key type */
     if (*ptr == ',') {
         ptr = ecs_parse_eol_and_whitespace(ptr + 1);
-        
+
         if (isdigit(*ptr)) {
             int64_t value;
             ptr = parse_c_digit(ptr, &value);
@@ -29835,7 +29835,7 @@ int meta_parse_desc(
     }
 
     if (*ptr != ')' && *ptr != '>') {
-        ecs_meta_error(ctx, ptr, 
+        ecs_meta_error(ctx, ptr,
             "expected ')' at end of collection definition");
         goto error;
     }
@@ -29999,8 +29999,8 @@ ecs_entity_t meta_lookup(
         if (!ecs_os_strcmp(typename, "ecs_array")) {
             type = meta_lookup_array(world, 0, token->params, ctx);
 
-        } else if (!ecs_os_strcmp(typename, "ecs_vector") || 
-                !ecs_os_strcmp(typename, "flecs::vector")) 
+        } else if (!ecs_os_strcmp(typename, "ecs_vector") ||
+                !ecs_os_strcmp(typename, "flecs::vector"))
         {
             type = meta_lookup_vector(world, 0, token->params, ctx);
 
@@ -30013,8 +30013,8 @@ ecs_entity_t meta_lookup(
         } else if (!ecs_os_strcmp(typename, "char")) {
             type = ecs_id(ecs_char_t);
 
-        } else if (!ecs_os_strcmp(typename, "bool") || 
-                !ecs_os_strcmp(typename, "_Bool")) 
+        } else if (!ecs_os_strcmp(typename, "bool") ||
+                !ecs_os_strcmp(typename, "_Bool"))
         {
             type = ecs_id(ecs_bool_t);
 
@@ -30056,8 +30056,8 @@ ecs_entity_t meta_lookup(
         if (token->is_ptr) {
             typename = "flecs.meta.uptr";
         } else
-        if (!ecs_os_strcmp(typename, "char*") || 
-            !ecs_os_strcmp(typename, "flecs::string")) 
+        if (!ecs_os_strcmp(typename, "char*") ||
+            !ecs_os_strcmp(typename, "flecs::string"))
         {
             typename = "flecs.meta.string";
         }
@@ -30112,7 +30112,7 @@ int meta_parse_struct(
         }
 
         ecs_set(world, m, EcsMember, {
-            .type = type, 
+            .type = type,
             .count = (ecs_size_t)token.count
         });
     }
@@ -30162,10 +30162,10 @@ int meta_parse_constants(
         });
 
         if (!is_bitmask) {
-            ecs_set_pair_object(world, c, EcsConstant, ecs_i32_t, 
+            ecs_set_pair_object(world, c, EcsConstant, ecs_i32_t,
                 {(ecs_i32_t)last_value});
         } else {
-            ecs_set_pair_object(world, c, EcsConstant, ecs_u32_t, 
+            ecs_set_pair_object(world, c, EcsConstant, ecs_u32_t,
                 {(ecs_u32_t)last_value});
         }
 
@@ -30475,8 +30475,8 @@ const ecs_stage_t* flecs_stage_from_readonly_world(
     } else if (ecs_poly_is(world, ecs_stage_t)) {
         return (ecs_stage_t*)world;
     }
-    
-    return NULL;    
+
+    return NULL;
 }
 
 ecs_stage_t *flecs_stage_from_world(
@@ -30498,12 +30498,12 @@ ecs_stage_t *flecs_stage_from_world(
         *world_ptr = stage->world;
         return stage;
     }
-    
+
     return NULL;
 }
 
 /* Evaluate component monitor. If a monitored entity changed it will have set a
- * flag in one of the world's component monitors. Queries can register 
+ * flag in one of the world's component monitors. Queries can register
  * themselves with component monitors to determine whether they need to rematch
  * with tables. */
 static
@@ -30557,10 +30557,10 @@ void flecs_monitor_mark_dirty(
 
     /* Only flag if there are actually monitors registered, so that we
      * don't waste cycles evaluating monitors if there's no interest */
-    ecs_monitor_set_t *ms = ecs_map_get(world->monitors.monitor_sets, 
+    ecs_monitor_set_t *ms = ecs_map_get(world->monitors.monitor_sets,
         ecs_monitor_set_t, relation);
     if (ms && ms->monitors) {
-        ecs_monitor_t *m = ecs_map_get(ms->monitors, 
+        ecs_monitor_t *m = ecs_map_get(ms->monitors,
             ecs_monitor_t, id);
         if (m) {
             m->is_dirty = true;
@@ -30590,7 +30590,7 @@ void flecs_monitor_register(
     }
 
     ecs_monitor_t *m = ecs_map_ensure(ms->monitors, ecs_monitor_t, id);
-    ecs_assert(m != NULL, ECS_INTERNAL_ERROR, NULL);        
+    ecs_assert(m != NULL, ECS_INTERNAL_ERROR, NULL);
 
     ecs_query_t **q = ecs_vector_add(&m->queries, ecs_query_t*);
     *q = query;
@@ -30628,10 +30628,10 @@ void monitors_fini(
 
 static
 void init_store(
-    ecs_world_t *world) 
+    ecs_world_t *world)
 {
     ecs_os_memset(&world->store, 0, ECS_SIZEOF(ecs_store_t));
-    
+
     /* Initialize entity index */
     world->store.entity_index = flecs_sparse_new(ecs_record_t);
     flecs_sparse_set_id_source(world->store.entity_index, &world->stats.last_id);
@@ -30662,7 +30662,7 @@ void clean_tables(
     for (i = 0; i < count; i ++) {
         ecs_table_t *t = flecs_sparse_get_dense(world->store.tables, ecs_table_t, i);
         flecs_table_free_type(t);
-    }    
+    }
 
     /* Clear the root table */
     if (count) {
@@ -30839,7 +30839,7 @@ ecs_world_t *ecs_mini(void) {
     world->type_handles = ecs_map_new(ecs_entity_t, 0);
 
     world->stats.time_scale = 1.0;
-    
+
     monitors_init(&world->monitors);
 
     if (ecs_os_has_time()) {
@@ -31010,7 +31010,7 @@ void default_copy_ctor(
     size_t size, int32_t count, void *ctx)
 {
     callbacks->ctor(world, component, dst_entity, dst_ptr, size, count, ctx);
-    callbacks->copy(world, component, dst_entity, src_entity, dst_ptr, src_ptr, 
+    callbacks->copy(world, component, dst_entity, src_entity, dst_ptr, src_ptr,
         size, count, ctx);
 }
 
@@ -31022,7 +31022,7 @@ void default_move_ctor(
     int32_t count, void *ctx)
 {
     callbacks->ctor(world, component, dst_entity, dst_ptr, size, count, ctx);
-    callbacks->move(world, component, dst_entity, src_entity, dst_ptr, src_ptr, 
+    callbacks->move(world, component, dst_entity, src_entity, dst_ptr, src_ptr,
         size, count, ctx);
 }
 
@@ -31034,7 +31034,7 @@ void default_ctor_w_move_w_dtor(
     int32_t count, void *ctx)
 {
     callbacks->ctor(world, component, dst_entity, dst_ptr, size, count, ctx);
-    callbacks->move(world, component, dst_entity, src_entity, dst_ptr, src_ptr, 
+    callbacks->move(world, component, dst_entity, src_entity, dst_ptr, src_ptr,
         size, count, ctx);
     callbacks->dtor(world, component, src_entity, src_ptr, size, count, ctx);
 }
@@ -31046,7 +31046,7 @@ void default_move_ctor_w_dtor(
     const ecs_entity_t *src_entity, void *dst_ptr, void *src_ptr, size_t size,
     int32_t count, void *ctx)
 {
-    callbacks->move_ctor(world, component, callbacks, dst_entity, src_entity, 
+    callbacks->move_ctor(world, component, callbacks, dst_entity, src_entity,
         dst_ptr, src_ptr, size, count, ctx);
     callbacks->dtor(world, component, src_entity, src_ptr, size, count, ctx);
 }
@@ -31058,7 +31058,7 @@ void default_move(
     const ecs_entity_t *src_entity, void *dst_ptr, void *src_ptr, size_t size,
     int32_t count, void *ctx)
 {
-    callbacks->move(world, component, dst_entity, src_entity, 
+    callbacks->move(world, component, dst_entity, src_entity,
         dst_ptr, src_ptr, size, count, ctx);
 }
 
@@ -31089,7 +31089,7 @@ void default_move_w_dtor(
     /* If a component has a move, the move will take care of memcpying the data
      * and destroying any data in dst. Because this is not a trivial move, the
      * src component must also be destructed. */
-    callbacks->move(world, component, dst_entity, src_entity, 
+    callbacks->move(world, component, dst_entity, src_entity,
         dst_ptr, src_ptr, size, count, ctx);
     callbacks->dtor(world, component, src_entity, src_ptr, size, count, ctx);
 }
@@ -31115,13 +31115,13 @@ void ecs_set_component_actions_w_id(
 
     if (c_info->lifecycle_set) {
         ecs_assert(c_info->component == component, ECS_INTERNAL_ERROR, NULL);
-        ecs_check(!lifecycle->ctor || c_info->lifecycle.ctor == lifecycle->ctor, 
+        ecs_check(!lifecycle->ctor || c_info->lifecycle.ctor == lifecycle->ctor,
             ECS_INCONSISTENT_COMPONENT_ACTION, NULL);
-        ecs_check(!lifecycle->dtor || c_info->lifecycle.dtor == lifecycle->dtor, 
+        ecs_check(!lifecycle->dtor || c_info->lifecycle.dtor == lifecycle->dtor,
             ECS_INCONSISTENT_COMPONENT_ACTION, NULL);
-        ecs_check(!lifecycle->copy || c_info->lifecycle.copy == lifecycle->copy, 
+        ecs_check(!lifecycle->copy || c_info->lifecycle.copy == lifecycle->copy,
             ECS_INCONSISTENT_COMPONENT_ACTION, NULL);
-        ecs_check(!lifecycle->move || c_info->lifecycle.move == lifecycle->move, 
+        ecs_check(!lifecycle->move || c_info->lifecycle.move == lifecycle->move,
             ECS_INCONSISTENT_COMPONENT_ACTION, NULL);
 
         if (!c_info->lifecycle.on_set) {
@@ -31134,14 +31134,14 @@ void ecs_set_component_actions_w_id(
         c_info->size = component_ptr->size;
         c_info->alignment = component_ptr->alignment;
 
-        /* If no constructor is set, invoking any of the other lifecycle actions 
-         * is not safe as they will potentially access uninitialized memory. For 
-         * ease of use, if no constructor is specified, set a default one that 
+        /* If no constructor is set, invoking any of the other lifecycle actions
+         * is not safe as they will potentially access uninitialized memory. For
+         * ease of use, if no constructor is specified, set a default one that
          * initializes the component to 0. */
-        if (!lifecycle->ctor && 
-            (lifecycle->dtor || lifecycle->copy || lifecycle->move)) 
+        if (!lifecycle->ctor &&
+            (lifecycle->dtor || lifecycle->copy || lifecycle->move))
         {
-            c_info->lifecycle.ctor = ecs_default_ctor;   
+            c_info->lifecycle.ctor = ecs_default_ctor;
         }
 
         /* Set default copy ctor, move ctor and merge */
@@ -31157,21 +31157,21 @@ void ecs_set_component_actions_w_id(
             if (lifecycle->move) {
                 if (lifecycle->dtor) {
                     if (lifecycle->move_ctor) {
-                        /* If an explicit move ctor has been set, use callback 
+                        /* If an explicit move ctor has been set, use callback
                          * that uses the move ctor vs. using a ctor+move */
-                        c_info->lifecycle.ctor_move_dtor = 
+                        c_info->lifecycle.ctor_move_dtor =
                             default_move_ctor_w_dtor;
                     } else {
                         /* If no explicit move_ctor has been set, use
                          * combination of ctor + move + dtor */
-                        c_info->lifecycle.ctor_move_dtor = 
+                        c_info->lifecycle.ctor_move_dtor =
                             default_ctor_w_move_w_dtor;
                     }
                 } else {
                     /* If no dtor has been set, this is just a move ctor */
-                    c_info->lifecycle.ctor_move_dtor = 
+                    c_info->lifecycle.ctor_move_dtor =
                         c_info->lifecycle.move_ctor;
-                }            
+                }
             }
         }
 
@@ -31193,7 +31193,7 @@ void ecs_set_component_actions_w_id(
          * table that uses the component as itself, as predicate or as object.
          * The latter is what makes selecting the right set of tables complex,
          * as it depends on the predicate of a pair whether the object is used
-         * as the component type or not. 
+         * as the component type or not.
          * A more selective approach requires a more expressive notification
          * framework. */
         flecs_notify_tables(world, 0, &(ecs_table_event_t) {
@@ -31211,7 +31211,7 @@ bool ecs_component_has_actions(
 {
     ecs_check(world != NULL, ECS_INVALID_PARAMETER, NULL);
     ecs_check(component != 0, ECS_INVALID_PARAMETER, NULL);
-    
+
     world = ecs_get_world(world);
     const ecs_type_info_t *c_info = flecs_get_c_info(world, component);
     return (c_info != NULL) && c_info->lifecycle_set;
@@ -31227,7 +31227,7 @@ void ecs_atfini(
     ecs_poly_assert(world, ecs_world_t);
     ecs_check(action != NULL, ECS_INVALID_PARAMETER, NULL);
 
-    ecs_action_elem_t *elem = ecs_vector_add(&world->fini_actions, 
+    ecs_action_elem_t *elem = ecs_vector_add(&world->fini_actions,
         ecs_action_elem_t);
     ecs_assert(elem != NULL, ECS_INTERNAL_ERROR, NULL);
 
@@ -31244,14 +31244,14 @@ void ecs_run_post_frame(
 {
     ecs_check(world != NULL, ECS_INVALID_PARAMETER, NULL);
     ecs_check(action != NULL, ECS_INVALID_PARAMETER, NULL);
-    
+
     ecs_stage_t *stage = flecs_stage_from_world(&world);
-    ecs_action_elem_t *elem = ecs_vector_add(&stage->post_frame_actions, 
+    ecs_action_elem_t *elem = ecs_vector_add(&stage->post_frame_actions,
         ecs_action_elem_t);
     ecs_assert(elem != NULL, ECS_INTERNAL_ERROR, NULL);
 
     elem->action = action;
-    elem->ctx = ctx; 
+    elem->ctx = ctx;
 error:
     return;
 }
@@ -31345,7 +31345,7 @@ void fini_aliases(
     while (flecs_hashmap_next_w_key(&it, ecs_hashed_string_t, &key, ecs_entity_t)) {
         ecs_os_free(key->value);
     }
-    
+
     flecs_hashmap_free(*map);
 }
 
@@ -31379,7 +31379,7 @@ int ecs_fini(
     /* Run UnSet/OnRemove actions for components while the store is still
      * unmodified by cleanup. */
     fini_unset_tables(world);
-    
+
     /* Run fini actions (simple callbacks ran when world is deleted) before
      * destroying the storage */
     fini_actions(world);
@@ -31396,7 +31396,7 @@ int ecs_fini(
      * validity checks on entity ids, even though after store cleanup the index
      * will be empty, so all entity ids are invalid. */
     flecs_sparse_free(world->store.entity_index);
-    
+
     if (world->locking_enabled) {
         ecs_os_mutex_free(world->mutex);
     }
@@ -31418,9 +31418,9 @@ int ecs_fini(
     flecs_sparse_free(world->triggers);
 
     fini_aliases(&world->aliases);
-    
+
     fini_aliases(&world->symbols);
-    
+
     fini_misc(world);
 
     ecs_os_enable_high_timer_resolution(false);
@@ -31428,7 +31428,7 @@ int ecs_fini(
     /* End of the world */
     ecs_poly_free(world, ecs_world_t);
 
-    ecs_os_fini(); 
+    ecs_os_fini();
 
     ecs_trace("world destroyed, bye!");
     ecs_log_pop();
@@ -31447,7 +31447,7 @@ void ecs_dim(
 void flecs_eval_component_monitors(
     ecs_world_t *world)
 {
-    ecs_poly_assert(world, ecs_world_t);    
+    ecs_poly_assert(world, ecs_world_t);
     eval_component_monitor(world);
 }
 
@@ -31493,7 +31493,7 @@ error:
 void* ecs_get_context(
     const ecs_world_t *world)
 {
-    ecs_check(world != NULL, ECS_INVALID_PARAMETER, NULL);    
+    ecs_check(world != NULL, ECS_INVALID_PARAMETER, NULL);
     world = ecs_get_world(world);
     return world->context;
 error:
@@ -31515,7 +31515,7 @@ void ecs_set_entity_range(
 {
     ecs_poly_assert(world, ecs_world_t);
     ecs_check(!id_end || id_end > id_start, ECS_INVALID_PARAMETER, NULL);
-    ecs_check(!id_end || id_end > world->stats.last_id, 
+    ecs_check(!id_end || id_end > world->stats.last_id,
         ECS_INVALID_PARAMETER, NULL);
 
     if (world->stats.last_id < id_start) {
@@ -31532,7 +31532,7 @@ bool ecs_enable_range_check(
     ecs_world_t *world,
     bool enable)
 {
-    ecs_poly_assert(world, ecs_world_t);    
+    ecs_poly_assert(world, ecs_world_t);
     bool old_value = world->range_check_enabled;
     world->range_check_enabled = enable;
     return old_value;
@@ -31579,7 +31579,7 @@ bool ecs_enable_locking(
 void ecs_lock(
     ecs_world_t *world)
 {
-    ecs_poly_assert(world, ecs_world_t);    
+    ecs_poly_assert(world, ecs_world_t);
     ecs_assert(world->locking_enabled, ECS_INVALID_PARAMETER, NULL);
     ecs_os_mutex_lock(world->mutex);
 }
@@ -31587,7 +31587,7 @@ void ecs_lock(
 void ecs_unlock(
     ecs_world_t *world)
 {
-    ecs_poly_assert(world, ecs_world_t);    
+    ecs_poly_assert(world, ecs_world_t);
     ecs_assert(world->locking_enabled, ECS_INVALID_PARAMETER, NULL);
     ecs_os_mutex_unlock(world->mutex);
 }
@@ -31604,7 +31604,7 @@ void ecs_begin_wait(
 void ecs_end_wait(
     ecs_world_t *world)
 {
-    ecs_poly_assert(world, ecs_world_t);    
+    ecs_poly_assert(world, ecs_world_t);
     ecs_assert(world->locking_enabled, ECS_INVALID_PARAMETER, NULL);
     ecs_os_mutex_unlock(world->thr_sync);
 }
@@ -31613,7 +31613,7 @@ const ecs_type_info_t* flecs_get_c_info(
     const ecs_world_t *world,
     ecs_entity_t component)
 {
-    ecs_poly_assert(world, ecs_world_t);   
+    ecs_poly_assert(world, ecs_world_t);
 
     ecs_assert(component != 0, ECS_INTERNAL_ERROR, NULL);
     ecs_assert(!(component & ECS_ROLE_MASK), ECS_INTERNAL_ERROR, NULL);
@@ -31625,14 +31625,14 @@ ecs_type_info_t* flecs_get_or_create_c_info(
     ecs_world_t *world,
     ecs_entity_t component)
 {
-    ecs_poly_assert(world, ecs_world_t);  
+    ecs_poly_assert(world, ecs_world_t);
 
     const ecs_type_info_t *c_info = flecs_get_c_info(world, component);
     ecs_type_info_t *c_info_mut = NULL;
     if (!c_info) {
         c_info_mut = flecs_sparse_ensure(
             world->type_info, ecs_type_info_t, component);
-        ecs_assert(c_info_mut != NULL, ECS_INTERNAL_ERROR, NULL);         
+        ecs_assert(c_info_mut != NULL, ECS_INTERNAL_ERROR, NULL);
     } else {
         c_info_mut = (ecs_type_info_t*)c_info;
     }
@@ -31645,7 +31645,7 @@ FLECS_FLOAT insert_sleep(
     ecs_world_t *world,
     ecs_time_t *stop)
 {
-    ecs_poly_assert(world, ecs_world_t);  
+    ecs_poly_assert(world, ecs_world_t);
 
     ecs_time_t start = *stop;
     FLECS_FLOAT delta_time = (FLECS_FLOAT)ecs_time_measure(stop);
@@ -31654,7 +31654,7 @@ FLECS_FLOAT insert_sleep(
         return delta_time;
     }
 
-    FLECS_FLOAT target_delta_time = 
+    FLECS_FLOAT target_delta_time =
         ((FLECS_FLOAT)1.0 / (FLECS_FLOAT)world->stats.target_fps);
 
     /* Calculate the time we need to sleep by taking the measured delta from the
@@ -31674,7 +31674,7 @@ FLECS_FLOAT insert_sleep(
 
         ecs_time_t now = start;
         delta_time = (FLECS_FLOAT)ecs_time_measure(&now);
-    } while ((target_delta_time - delta_time) > 
+    } while ((target_delta_time - delta_time) >
         (sleep_time / (FLECS_FLOAT)2.0));
 
     return delta_time;
@@ -31685,14 +31685,14 @@ FLECS_FLOAT start_measure_frame(
     ecs_world_t *world,
     FLECS_FLOAT user_delta_time)
 {
-    ecs_poly_assert(world, ecs_world_t);  
+    ecs_poly_assert(world, ecs_world_t);
 
     FLECS_FLOAT delta_time = 0;
 
     if (world->measure_frame_time || (user_delta_time == 0)) {
         ecs_time_t t = world->frame_start_time;
         do {
-            if (world->frame_start_time.nanosec || world->frame_start_time.sec){ 
+            if (world->frame_start_time.nanosec || world->frame_start_time.sec){
                 delta_time = insert_sleep(world, &t);
 
                 ecs_time_measure(&t);
@@ -31702,14 +31702,14 @@ FLECS_FLOAT start_measure_frame(
                     delta_time = (FLECS_FLOAT)1.0 / world->stats.target_fps;
                 } else {
                     /* Best guess */
-                    delta_time = (FLECS_FLOAT)1.0 / (FLECS_FLOAT)60.0; 
+                    delta_time = (FLECS_FLOAT)1.0 / (FLECS_FLOAT)60.0;
                 }
             }
-        
+
         /* Keep trying while delta_time is zero */
         } while (delta_time == 0);
 
-        world->frame_start_time = t;  
+        world->frame_start_time = t;
 
         /* Keep track of total time passed in world */
         world->stats.world_time_total_raw += (FLECS_FLOAT)delta_time;
@@ -31722,7 +31722,7 @@ static
 void stop_measure_frame(
     ecs_world_t* world)
 {
-    ecs_poly_assert(world, ecs_world_t);  
+    ecs_poly_assert(world, ecs_world_t);
 
     if (world->measure_frame_time) {
         ecs_time_t t = world->frame_start_time;
@@ -31736,7 +31736,7 @@ FLECS_FLOAT ecs_frame_begin(
 {
     ecs_poly_assert(world, ecs_world_t);
     ecs_check(world->is_readonly == false, ECS_INVALID_OPERATION, NULL);
-    ecs_check(user_delta_time != 0 || ecs_os_has_time(), 
+    ecs_check(user_delta_time != 0 || ecs_os_has_time(),
         ECS_MISSING_OS_API, "get_time");
 
     if (world->locking_enabled) {
@@ -31747,7 +31747,7 @@ FLECS_FLOAT ecs_frame_begin(
     FLECS_FLOAT delta_time = start_measure_frame(world, user_delta_time);
     if (user_delta_time == 0) {
         user_delta_time = delta_time;
-    }  
+    }
 
     world->stats.delta_time_raw = user_delta_time;
     world->stats.delta_time = user_delta_time * world->stats.time_scale;
@@ -31772,7 +31772,7 @@ void ecs_frame_end(
 
     ecs_vector_each(world->worker_stages, ecs_stage_t, stage, {
         flecs_stage_merge_post_frame(world, stage);
-    });        
+    });
 
     if (world->locking_enabled) {
         ecs_unlock(world);
@@ -31798,7 +31798,7 @@ void flecs_notify_queries(
     ecs_world_t *world,
     ecs_query_event_t *event)
 {
-    ecs_poly_assert(world, ecs_world_t); 
+    ecs_poly_assert(world, ecs_world_t);
 
     int32_t i, count = flecs_sparse_count(world->queries);
     for (i = 0; i < count; i ++) {
@@ -31807,16 +31807,16 @@ void flecs_notify_queries(
         if (query->flags & EcsQueryIsSubquery) {
             continue;
         }
-        
+
         flecs_query_notify(world, query, event);
-    }    
+    }
 }
 
 void flecs_delete_table(
     ecs_world_t *world,
     ecs_table_t *table)
 {
-    ecs_poly_assert(world, ecs_world_t); 
+    ecs_poly_assert(world, ecs_world_t);
 
     /* Notify queries that table is to be removed */
     flecs_notify_queries(
@@ -31905,7 +31905,7 @@ void set_empty(
 
     ecs_id_record_t *idr = flecs_get_id_record(world, id);
     if (idr) {
-        ecs_table_cache_set_empty(&idr->cache, table, 
+        ecs_table_cache_set_empty(&idr->cache, table,
             ecs_table_count(table) == 0);
     }
 }
@@ -31920,21 +31920,21 @@ void for_each_id(
     int32_t i, count = ecs_vector_count(table->type);
     ecs_id_t *ids = ecs_vector_first(table->type, ecs_id_t);
     bool has_childof = false;
-    
+
     for (i = 0; i < count; i ++) {
         ecs_entity_t id = ids[i];
 
         /* This check ensures that legacy CHILDOF works */
         if (ECS_HAS_RELATION(id, EcsChildOf)) {
             has_childof = true;
-        } 
+        }
 
         action(world, table, ecs_strip_generation(id), i);
         action(world, table, EcsWildcard, i);
 
         if (ECS_HAS_ROLE(id, PAIR)) {
             ecs_entity_t pred_w_wildcard = ecs_pair(
-                ECS_PAIR_RELATION(id), EcsWildcard);       
+                ECS_PAIR_RELATION(id), EcsWildcard);
             action(world, table, pred_w_wildcard, i);
 
             ecs_entity_t obj_w_wildcard = ecs_pair(
@@ -31961,7 +31961,7 @@ void for_each_id(
 
             if (set_watch) {
                 flecs_add_flag(world, id, ECS_FLAG_OBSERVED_ID);
-            }            
+            }
         }
     }
 
@@ -32002,7 +32002,7 @@ ecs_id_record_t* flecs_ensure_id_record(
     ecs_world_t *world,
     ecs_id_t id)
 {
-    ecs_id_record_t *idr = ecs_map_ensure(world->id_index, ecs_id_record_t, 
+    ecs_id_record_t *idr = ecs_map_ensure(world->id_index, ecs_id_record_t,
         ecs_strip_generation(id));
 
     if (!ecs_table_cache_is_initialized(&idr->cache)) {
@@ -32016,7 +32016,7 @@ ecs_id_record_t* flecs_get_id_record(
     const ecs_world_t *world,
     ecs_id_t id)
 {
-    return ecs_map_get(world->id_index, ecs_id_record_t, 
+    return ecs_map_get(world->id_index, ecs_id_record_t,
         ecs_strip_generation(id));
 }
 
@@ -32065,12 +32065,12 @@ void flecs_register_remove_ref(
 
 void flecs_clear_id_record(
     ecs_world_t *world,
-    ecs_id_t id)    
+    ecs_id_t id)
 {
     if (world->is_fini) {
         return;
     }
-    
+
     ecs_id_record_t *idr_ptr = flecs_get_id_record(world, id);
     if (!idr_ptr) {
         return;
@@ -32092,7 +32092,7 @@ void flecs_clear_id_record(
     it = ecs_map_iter(idr.remove_refs);
     while ((table = ecs_map_next_ptr(&it, ecs_table_t*, NULL))) {
         flecs_table_clear_remove_edge(table, id);
-    }    
+    }
 
     ecs_map_free(idr.add_refs);
     ecs_map_free(idr.remove_refs);
@@ -32158,7 +32158,7 @@ void flecs_observable_fini(
     int32_t i, count = flecs_sparse_count(triggers);
 
     for (i = 0; i < count; i ++) {
-        ecs_event_record_t *et = 
+        ecs_event_record_t *et =
             ecs_sparse_get_dense(triggers, ecs_event_record_t, i);
         ecs_assert(et != NULL, ECS_INTERNAL_ERROR, NULL);
 
@@ -32275,7 +32275,7 @@ void ecs_emit(
     if (!desc->relation) {
         flecs_triggers_notify(&it, observable, ids, event);
     } else {
-        flecs_set_triggers_notify(&it, observable, ids, event, 
+        flecs_set_triggers_notify(&it, observable, ids, event,
             ecs_pair(relation, EcsWildcard));
     }
 
@@ -32294,12 +32294,12 @@ void ecs_emit(
             uint32_t flags = ECS_RECORD_TO_ROW_FLAGS(recs[i]->row);
             if (flags & ECS_FLAG_OBSERVED_ACYCLIC) {
                 notify_subset(world, &it, observable, ecs_vector_first(
-                    table->storage.entities, ecs_entity_t)[row + i], 
+                    table->storage.entities, ecs_entity_t)[row + i],
                         event, ids);
             }
         }
     }
-    
+
 error:
     return;
 }
@@ -32350,12 +32350,12 @@ int finalize_term_set(
         }
     } else {
         if (identifier->set.min_depth > 0) {
-            term_error(world, term, name, 
+            term_error(world, term, name,
                 "min depth cannnot be non-zero for Self term");
             return -1;
         }
         if (identifier->set.max_depth > 1) {
-            term_error(world, term, name, 
+            term_error(world, term, name,
                 "max depth cannnot be larger than 1 for Self term");
             return -1;
         }
@@ -32363,8 +32363,8 @@ int finalize_term_set(
         identifier->set.max_depth = 1;
     }
 
-    if ((identifier->set.mask != EcsNothing) && 
-        (identifier->set.mask & EcsNothing)) 
+    if ((identifier->set.mask != EcsNothing) &&
+        (identifier->set.mask & EcsNothing))
     {
         term_error(world, term, name, "invalid Nothing in set mask");
         return -1;
@@ -32419,8 +32419,8 @@ int finalize_term_var(
         }
     }
 
-    if ((identifier->set.mask == EcsNothing) && 
-        (identifier->var != EcsVarDefault)) 
+    if ((identifier->set.mask == EcsNothing) &&
+        (identifier->var != EcsVarDefault))
     {
         term_error(world, term, name, "Invalid Nothing with entity");
         return -1;
@@ -32447,7 +32447,7 @@ int finalize_term_identifier(
 
 static
 bool term_can_inherit(
-    ecs_term_t *term) 
+    ecs_term_t *term)
 {
     /* Hardcoded components that can't be inherited. TODO: replace with
      * relationship property. */
@@ -32466,8 +32466,8 @@ ecs_entity_t term_id_entity(
     const ecs_world_t *world,
     ecs_term_id_t *term_id)
 {
-    if (term_id->entity && term_id->entity != EcsThis && 
-        term_id->entity != EcsWildcard && term_id->entity != EcsAny) 
+    if (term_id->entity && term_id->entity != EcsThis &&
+        term_id->entity != EcsWildcard && term_id->entity != EcsAny)
     {
         if (!(term_id->entity & ECS_ROLE_MASK)) {
             return term_id->entity;
@@ -32475,9 +32475,9 @@ ecs_entity_t term_id_entity(
             return 0;
         }
     } else if (term_id->name) {
-        if (term_id->var == EcsVarIsEntity || 
-           (term_id->var == EcsVarDefault && 
-            !ecs_identifier_is_var(term_id->name))) 
+        if (term_id->var == EcsVarIsEntity ||
+           (term_id->var == EcsVarDefault &&
+            !ecs_identifier_is_var(term_id->name)))
         {
             ecs_entity_t e = ecs_lookup_fullpath(world, term_id->name);
             if (e != EcsWildcard && e != EcsThis && e != EcsAny) {
@@ -32527,7 +32527,7 @@ int finalize_term_identifiers(
     ecs_term_t *term,
     const char *name)
 {
-    /* By default select subsets for predicates. For example, when the term 
+    /* By default select subsets for predicates. For example, when the term
      * matches "Tree", also include "Oak", "Pine", "Elm". */
     if (term->pred.set.mask == EcsDefaultSet) {
         ecs_entity_t e = term_id_entity(world, &term->pred);
@@ -32562,24 +32562,24 @@ int finalize_term_identifiers(
     }
 
     if (term->pred.set.mask & EcsNothing) {
-        term_error(world, term, name, 
+        term_error(world, term, name,
             "invalid Nothing value for predicate set mask");
         return -1;
     }
 
     if (term->obj.set.mask & EcsNothing) {
-        term_error(world, term, name, 
+        term_error(world, term, name,
             "invalid Nothing value for object set mask");
         return -1;
     }
 
-    if (!(term->subj.set.mask & EcsNothing) && 
-        !term->subj.entity && 
-        term->subj.var == EcsVarIsEntity) 
+    if (!(term->subj.set.mask & EcsNothing) &&
+        !term->subj.entity &&
+        term->subj.var == EcsVarIsEntity)
     {
         term->subj.entity = EcsThis;
     }
-    
+
     if (entity_is_var(term->pred.entity)) {
         term->pred.var = EcsVarIsVariable;
     }
@@ -32621,7 +32621,7 @@ int finalize_term_id(
 
     if (ECS_HAS_ROLE(pred, PAIR)) {
         if (obj) {
-            term_error(world, term, name, 
+            term_error(world, term, name,
                 "cannot set term.pred to a pair and term.obj at the same time");
             return -1;
         }
@@ -32704,7 +32704,7 @@ int populate_from_term_id(
     ecs_entity_t term_pred = entity_from_identifier(&term->pred);
     if (term_pred) {
         if (term_pred != pred) {
-            term_error(world, term, name, 
+            term_error(world, term, name,
                 "mismatch between term.id and term.pred");
             return -1;
         }
@@ -32718,7 +32718,7 @@ int populate_from_term_id(
     ecs_entity_t term_obj = entity_from_identifier(&term->obj);
     if (term_obj) {
         if (ecs_entity_t_lo(term_obj) != obj) {
-            term_error(world, term, name, 
+            term_error(world, term, name,
                 "mismatch between term.id and term.obj");
             return -1;
         }
@@ -32745,13 +32745,13 @@ int verify_term_consistency(
     bool wildcard = pred == EcsWildcard || obj == EcsWildcard;
 
     if (obj && (!role || (role != ECS_PAIR && role != ECS_CASE))) {
-        term_error(world, term, name, 
+        term_error(world, term, name,
             "invalid role for term with pair (expected ECS_PAIR)");
         return -1;
     }
 
     if (role == ECS_CASE && !obj) {
-        term_error(world, term, name, 
+        term_error(world, term, name,
             "missing object for term with ECS_CASE role");
         return -1;
     }
@@ -32775,10 +32775,10 @@ int verify_term_consistency(
         if (!wildcard) {
             role = ECS_ROLE_MASK & id;
             if (id != (role | ecs_entity_t_comb(
-                term->obj.entity, term->pred.entity))) 
+                term->obj.entity, term->pred.entity)))
             {
                 char *id_str = ecs_id_str(world, ecs_pair(pred, obj));
-                term_error(world, term, name, 
+                term_error(world, term, name,
                     "term id does not match pred/obj (%s)", id_str);
                 ecs_os_free(id_str);
                 return -1;
@@ -32809,7 +32809,7 @@ int verify_term_consistency(
                 }
 
                 if (is_same && ecs_has_id(world, term->pred.entity, EcsAcyclic)
-                    && !ecs_has_id(world, term->pred.entity, EcsReflexive)) 
+                    && !ecs_has_id(world, term->pred.entity, EcsReflexive))
                 {
                     char *pred_str = ecs_get_fullpath(world, term->pred.entity);
                     term_error(world, term, name, "term with acyclic relation"
@@ -32874,7 +32874,7 @@ bool ecs_id_match(
 
         ecs_check(pattern_rel != 0, ECS_INVALID_PARAMETER, NULL);
         ecs_check(pattern_obj != 0, ECS_INVALID_PARAMETER, NULL);
-        
+
         if (pattern_rel == EcsWildcard) {
             if (pattern_obj == EcsWildcard || pattern_obj == id_obj) {
                 return true;
@@ -33137,7 +33137,7 @@ void filter_iter_init(
 int ecs_filter_init(
     const ecs_world_t *stage,
     ecs_filter_t *filter_out,
-    const ecs_filter_desc_t *desc)    
+    const ecs_filter_desc_t *desc)
 {
     ecs_filter_t f;
     ecs_poly_init(&f, ecs_filter_t);
@@ -33200,15 +33200,15 @@ int ecs_filter_init(
             if (!ecs_term_is_initialized(&term)) {
                 break;
             }
-            
+
             if (term_count == buffer_count) {
                 buffer_count = buffer_count ? buffer_count * 2 : 8;
-                terms = ecs_os_realloc(terms, 
+                terms = ecs_os_realloc(terms,
                     buffer_count * ECS_SIZEOF(ecs_term_t));
             }
 
             /* Check for identifiers that have a name that starts with _. If the
-             * variable kind is left to Default, the kind should be set to 
+             * variable kind is left to Default, the kind should be set to
              * variable and the _ prefix should be removed. */
             finalize_term_vars(world, &term, name, true);
 
@@ -33251,7 +33251,7 @@ int ecs_filter_init(
 
         for (i = 0; i < term_count; i ++) {
             filter_out->terms[i] = ecs_term_move(&terms[i]);
-        }        
+        }
     } else {
         filter_out->terms = NULL;
     }
@@ -33259,7 +33259,7 @@ int ecs_filter_init(
     filter_out->name = ecs_os_strdup(desc->name);
     filter_out->expr = ecs_os_strdup(desc->expr);
 
-    ecs_assert(!filter_out->term_cache_used || 
+    ecs_assert(!filter_out->term_cache_used ||
         filter_out->terms == filter_out->term_cache,
         ECS_INTERNAL_ERROR, NULL);
 
@@ -33282,7 +33282,7 @@ error:
 
 void ecs_filter_copy(
     ecs_filter_t *dst,
-    const ecs_filter_t *src)   
+    const ecs_filter_t *src)
 {
     if (src) {
         *dst = *src;
@@ -33306,7 +33306,7 @@ void ecs_filter_copy(
 
 void ecs_filter_move(
     ecs_filter_t *dst,
-    ecs_filter_t *src)   
+    ecs_filter_t *src)
 {
     if (src) {
         *dst = *src;
@@ -33325,7 +33325,7 @@ void ecs_filter_move(
 }
 
 void ecs_filter_fini(
-    ecs_filter_t *filter) 
+    ecs_filter_t *filter)
 {
     if (filter->terms) {
         int i, count = filter->term_count;
@@ -33432,7 +33432,7 @@ void term_str_w_strbuf(
             ecs_strbuf_appendstr(buf, str);
             ecs_os_free(str);
         } else if (pred_set) {
-            filter_str_add_id(world, buf, &term->pred, false, def_pred_mask);   
+            filter_str_add_id(world, buf, &term->pred, false, def_pred_mask);
         }
     } else {
         filter_str_add_id(world, buf, &term->pred, false, def_pred_mask);
@@ -33530,7 +33530,7 @@ bool flecs_n_term_match_table(
     bool first)
 {
     (void)column_out;
-    
+
     ecs_entity_t type_id = term->id;
     ecs_oper_kind_t oper = term->oper;
 
@@ -33544,7 +33544,7 @@ bool flecs_n_term_match_table(
 
     for (i = 0; i < count; i ++) {
         temp.id = ids[i];
-        bool result = flecs_term_match_table(world, &temp, table, type, id_out, 
+        bool result = flecs_term_match_table(world, &temp, table, type, id_out,
             0, subject_out, match_index_out, first);
         if (!result && oper == EcsAndFrom) {
             return false;
@@ -33589,7 +33589,7 @@ bool flecs_term_match_table(
     }
 
     if (oper == EcsAndFrom || oper == EcsOrFrom) {
-        return flecs_n_term_match_table(world, term, table, type, id_out, column_out, 
+        return flecs_n_term_match_table(world, term, table, type, id_out, column_out,
             subject_out, match_index_out, first);
     }
 
@@ -33629,7 +33629,7 @@ bool flecs_term_match_table(
     /* Find location, source and id of match in table type */
     ecs_table_record_t *tr = 0;
     column = ecs_search_relation(world, match_table,
-        column, actual_match_id(id), subj->set.relation, subj->set.min_depth, 
+        column, actual_match_id(id), subj->set.relation, subj->set.min_depth,
         subj->set.max_depth, &source, id_out, &tr);
 
     if (tr && match_index_out) {
@@ -33667,7 +33667,7 @@ bool flecs_term_match_table(
         if (column >= 0) {
             column ++;
             if (source != 0) {
-                column *= -1; 
+                column *= -1;
             }
             column_out[0] = column;
         } else {
@@ -33756,11 +33756,11 @@ bool flecs_filter_match_table(
         }
 
         int32_t match_index = 0;
-        bool result = flecs_term_match_table(world, term, match_table, 
+        bool result = flecs_term_match_table(world, term, match_table,
             match_type,
-            ids ? &ids[t_i] : NULL, 
-            columns ? &columns[t_i] : NULL, 
-            subjects ? &subjects[t_i] : NULL, 
+            ids ? &ids[t_i] : NULL,
+            columns ? &columns[t_i] : NULL,
+            subjects ? &subjects[t_i] : NULL,
             &match_index,
             first);
 
@@ -33810,18 +33810,18 @@ void term_iter_init(
     const ecs_world_t *world,
     ecs_term_t *term,
     ecs_term_iter_t *iter)
-{    
+{
     const ecs_term_id_t *subj = &term->subj;
 
     iter->term = *term;
 
     if (subj->set.mask == EcsDefaultSet || subj->set.mask & EcsSelf) {
-        iter->self_index = flecs_get_id_record(world, 
+        iter->self_index = flecs_get_id_record(world,
             actual_match_id(term->id));
     }
 
     if (subj->set.mask & EcsSuperSet) {
-        iter->set_index = flecs_get_id_record(world, 
+        iter->set_index = flecs_get_id_record(world,
             ecs_pair(subj->set.relation, EcsWildcard));
     }
 
@@ -33987,8 +33987,8 @@ bool term_iter_next(
             }
 
             /* Test if following the relation finds the id */
-            int32_t index = ecs_search_relation(world, table, 0, 
-                term->id, subj->set.relation, subj->set.min_depth, 
+            int32_t index = ecs_search_relation(world, table, 0,
+                term->id, subj->set.relation, subj->set.min_depth,
                 subj->set.max_depth, &source, &iter->id, NULL);
 
             if (index == -1) {
@@ -34057,7 +34057,7 @@ bool ecs_term_next(
         table = iter->table;
 
         /* Source must either be 0 (EcsThis) or nonzero in case of substitution */
-        ecs_assert(iter->subject || iter->cur != iter->set_index, 
+        ecs_assert(iter->subject || iter->cur != iter->set_index,
             ECS_INTERNAL_ERROR, NULL);
         ecs_assert(iter->table != NULL, ECS_INTERNAL_ERROR, NULL);
     }
@@ -34088,8 +34088,8 @@ const ecs_filter_t* init_filter_iter(
 
         ecs_filter_finalize(world, &iter->filter);
 
-        ecs_assert(!filter->term_cache_used || 
-            filter->terms == filter->term_cache, ECS_INTERNAL_ERROR, NULL);    
+        ecs_assert(!filter->term_cache_used ||
+            filter->terms == filter->term_cache, ECS_INTERNAL_ERROR, NULL);
     } else {
         ecs_filter_init(world, &iter->filter, &(ecs_filter_desc_t) {
             .terms = {{ .id = EcsWildcard }}
@@ -34145,10 +34145,10 @@ ecs_iter_t ecs_filter_iter(
                 continue;
             }
 
-            ecs_id_record_t *idr = flecs_get_id_record(world,   
+            ecs_id_record_t *idr = flecs_get_id_record(world,
                 actual_match_id(id));
             if (!idr) {
-                /* If one of the terms does not match with any data, iterator 
+                /* If one of the terms does not match with any data, iterator
                  * should not return anything */
                 term_iter_init_no_data(&iter->term_iter);
                 return it;
@@ -34256,7 +34256,7 @@ bool ecs_filter_next_instanced(
 
     if (chain_it) {
         ecs_assert(kind == EcsIterEvalChain, ECS_INVALID_PARAMETER, NULL);
-        
+
         ecs_iter_next_action_t next = chain_it->next;
         do {
             if (!next(chain_it)) {
@@ -34265,7 +34265,7 @@ bool ecs_filter_next_instanced(
 
             table = chain_it->table;
             match = flecs_filter_match_table(world, filter, table,
-                it->ids, it->columns, it->subjects, it->match_indices, NULL, 
+                it->ids, it->columns, it->subjects, it->match_indices, NULL,
                 true, -1);
         } while (!match);
 
@@ -34282,13 +34282,13 @@ bool ecs_filter_next_instanced(
             if (first) {
                 if (kind != EcsIterEvalCondition) {
                     /* Find new match, starting with the leading term */
-                    if (!term_iter_next(world, term_iter, 
-                        filter->match_prefab, filter->match_disabled)) 
+                    if (!term_iter_next(world, term_iter,
+                        filter->match_prefab, filter->match_disabled))
                     {
                         goto done;
                     }
 
-                    ecs_assert(term_iter->match_count != 0, 
+                    ecs_assert(term_iter->match_count != 0,
                         ECS_INTERNAL_ERROR, NULL);
 
                     if (pivot_term == -1) {
@@ -34323,13 +34323,13 @@ bool ecs_filter_next_instanced(
                 /* Match the remainder of the terms */
                 match = flecs_filter_match_table(world, filter, table,
                     it->ids, it->columns, it->subjects,
-                    it->match_indices, &iter->matches_left, first, 
+                    it->match_indices, &iter->matches_left, first,
                     pivot_term);
                 if (!match) {
                     iter->matches_left = 0;
                     continue;
                 }
-                    
+
                 ecs_assert(iter->matches_left != 0, ECS_INTERNAL_ERROR, NULL);
             }
 
@@ -34337,7 +34337,7 @@ bool ecs_filter_next_instanced(
              * is matched more than once, iterate remaining matches */
             if (!first && (iter->matches_left > 0)) {
                 table = it->table;
-                
+
                 /* Find first term that still has matches left */
                 int32_t i, j, count = it->term_count;
                 for (i = count - 1; i >= 0; i --) {
@@ -34349,14 +34349,14 @@ bool ecs_filter_next_instanced(
 
                 /* Progress first term to next match (must be at least one) */
                 it->columns[i] ++;
-                flecs_term_match_table(world, &filter->terms[i], table, 
+                flecs_term_match_table(world, &filter->terms[i], table,
                     table->type, &it->ids[i], &it->columns[i], &it->subjects[i],
                     &it->match_indices[i], false);
 
                 /* Reset remaining terms (if any) to first match */
                 for (j = i + 1; j < count; j ++) {
-                    flecs_term_match_table(world, &filter->terms[j], table, 
-                        table->type, &it->ids[j], &it->columns[j], 
+                    flecs_term_match_table(world, &filter->terms[j], table,
+                        table->type, &it->ids[j], &it->columns[j],
                         &it->subjects[j], &it->match_indices[j], true);
                 }
             }
@@ -34379,7 +34379,7 @@ yield:
     it->offset = 0;
     flecs_iter_populate_data(world, it, table, 0, 0, it->ptrs, it->sizes);
     it->is_valid = true;
-    return true;    
+    return true;
 }
 
 
@@ -34456,7 +34456,7 @@ int32_t type_search_relation(
     int32_t count = ecs_vector_count(type);
 
     if (min_depth <= 0) {
-        int32_t r = type_offset_search(world, table, offset, id, ids, count, 
+        int32_t r = type_offset_search(world, table, offset, id, ids, count,
             id_out, tr_out);
         if (r != -1) {
             return r;
@@ -34464,7 +34464,7 @@ int32_t type_search_relation(
     }
 
     ecs_flags32_t flags = table->flags;
-    if ((flags & EcsTableHasPairs) && max_depth && rel && id != EcsPrefab && 
+    if ((flags & EcsTableHasPairs) && max_depth && rel && id != EcsPrefab &&
         id != EcsDisabled && ECS_PAIR_RELATION(id) != ecs_id(EcsIdentifier) &&
         ECS_PAIR_RELATION(id) != EcsChildOf)
     {
@@ -34486,7 +34486,7 @@ int32_t type_search_relation(
 
                     ecs_table_t *obj_table = rec->table;
                     if (obj_table) {
-                        r = type_search_relation(world, obj_table, 0, id, rel, 
+                        r = type_search_relation(world, obj_table, 0, id, rel,
                             min_depth - 1, max_depth - 1, subject_out, id_out,
                             tr_out);
                         if (r != -1) {
@@ -34498,7 +34498,7 @@ int32_t type_search_relation(
 
                         if (!is_a) {
                             r = type_search_relation(world, obj_table, 0, id,
-                                (uint32_t)EcsIsA, 1, INT_MAX, subject_out, id_out, 
+                                (uint32_t)EcsIsA, 1, INT_MAX, subject_out, id_out,
                                 tr_out);
                             if (r != -1) {
                                 if (subject_out && !subject_out[0]) {
@@ -34546,8 +34546,8 @@ int32_t ecs_search_relation(
 
     bool is_case = ECS_HAS_ROLE(id, CASE);
     id = is_case * (ECS_SWITCH | ECS_PAIR_RELATION(id)) + !is_case * id;
-    
-    return type_search_relation(world, table, offset, id, (uint32_t)rel, 
+
+    return type_search_relation(world, table, offset, id, (uint32_t)rel,
         min_depth, max_depth, subject_out, id_out, tr_out);
 }
 
@@ -34579,7 +34579,7 @@ int32_t ecs_search_offset(
     ecs_poly_assert(world, ecs_world_t);
     ecs_assert(table != NULL, ECS_INTERNAL_ERROR, NULL);
 
-    return type_search_relation(world, table, offset, id, 0, 
+    return type_search_relation(world, table, offset, id, 0,
         0, 0, 0, id_out, NULL);
 }
 
@@ -34631,7 +34631,7 @@ void observer_callback(ecs_iter_t *it) {
     /* Populate the column for the term that triggered. This will allow the
      * matching algorithm to pick the right column in case the term is a
      * wildcard matching multiple columns. */
-    user_it.columns[0] = 0;    
+    user_it.columns[0] = 0;
     user_it.columns[pivot_term] = it->columns[0];
 
     if (flecs_filter_match_table(world, &o->filter, table,
@@ -34644,8 +34644,8 @@ void observer_callback(ecs_iter_t *it) {
                 goto done;
             }
 
-            if (flecs_filter_match_table(world, &o->filter, prev_table, 
-                NULL, NULL, NULL, NULL, NULL, true, -1)) 
+            if (flecs_filter_match_table(world, &o->filter, prev_table,
+                NULL, NULL, NULL, NULL, NULL, true, -1))
             {
                 goto done;
             }
@@ -34662,7 +34662,7 @@ void observer_callback(ecs_iter_t *it) {
             }
         }
 
-        flecs_iter_populate_data(world, &user_it, 
+        flecs_iter_populate_data(world, &user_it,
             it->table, it->offset, it->count, user_it.ptrs, user_it.sizes);
 
         user_it.ids[it->term_index] = it->event_id;
@@ -34688,7 +34688,7 @@ ecs_entity_t ecs_observer_init(
     ecs_check(desc != NULL, ECS_INVALID_PARAMETER, NULL);
     ecs_check(desc->_canary == 0, ECS_INVALID_PARAMETER, NULL);
     ecs_check(!world->is_fini, ECS_INVALID_OPERATION, NULL);
-    ecs_check(desc->callback != NULL || desc->run != NULL, 
+    ecs_check(desc->callback != NULL || desc->run != NULL,
         ECS_INVALID_OPERATION, NULL);
 
     /* If entity is provided, create it */
@@ -34721,7 +34721,7 @@ ecs_entity_t ecs_observer_init(
         }
 
         /* Creating an observer with no terms has no effect */
-        ecs_assert(observer->filter.term_count != 0, 
+        ecs_assert(observer->filter.term_count != 0,
             ECS_INVALID_PARAMETER, NULL);
 
         int i;
@@ -34794,7 +34794,7 @@ ecs_entity_t ecs_observer_init(
                     tdesc.term.pred.name = NULL;
                     tdesc.term.pred.entity = ti_ids[ti];
                     tdesc.term.id = ti_ids[ti];
-                    ecs_entity_t t = ecs_vector_add(&observer->triggers, 
+                    ecs_entity_t t = ecs_vector_add(&observer->triggers,
                         ecs_entity_t)[0] = ecs_trigger_init(world, &tdesc);
                     if (!t) {
                         goto error;
@@ -34811,7 +34811,7 @@ ecs_entity_t ecs_observer_init(
         }
 
         if (desc->entity.name) {
-            ecs_trace("#[green]observer#[reset] %s created", 
+            ecs_trace("#[green]observer#[reset] %s created",
                 ecs_get_name(world, entity));
         }
     } else {
@@ -34826,13 +34826,13 @@ ecs_entity_t ecs_observer_init(
                 ((ecs_observer_t*)comp->observer)->ctx = desc->ctx;
             }
             if (desc->binding_ctx) {
-                ((ecs_observer_t*)comp->observer)->binding_ctx = 
+                ((ecs_observer_t*)comp->observer)->binding_ctx =
                     desc->binding_ctx;
             }
-        }        
+        }
     }
 
-    return entity; 
+    return entity;
 error:
     if (entity) {
         ecs_delete(world, entity);
@@ -34879,7 +34879,7 @@ void* ecs_get_observer_ctx(
         return o->observer->ctx;
     } else {
         return NULL;
-    }     
+    }
 }
 
 void* ecs_get_observer_binding_ctx(
@@ -34891,7 +34891,7 @@ void* ecs_get_observer_binding_ctx(
         return o->observer->binding_ctx;
     } else {
         return NULL;
-    }      
+    }
 }
 
 
@@ -34913,11 +34913,11 @@ int32_t move_table(
     ecs_assert(last_src_index >= 0, ECS_INTERNAL_ERROR, NULL);
 
     ecs_table_cache_hdr_t *elem = ecs_vector_last_t(src_array, size, 8);
-    
+
     /* The last table of the source array will be moved to the location of the
      * table to move, do some bookkeeping to keep things consistent. */
     if (last_src_index) {
-        int32_t *old_index_ptr = ecs_map_get(cache->index, 
+        int32_t *old_index_ptr = ecs_map_get(cache->index,
             int32_t, elem->table->id);
         ecs_assert(old_index_ptr != NULL, ECS_INTERNAL_ERROR, NULL);
 
@@ -34925,7 +34925,7 @@ int32_t move_table(
         if (!empty) {
             if (old_index >= 0) {
                 /* old_index should be negative if not empty, since
-                 * we're moving from the empty list to the non-empty list. 
+                 * we're moving from the empty list to the non-empty list.
                  * However, if the last table in the source array is also
                  * the table being moved, this can happen. */
                 ecs_assert(table == elem->table, ECS_INTERNAL_ERROR, NULL);
@@ -34959,7 +34959,7 @@ int32_t move_table(
         /* Make sure table is where we expect it */
         elem = ecs_vector_last_t(*dst_array, size, 8);
         ecs_assert(elem->table == table, ECS_INTERNAL_ERROR, NULL);
-        ecs_assert(ecs_vector_count(*dst_array) == (new_index + 1), 
+        ecs_assert(ecs_vector_count(*dst_array) == (new_index + 1),
             ECS_INTERNAL_ERROR, NULL);
         elem->empty = empty;
     } else {
@@ -34967,7 +34967,7 @@ int32_t move_table(
     }
 
     /* Ensure that src array has now one element less */
-    ecs_assert(ecs_vector_count(src_array) == last_src_index, 
+    ecs_assert(ecs_vector_count(src_array) == last_src_index,
         ECS_INTERNAL_ERROR, NULL);
 
     if (empty) {
@@ -34994,7 +34994,7 @@ void _ecs_table_cache_init(
     void(*free_payload)(ecs_poly_t*, void*))
 {
     ecs_assert(cache != NULL, ECS_INTERNAL_ERROR, NULL);
-    ecs_assert(size >= ECS_SIZEOF(ecs_table_cache_hdr_t), 
+    ecs_assert(size >= ECS_SIZEOF(ecs_table_cache_hdr_t),
         ECS_INTERNAL_ERROR, NULL);
     cache->index = NULL;
     cache->empty_tables = NULL;
@@ -35047,7 +35047,7 @@ void* _ecs_table_cache_insert(
     ecs_assert(cache != NULL, ECS_INTERNAL_ERROR, NULL);
     ecs_assert(size == cache->size, ECS_INTERNAL_ERROR, NULL);
 
-    ecs_assert(!table || (_ecs_table_cache_get(cache, size, table) == NULL), 
+    ecs_assert(!table || (_ecs_table_cache_get(cache, size, table) == NULL),
         ECS_INTERNAL_ERROR, NULL);
 
     int32_t index;
@@ -35072,7 +35072,7 @@ void* _ecs_table_cache_insert(
         ensure_index(cache);
         ecs_map_set(cache->index, table->id, &index);
     }
-    
+
     ecs_os_memset(result, 0, size);
     result->table = (ecs_table_t*)table;
     result->empty = empty;
@@ -35111,7 +35111,7 @@ void _ecs_table_cache_remove(
     ecs_map_remove(cache->index, table->id);
 
     if (!ecs_map_count(cache->index)) {
-        ecs_assert(ecs_vector_count(cache->tables) == 0, 
+        ecs_assert(ecs_vector_count(cache->tables) == 0,
             ECS_INTERNAL_ERROR, NULL);
         ecs_assert(ecs_vector_count(cache->empty_tables) == 0,
             ECS_INTERNAL_ERROR, NULL);
@@ -35300,7 +35300,7 @@ void ecs_os_init(void)
     if (!ecs_os_api_initialized) {
         ecs_os_set_api_defaults();
     }
-    
+
     if (!(ecs_os_api_init_count ++)) {
         if (ecs_os_api.init_) {
             ecs_os_api.init_();
@@ -35316,12 +35316,12 @@ void ecs_os_fini(void) {
     }
 }
 
-#if !defined(ECS_TARGET_WINDOWS) && !defined(ECS_TARGET_EM) && !defined(ECS_TARGET_ANDROID)
+#if !defined(ECS_TARGET_WINDOWS) && !defined(ECS_TARGET_EM) && !defined(ECS_TARGET_ANDROID) && !defined(__ANDROID__)
 #include <execinfo.h>
 #define ECS_BT_BUF_SIZE 100
 static
 void dump_backtrace(
-    FILE *stream) 
+    FILE *stream)
 {
     int nptrs;
     void *buffer[ECS_BT_BUF_SIZE];
@@ -35344,7 +35344,7 @@ void dump_backtrace(
 static
 void dump_backtrace(
     FILE *stream)
-{ 
+{
     (void)stream;
 }
 #endif
@@ -35352,8 +35352,8 @@ void dump_backtrace(
 static
 void log_msg(
     int32_t level,
-    const char *file, 
-    int32_t line,  
+    const char *file,
+    int32_t line,
     const char *msg)
 {
     FILE *stream;
@@ -35424,8 +35424,8 @@ void log_msg(
 }
 
 void ecs_os_dbg(
-    const char *file, 
-    int32_t line, 
+    const char *file,
+    int32_t line,
     const char *msg)
 {
 #ifndef NDEBUG
@@ -35440,9 +35440,9 @@ void ecs_os_dbg(
 }
 
 void ecs_os_trace(
-    const char *file, 
-    int32_t line, 
-    const char *msg) 
+    const char *file,
+    int32_t line,
+    const char *msg)
 {
     if (ecs_os_api.log_) {
         ecs_os_api.log_(0, file, line, msg);
@@ -35450,9 +35450,9 @@ void ecs_os_trace(
 }
 
 void ecs_os_warn(
-    const char *file, 
-    int32_t line, 
-    const char *msg) 
+    const char *file,
+    int32_t line,
+    const char *msg)
 {
     if (ecs_os_api.log_) {
         ecs_os_api.log_(-2, file, line, msg);
@@ -35460,9 +35460,9 @@ void ecs_os_warn(
 }
 
 void ecs_os_err(
-    const char *file, 
-    int32_t line, 
-    const char *msg) 
+    const char *file,
+    int32_t line,
+    const char *msg)
 {
     if (ecs_os_api.log_) {
         ecs_os_api.log_(-3, file, line, msg);
@@ -35470,9 +35470,9 @@ void ecs_os_err(
 }
 
 void ecs_os_fatal(
-    const char *file, 
-    int32_t line, 
-    const char *msg) 
+    const char *file,
+    int32_t line,
+    const char *msg)
 {
     if (ecs_os_api.log_) {
         ecs_os_api.log_(-4, file, line, msg);
@@ -35482,7 +35482,7 @@ void ecs_os_fatal(
 static
 void ecs_os_gettime(ecs_time_t *time) {
     ecs_assert(ecs_os_has_time() == true, ECS_MISSING_OS_API, NULL);
-    
+
     uint64_t now = ecs_os_now();
     uint64_t sec = now / 1000000000;
 
@@ -35515,9 +35515,9 @@ void* ecs_os_api_realloc(void *ptr, ecs_size_t size) {
         ecs_os_api_realloc_count ++;
     } else {
         /* If not actually reallocing, treat as malloc */
-        ecs_os_api_malloc_count ++; 
+        ecs_os_api_malloc_count ++;
     }
-    
+
     return realloc(ptr, (size_t)size);
 }
 
@@ -35608,7 +35608,7 @@ void ecs_os_set_api_defaults(void)
     }
 
     ecs_os_api_initializing = true;
-    
+
     /* Memory management */
     ecs_os_api.malloc_ = ecs_os_api_malloc;
     ecs_os_api.free_ = ecs_os_api_free;
@@ -35646,7 +35646,7 @@ void ecs_os_set_api_defaults(void)
 }
 
 bool ecs_os_has_heap(void) {
-    return 
+    return
         (ecs_os_api.malloc_ != NULL) &&
         (ecs_os_api.calloc_ != NULL) &&
         (ecs_os_api.realloc_ != NULL) &&
@@ -35665,11 +35665,11 @@ bool ecs_os_has_threading(void) {
         (ecs_os_api.cond_signal_ != NULL) &&
         (ecs_os_api.cond_broadcast_ != NULL) &&
         (ecs_os_api.thread_new_ != NULL) &&
-        (ecs_os_api.thread_join_ != NULL);   
+        (ecs_os_api.thread_join_ != NULL);
 }
 
 bool ecs_os_has_time(void) {
-    return 
+    return
         (ecs_os_api.get_time_ != NULL) &&
         (ecs_os_api.sleep_ != NULL) &&
         (ecs_os_api.now_ != NULL) &&
@@ -35681,14 +35681,14 @@ bool ecs_os_has_logging(void) {
 }
 
 bool ecs_os_has_dl(void) {
-    return 
+    return
         (ecs_os_api.dlopen_ != NULL) &&
         (ecs_os_api.dlproc_ != NULL) &&
-        (ecs_os_api.dlclose_ != NULL);  
+        (ecs_os_api.dlclose_ != NULL);
 }
 
 bool ecs_os_has_modules(void) {
-    return 
+    return
         (ecs_os_api.module_to_dl_ != NULL) &&
         (ecs_os_api.module_to_etc_ != NULL);
 }
@@ -35697,7 +35697,7 @@ void ecs_os_enable_high_timer_resolution(bool enable) {
     if (ecs_os_api.enable_high_timer_resolution_) {
         ecs_os_api.enable_high_timer_resolution_(enable);
     } else {
-        ecs_assert(enable == false, ECS_MISSING_OS_API, 
+        ecs_assert(enable == false, ECS_MISSING_OS_API,
             "enable_high_timer_resolution");
     }
 }
@@ -35730,7 +35730,7 @@ void compute_group_id(
         ecs_table_t *table = match->table;
         ecs_assert(table != NULL, ECS_INTERNAL_ERROR, NULL);
 
-        match->group_id = query->group_by(query->world, table->type, 
+        match->group_id = query->group_by(query->world, table->type,
             query->group_by_id, query->group_by_ctx);
     } else {
         match->group_id = 0;
@@ -35830,9 +35830,9 @@ void create_group(
         if (insert_before) {
             insert_before->prev = node;
         } else {
-            ecs_assert(query->list.last == insert_after, 
+            ecs_assert(query->list.last == insert_after,
                 ECS_INTERNAL_ERROR, NULL);
-                
+
             /* This group should appear last in the query list */
             query->list.last = node;
         }
@@ -35898,9 +35898,9 @@ void remove_table_node(
         return;
     }
 
-    ecs_assert(prev != NULL || query->list.first == node, 
+    ecs_assert(prev != NULL || query->list.first == node,
         ECS_INTERNAL_ERROR, NULL);
-    ecs_assert(next != NULL || query->list.last == node, 
+    ecs_assert(next != NULL || query->list.last == node,
         ECS_INTERNAL_ERROR, NULL);
 
     if (prev) {
@@ -35978,7 +35978,7 @@ void insert_table_node(
     ecs_query_table_node_t *node)
 {
     /* Node should not be part of an existing list */
-    ecs_assert(node->prev == NULL && node->next == NULL, 
+    ecs_assert(node->prev == NULL && node->next == NULL,
         ECS_INTERNAL_ERROR, NULL);
 
     /* If this is the first match, activate system */
@@ -36103,7 +36103,7 @@ void get_dirty_state(
     }
 }
 
-/* Get match monitor. Monitors are used to keep track of whether components 
+/* Get match monitor. Monitors are used to keep track of whether components
  * matched by the query in a table have changed. */
 static
 bool get_match_monitor(
@@ -36132,7 +36132,7 @@ bool get_match_monitor(
         t = f->terms[i].index;
         monitor[t + 1] = -1;
 
-        if (f->terms[i].inout != EcsIn && 
+        if (f->terms[i].inout != EcsIn &&
             f->terms[i].inout != EcsInOut &&
             f->terms[i].inout != EcsInOutDefault) {
             continue; /* If term isn't read, don't monitor */
@@ -36187,7 +36187,7 @@ void sync_match_monitor(
         if (monitor[t + 1] == -1) {
             continue;
         }
-                
+
         get_dirty_state(query, match, t, &cur);
         ecs_assert(cur.column != -1, ECS_INTERNAL_ERROR, NULL);
         monitor[t + 1] = cur.dirty_state[cur.column + 1];
@@ -36206,7 +36206,7 @@ bool check_match_monitor_term(
     if (get_match_monitor(query, match)) {
         return true;
     }
-    
+
     int32_t *monitor = match->monitor;
     ecs_table_t *table = match->table;
     int32_t *dirty_state = flecs_table_get_dirty_state(table);
@@ -36288,7 +36288,7 @@ bool check_table_monitor(
         } else {
             if (check_match_monitor_term(query, match, term)) {
                 return true;
-            } 
+            }
         }
     }
 
@@ -36329,8 +36329,8 @@ void init_query_monitors(
 /* Builtin group_by callback for Cascade terms.
  * This function traces the hierarchy depth of an entity type by following a
  * relation upwards (to its 'parents') for as long as those parents have the
- * specified component id. 
- * The result of the function is the number of parents with the provided 
+ * specified component id.
+ * The result of the function is the number of parents with the provided
  * component for a given relation. */
 static
 uint64_t group_by_cascade(
@@ -36356,7 +36356,7 @@ uint64_t group_by_cascade(
     for (i = count - 1; i >= 0; i --) {
         /* Find relation & relation object in entity type */
         if (ECS_HAS_RELATION(array[i], relation)) {
-            ecs_type_t obj_type = ecs_get_type(world,     
+            ecs_type_t obj_type = ecs_get_type(world,
                 ecs_pair_object(world, array[i]));
             int32_t j, c_count = ecs_vector_count(obj_type);
             ecs_entity_t *c_array = ecs_vector_first(obj_type, ecs_entity_t);
@@ -36433,8 +36433,8 @@ int get_comp_and_src(
 
                 if (!component) {
                     ecs_entity_t source = 0;
-                    int32_t result = ecs_search_relation(world, table, 
-                        0, term->id, subj->set.relation, subj->set.min_depth, 
+                    int32_t result = ecs_search_relation(world, table,
+                        0, term->id, subj->set.relation, subj->set.min_depth,
                         subj->set.max_depth, &source, NULL, NULL);
 
                     if (result != -1) {
@@ -36443,15 +36443,15 @@ int get_comp_and_src(
 
                     if (source) {
                         entity = source;
-                    }                    
+                    }
                 }
             }
         } else {
             component = term->id;
 
             ecs_entity_t source = 0;
-            bool result = ecs_search_relation(world, table, 0, component, 
-                subj->set.relation, subj->set.min_depth, subj->set.max_depth, 
+            bool result = ecs_search_relation(world, table, 0, component,
+                subj->set.relation, subj->set.min_depth, subj->set.max_depth,
                 &source, NULL, NULL) != -1;
 
             *match_out = result;
@@ -36463,8 +36463,8 @@ int get_comp_and_src(
             /* Optional terms may not have the component. *From terms contain
              * the id of a type of which the contents must match, but the type
              * itself does not need to match. */
-            if (op == EcsOptional || op == EcsAndFrom || op == EcsOrFrom || 
-                op == EcsNotFrom) 
+            if (op == EcsOptional || op == EcsAndFrom || op == EcsOrFrom ||
+                op == EcsNotFrom)
             {
                 result = true;
             }
@@ -36524,7 +36524,7 @@ int32_t get_pair_index(
     } else {
         /* First time for this iteration that the pair index is resolved, look
          * it up in the type. */
-        result = ecs_search_offset(world, table, 
+        result = ecs_search_offset(world, table,
             pair_offsets[column_index].index, pair, 0);
         pair_offsets[column_index].index = result + 1;
         pair_offsets[column_index].count = count;
@@ -36543,7 +36543,7 @@ int32_t get_component_index(
     ecs_oper_kind_t op,
     pair_offset_t *pair_offsets,
     int32_t count)
-{    
+{
     int32_t result = 0;
     ecs_entity_t component = *component_out;
 
@@ -36557,7 +36557,7 @@ int32_t get_component_index(
             result = ecs_search(world, table, ECS_SWITCH | sw, 0);
             ecs_assert(result != -1, ECS_INTERNAL_ERROR, NULL);
         } else
-        if (ECS_HAS_ROLE(component, PAIR)) { 
+        if (ECS_HAS_ROLE(component, PAIR)) {
             ecs_entity_t rel = ECS_PAIR_RELATION(component);
             ecs_entity_t obj = ECS_PAIR_OBJECT(component);
 
@@ -36570,13 +36570,13 @@ int32_t get_component_index(
 
                 /* Get index of pair. Start looking from the last pair index
                  * as this may not be the first instance of the pair. */
-                result = get_pair_index(world, table, component, column_index, 
+                result = get_pair_index(world, table, component, column_index,
                     pair_offsets, count);
-                
+
                 if (result != -1) {
-                    /* If component of current column is a pair, get the actual 
-                     * pair type for the table, so the system can see which 
-                     * component the pair was applied to */   
+                    /* If component of current column is a pair, get the actual
+                     * pair type for the table, so the system can see which
+                     * component the pair was applied to */
                     ecs_entity_t *pair = ecs_vector_get(
                         table_type, ecs_entity_t, result);
                     *component_out = *pair;
@@ -36593,7 +36593,7 @@ int32_t get_component_index(
             } else {
                 /* If the low part is a regular entity (component), then
                  * this query exactly matches a single pair instance. In
-                 * this case we can simply do a lookup of the pair 
+                 * this case we can simply do a lookup of the pair
                  * identifier in the table type. */
                 result = ecs_search(world, table, component, 0);
             }
@@ -36606,23 +36606,23 @@ int32_t get_component_index(
         * a table is reserved for entity id's */
         if (result != -1) {
             result ++;
-        }     
+        }
 
         /* ecs_table_column_offset may return -1 if the component comes
          * from a prefab. If so, the component will be resolved as a
-         * reference (see below) */           
+         * reference (see below) */
     }
 
     if (op == EcsAndFrom || op == EcsOrFrom || op == EcsNotFrom) {
         result = 0;
     } else if (op == EcsOptional) {
         /* If table doesn't have the field, mark it as no data */
-        if (-1 == ecs_search_relation(world, table, 0, component, EcsIsA, 
-            0, 0, 0, 0, 0)) 
+        if (-1 == ecs_search_relation(world, table, 0, component, EcsIsA,
+            0, 0, 0, 0, 0))
         {
             result = 0;
         }
-    }  
+    }
 
     return result;
 }
@@ -36635,14 +36635,14 @@ ecs_vector_t* add_ref(
     ecs_term_t *term,
     ecs_entity_t component,
     ecs_entity_t entity)
-{    
+{
     ecs_ref_t *ref = ecs_vector_add(&references, ecs_ref_t);
     ecs_term_id_t *subj = &term->subj;
 
     if (!(subj->set.mask & EcsCascade)) {
         ecs_assert(entity != 0, ECS_INTERNAL_ERROR, NULL);
     }
-    
+
     *ref = (ecs_ref_t){0};
     ref->entity = entity;
     ref->component = component;
@@ -36734,7 +36734,7 @@ ecs_type_t get_term_type(
         return type->normalized->type;
     } else {
         return ecs_get_type(world, component);
-    } 
+    }
 }
 
 /** Add table to system, compute offsets for system components in table it */
@@ -36753,12 +36753,12 @@ void add_table(
     }
 
     int32_t pair_cur = 0, pair_count = count_pairs(world, query, table);
-    
+
     /* If the query has pairs, we need to account for the fact that a table may
      * have multiple components to which the pair is applied, which means the
      * table has to be registered with the query multiple times, with different
      * table columns. If so, allocate a small array for each pair in which the
-     * last added table index of the pair is stored, so that in the next 
+     * last added table index of the pair is stored, so that in the next
      * iteration we can start the search from the correct offset type. */
     pair_offset_t *pair_offsets = NULL;
     if (pair_count) {
@@ -36796,7 +36796,7 @@ add_pair:
 
         /* Cache subject (source) entity ids for components */
         table_data->sizes = ecs_os_calloc_n(ecs_size_t, query->filter.term_count_actual);
-        ecs_assert(table_data->sizes != NULL, ECS_OUT_OF_MEMORY, NULL);                     
+        ecs_assert(table_data->sizes != NULL, ECS_OUT_OF_MEMORY, NULL);
     }
 
     /* Walk columns parsed from the system signature */
@@ -36817,7 +36817,7 @@ add_pair:
 
         /* This column does not retrieve data from a static entity */
         if (!entity && subj.entity) {
-            int32_t index = get_component_index(world, table, table_type, 
+            int32_t index = get_component_index(world, table, table_type,
                 &component, c, op, pair_offsets, pair_cur + 1);
 
             if (index == -1) {
@@ -36848,7 +36848,7 @@ add_pair:
              * in a vector as the iterator will need to skip the entity when the
              * component is disabled. */
             if (index && (table && table->flags & EcsTableHasDisabled)) {
-                ecs_entity_t bs_id = 
+                ecs_entity_t bs_id =
                     (component & ECS_COMPONENT_MASK) | ECS_DISABLED;
                 int32_t bs_index = ecs_search(world, table, bs_id, 0);
                 if (bs_index != -1) {
@@ -36916,7 +36916,7 @@ add_pair:
     if (references) {
         ecs_size_t ref_size = ECS_SIZEOF(ecs_ref_t) * ecs_vector_count(references);
         table_data->references = ecs_os_malloc(ref_size);
-        ecs_os_memcpy(table_data->references, 
+        ecs_os_memcpy(table_data->references,
             ecs_vector_first(references, ecs_ref_t), ref_size);
         ecs_vector_free(references);
         references = NULL;
@@ -36957,7 +36957,7 @@ bool match_term(
     }
 
     return ecs_search_relation(
-        world, table, 0, term->id, subj->set.relation, 
+        world, table, 0, term->id, subj->set.relation,
         subj->set.min_depth, subj->set.max_depth, NULL, NULL, NULL) != -1;
 }
 
@@ -37030,7 +37030,7 @@ bool flecs_query_match(
             if (!match) {
                 return false;
             }
- 
+
         } else if (oper == EcsAndFrom || oper == EcsOrFrom || oper == EcsNotFrom) {
             ecs_type_t type = get_term_type((ecs_world_t*)world, term, term->id);
             int32_t match_count = 0, j, count = ecs_vector_count(type);
@@ -37086,7 +37086,7 @@ int32_t qsort_partition(
     ecs_table_t *table,
     ecs_data_t *data,
     ecs_entity_t *entities,
-    void *ptr,    
+    void *ptr,
     int32_t elem_size,
     int32_t lo,
     int32_t hi,
@@ -37096,7 +37096,7 @@ int32_t qsort_partition(
     void *pivot = ECS_ELEM(ptr, elem_size, p);
     ecs_entity_t pivot_e = entities[p];
     int32_t i = lo - 1, j = hi + 1;
-    void *el;    
+    void *el;
 
 repeat:
     {
@@ -37139,7 +37139,7 @@ void qsort_array(
     int32_t lo,
     int32_t hi,
     ecs_order_by_action_t compare)
-{   
+{
     if ((hi - lo) < 1)  {
         return;
     }
@@ -37149,7 +37149,7 @@ void qsort_array(
 
     qsort_array(world, table, data, entities, ptr, size, lo, p, compare);
 
-    qsort_array(world, table, data, entities, ptr, size, p + 1, hi, compare); 
+    qsort_array(world, table, data, entities, ptr, size, p + 1, hi, compare);
 }
 
 static
@@ -37227,7 +37227,7 @@ void build_sorted_table_range(
     ecs_world_t *world = query->world;
     ecs_entity_t id = query->order_by_component;
     ecs_order_by_action_t compare = query->order_by;
-    
+
     if (!list->count) {
         return;
     }
@@ -37259,7 +37259,7 @@ void build_sorted_table_range(
         } else if (id) {
             /* Find component in prefab */
             ecs_entity_t base = 0;
-            ecs_search_relation(world, table, 0, id, 
+            ecs_search_relation(world, table, 0, id,
                 EcsIsA, 1, 0, &base, NULL, NULL);
 
             /* If a base was not found, the query should not have allowed using
@@ -37282,7 +37282,7 @@ void build_sorted_table_range(
         helper[to_sort].entities = ecs_vector_first(entities, ecs_entity_t);
         helper[to_sort].row = 0;
         helper[to_sort].count = ecs_table_count(table);
-        to_sort ++;      
+        to_sort ++;
     }
 
     bool proceed;
@@ -37334,7 +37334,7 @@ void build_sorted_table_range(
 
     /* Iterate through the vector of slices to set the prev/next ptrs. This
      * can't be done while building the vector, as reallocs may occur */
-    int32_t i, count = ecs_vector_count(query->table_slices);    
+    int32_t i, count = ecs_vector_count(query->table_slices);
     ecs_query_table_node_t *nodes = ecs_vector_first(
         query->table_slices, ecs_query_table_node_t);
     for (i = 0; i < count; i ++) {
@@ -37363,13 +37363,13 @@ void build_sorted_tables(
                 ecs_query_table_match_t *match = cur->match;
                 ecs_assert(match != NULL, ECS_INTERNAL_ERROR, NULL);
                 uint64_t group_id = match->group_id;
-                ecs_query_table_list_t *list = ecs_map_get(query->groups, 
+                ecs_query_table_list_t *list = ecs_map_get(query->groups,
                     ecs_query_table_list_t, group_id);
                 ecs_assert(list != NULL, ECS_INTERNAL_ERROR, NULL);
 
                 /* Sort tables in current group */
                 build_sorted_table_range(query, list);
-                
+
                 /* Find next group to sort */
                 cur = list->last->next;
             } while (cur);
@@ -37388,7 +37388,7 @@ void sort_tables(
     if (!compare) {
         return;
     }
-    
+
     ecs_entity_t order_by_component = query->order_by_component;
     int32_t i, order_by_term = -1;
 
@@ -37439,7 +37439,7 @@ void sort_tables(
 
                 ecs_table_t *storage_table = table->storage_table;
                 if (storage_table) {
-                    column = ecs_search(world, storage_table, 
+                    column = ecs_search(world, storage_table,
                         order_by_component, NULL);
                 }
 
@@ -37485,7 +37485,7 @@ bool has_refs(
             /* If entity is not this, or if it can be substituted by other
              * entities, the query can have references. */
             return true;
-        } 
+        }
     }
 
     return false;
@@ -37504,7 +37504,7 @@ bool has_pairs(
         }
     }
 
-    return false;    
+    return false;
 }
 
 static
@@ -37522,12 +37522,12 @@ void register_monitors(
         /* If component is requested with EcsCascade register component as a
          * parent monitor. Parent monitors keep track of whether an entity moved
          * in the hierarchy, which potentially requires the query to reorder its
-         * tables. 
+         * tables.
          * Also register a regular component monitor for EcsCascade columns.
          * This ensures that when the component used in the EcsCascade column
          * is added or removed tables are updated accordingly*/
-        if (subj->set.mask & EcsSuperSet && subj->set.mask & EcsCascade && 
-            subj->set.relation != EcsIsA) 
+        if (subj->set.mask & EcsSuperSet && subj->set.mask & EcsCascade &&
+            subj->set.relation != EcsIsA)
         {
             if (term->oper != EcsOr) {
                 if (term->subj.set.relation != EcsIsA) {
@@ -37574,7 +37574,7 @@ void process_signature(
         ecs_term_id_t *pred = &term->pred;
         ecs_term_id_t *subj = &term->subj;
         ecs_term_id_t *obj = &term->obj;
-        ecs_oper_kind_t op = term->oper; 
+        ecs_oper_kind_t op = term->oper;
         ecs_inout_kind_t inout = term->inout;
 
         bool is_pred_supported = is_term_id_supported(pred);
@@ -37590,7 +37590,7 @@ void process_signature(
         /* Queries do not support named variables */
         ecs_check(is_pred_supported, ECS_UNSUPPORTED, NULL);
         ecs_check(is_obj_supported,  ECS_UNSUPPORTED, NULL);
-        ecs_check(is_subj_supported || subj->entity == EcsThis, 
+        ecs_check(is_subj_supported || subj->entity == EcsThis,
             ECS_UNSUPPORTED, NULL);
 
         /* If self is not included in set, always start from depth 1 */
@@ -37632,8 +37632,8 @@ void process_signature(
             query->cascade_by = i + 1;
         }
 
-        if (subj->entity && subj->entity != EcsThis && 
-            subj->set.mask == EcsSelf) 
+        if (subj->entity && subj->entity != EcsThis &&
+            subj->set.mask == EcsSelf)
         {
             flecs_add_flag(world, term->subj.entity, ECS_FLAG_OBSERVED);
         }
@@ -37683,27 +37683,27 @@ void update_table(
             next = cur->next_match;
 
             if (empty) {
-                ecs_assert(ecs_table_count(table) == 0, 
+                ecs_assert(ecs_table_count(table) == 0,
                     ECS_INTERNAL_ERROR, NULL);
 
                 remove_table_node(query, &cur->node);
             } else {
-                ecs_assert(ecs_table_count(table) != 0, 
+                ecs_assert(ecs_table_count(table) != 0,
                     ECS_INTERNAL_ERROR, NULL);
                 insert_table_node(query, &cur->node);
             }
         }
     }
 
-    ecs_assert(cur_count || query->list.first == NULL, 
+    ecs_assert(cur_count || query->list.first == NULL,
         ECS_INTERNAL_ERROR, NULL);
 }
 
 static
 void add_subquery(
-    ecs_world_t *world, 
-    ecs_query_t *parent, 
-    ecs_query_t *subquery) 
+    ecs_world_t *world,
+    ecs_query_t *parent,
+    ecs_query_t *subquery)
 {
     ecs_query_t **elem = ecs_vector_add(&parent->subqueries, ecs_query_t*);
     *elem = subquery;
@@ -37765,7 +37765,7 @@ void resolve_cascade_subject_for_table(
 
     /* Find source for component */
     ecs_entity_t subject = 0;
-    ecs_search_relation(world, table, 0, term->id, 
+    ecs_search_relation(world, table, 0, term->id,
         term->subj.set.relation, 1, 0, &subject, NULL, NULL);
 
     /* If container was found, update the reference */
@@ -37859,8 +37859,8 @@ void rematch_table(
             add_table(world, query, table);
 
         /* If table still matches and has cascade column, reevaluate the
-         * sources of references. This may have changed in case 
-         * components were added/removed to container entities */ 
+         * sources of references. This may have changed in case
+         * components were added/removed to container entities */
         } else if (query->cascade_by) {
             resolve_cascade_subject(world, query, match, table);
 
@@ -37927,8 +37927,8 @@ bool satisfy_constraints(
         if (subj->entity != EcsThis && subj->set.mask & EcsSelf) {
             ecs_table_t *table = ecs_get_table(world, subj->entity);
 
-            if (ecs_search_relation(world, table, 0, term->id, EcsIsA, 
-                0, 0, 0, 0, 0) != -1) 
+            if (ecs_search_relation(world, table, 0, term->id, EcsIsA,
+                0, 0, 0, 0, 0) != -1)
             {
                 if (oper == EcsNot) {
                     return false;
@@ -37950,7 +37950,7 @@ void rematch_tables(
     ecs_world_t *world,
     ecs_query_t *query,
     ecs_query_t *parent_query)
-{    
+{
     if (parent_query) {
         ecs_query_table_t *tables = ecs_vector_first(
             parent_query->cache.tables, ecs_query_table_t);
@@ -37964,7 +37964,7 @@ void rematch_tables(
         count = ecs_vector_count(parent_query->cache.empty_tables);
         for (i = 0; i < count; i ++) {
             rematch_table(world, query, tables[i].hdr.table);
-        }        
+        }
     } else {
         ecs_sparse_t *tables = world->store.tables;
         int32_t i, count = flecs_sparse_count(tables);
@@ -37978,12 +37978,12 @@ void rematch_tables(
 
     /* Enable/disable system if constraints are (not) met. If the system is
      * already dis/enabled this operation has no side effects. */
-    query->constraints_satisfied = satisfy_constraints(world, &query->filter);      
+    query->constraints_satisfied = satisfy_constraints(world, &query->filter);
 }
 
 static
 void remove_subquery(
-    ecs_query_t *parent, 
+    ecs_query_t *parent,
     ecs_query_t *sub)
 {
     ecs_assert(parent != NULL, ECS_INTERNAL_ERROR, NULL);
@@ -38028,7 +38028,7 @@ void flecs_query_notify(
     case EcsQueryTableRematch:
         /* Rematch tables of query */
         rematch_tables(world, query, event->parent_query);
-        break;        
+        break;
     case EcsQueryOrphan:
         ecs_assert(query->flags & EcsQueryIsSubquery, ECS_INTERNAL_ERROR, NULL);
         query->flags |= EcsQueryIsOrphaned;
@@ -38049,7 +38049,7 @@ void query_order_by(
     ecs_order_by_action_t order_by)
 {
     ecs_check(query != NULL, ECS_INVALID_PARAMETER, NULL);
-    ecs_check(!(query->flags & EcsQueryIsOrphaned), ECS_INVALID_PARAMETER, NULL);    
+    ecs_check(!(query->flags & EcsQueryIsOrphaned), ECS_INVALID_PARAMETER, NULL);
     ecs_check(query->flags & EcsQueryNeedsTables, ECS_INVALID_PARAMETER, NULL);
 
     query->order_by_component = order_by_component;
@@ -38058,7 +38058,7 @@ void query_order_by(
     ecs_vector_free(query->table_slices);
     query->table_slices = NULL;
 
-    sort_tables(world, query);  
+    sort_tables(world, query);
 
     if (!query->table_slices) {
         build_sorted_tables(query);
@@ -38072,7 +38072,7 @@ void query_group_by(
     ecs_query_t *query,
     ecs_entity_t sort_component,
     ecs_group_by_action_t group_by)
-{   
+{
     /* Cannot change grouping once a query has been created */
     ecs_check(query->group_by_id == 0, ECS_INVALID_OPERATION, NULL);
     ecs_check(query->group_by == 0, ECS_INVALID_OPERATION, NULL);
@@ -38104,8 +38104,8 @@ void query_iter_init(
 
 static
 void query_on_event(
-    ecs_iter_t *it) 
-{ 
+    ecs_iter_t *it)
+{
     /* Because this is the observer::run callback, checking if this is event is
      * already handled is not done for us. */
     ecs_world_t *world = it->world;
@@ -38213,7 +38213,7 @@ ecs_query_t* ecs_query_init(
             if (term->subj.entity == desc->system) {
                 ecs_add_id(world, desc->system, term->id);
             }
-        }        
+        }
     }
 
 #ifndef NDEBUG
@@ -38293,7 +38293,7 @@ void ecs_query_fini(
     ecs_filter_fini(&query->filter);
 
     ecs_poly_fini(query, ecs_query_t);
-    
+
     /* Remove query from storage */
     flecs_sparse_remove(world->queries, query->id);
 error:
@@ -38363,7 +38363,7 @@ int find_smallest_column(
     ecs_query_table_match_t *table_data,
     ecs_vector_t *sparse_columns)
 {
-    flecs_sparse_column_t *sparse_column_array = 
+    flecs_sparse_column_t *sparse_column_array =
         ecs_vector_first(sparse_columns, flecs_sparse_column_t);
     int32_t i, count = ecs_vector_count(sparse_columns);
     int32_t min = INT_MAX, index = 0;
@@ -38387,7 +38387,7 @@ int find_smallest_column(
 
             /* Get the sparse column */
             ecs_data_t *data = &table->storage;
-            sc = sparse_column->sw_column = 
+            sc = sparse_column->sw_column =
                 &data->sw_columns[table_column_index - 1];
         }
 
@@ -38510,14 +38510,14 @@ int bitset_column_next(
     (uint64_t)1 << 12, (uint64_t)1 << 13, (uint64_t)1 << 14, (uint64_t)1 << 15,
     (uint64_t)1 << 16, (uint64_t)1 << 17, (uint64_t)1 << 18, (uint64_t)1 << 19,
     (uint64_t)1 << 20, (uint64_t)1 << 21, (uint64_t)1 << 22, (uint64_t)1 << 23,
-    (uint64_t)1 << 24, (uint64_t)1 << 25, (uint64_t)1 << 26, (uint64_t)1 << 27,  
+    (uint64_t)1 << 24, (uint64_t)1 << 25, (uint64_t)1 << 26, (uint64_t)1 << 27,
     (uint64_t)1 << 28, (uint64_t)1 << 29, (uint64_t)1 << 30, (uint64_t)1 << 31,
-    (uint64_t)1 << 32, (uint64_t)1 << 33, (uint64_t)1 << 34, (uint64_t)1 << 35,  
+    (uint64_t)1 << 32, (uint64_t)1 << 33, (uint64_t)1 << 34, (uint64_t)1 << 35,
     (uint64_t)1 << 36, (uint64_t)1 << 37, (uint64_t)1 << 38, (uint64_t)1 << 39,
     (uint64_t)1 << 40, (uint64_t)1 << 41, (uint64_t)1 << 42, (uint64_t)1 << 43,
-    (uint64_t)1 << 44, (uint64_t)1 << 45, (uint64_t)1 << 46, (uint64_t)1 << 47,  
+    (uint64_t)1 << 44, (uint64_t)1 << 45, (uint64_t)1 << 46, (uint64_t)1 << 47,
     (uint64_t)1 << 48, (uint64_t)1 << 49, (uint64_t)1 << 50, (uint64_t)1 << 51,
-    (uint64_t)1 << 52, (uint64_t)1 << 53, (uint64_t)1 << 54, (uint64_t)1 << 55,  
+    (uint64_t)1 << 52, (uint64_t)1 << 53, (uint64_t)1 << 54, (uint64_t)1 << 55,
     (uint64_t)1 << 56, (uint64_t)1 << 57, (uint64_t)1 << 58, (uint64_t)1 << 59,
     (uint64_t)1 << 60, (uint64_t)1 << 61, (uint64_t)1 << 62, (uint64_t)1 << 63
     };
@@ -38526,24 +38526,24 @@ int bitset_column_next(
     static const uint64_t bitmask_remain[64] = {
     BS_MAX, BS_MAX - (BS_MAX >> 63), BS_MAX - (BS_MAX >> 62),
     BS_MAX - (BS_MAX >> 61), BS_MAX - (BS_MAX >> 60), BS_MAX - (BS_MAX >> 59),
-    BS_MAX - (BS_MAX >> 58), BS_MAX - (BS_MAX >> 57), BS_MAX - (BS_MAX >> 56), 
-    BS_MAX - (BS_MAX >> 55), BS_MAX - (BS_MAX >> 54), BS_MAX - (BS_MAX >> 53), 
-    BS_MAX - (BS_MAX >> 52), BS_MAX - (BS_MAX >> 51), BS_MAX - (BS_MAX >> 50), 
-    BS_MAX - (BS_MAX >> 49), BS_MAX - (BS_MAX >> 48), BS_MAX - (BS_MAX >> 47), 
-    BS_MAX - (BS_MAX >> 46), BS_MAX - (BS_MAX >> 45), BS_MAX - (BS_MAX >> 44), 
-    BS_MAX - (BS_MAX >> 43), BS_MAX - (BS_MAX >> 42), BS_MAX - (BS_MAX >> 41), 
-    BS_MAX - (BS_MAX >> 40), BS_MAX - (BS_MAX >> 39), BS_MAX - (BS_MAX >> 38), 
-    BS_MAX - (BS_MAX >> 37), BS_MAX - (BS_MAX >> 36), BS_MAX - (BS_MAX >> 35), 
-    BS_MAX - (BS_MAX >> 34), BS_MAX - (BS_MAX >> 33), BS_MAX - (BS_MAX >> 32), 
-    BS_MAX - (BS_MAX >> 31), BS_MAX - (BS_MAX >> 30), BS_MAX - (BS_MAX >> 29), 
-    BS_MAX - (BS_MAX >> 28), BS_MAX - (BS_MAX >> 27), BS_MAX - (BS_MAX >> 26), 
-    BS_MAX - (BS_MAX >> 25), BS_MAX - (BS_MAX >> 24), BS_MAX - (BS_MAX >> 23), 
-    BS_MAX - (BS_MAX >> 22), BS_MAX - (BS_MAX >> 21), BS_MAX - (BS_MAX >> 20), 
-    BS_MAX - (BS_MAX >> 19), BS_MAX - (BS_MAX >> 18), BS_MAX - (BS_MAX >> 17), 
-    BS_MAX - (BS_MAX >> 16), BS_MAX - (BS_MAX >> 15), BS_MAX - (BS_MAX >> 14), 
-    BS_MAX - (BS_MAX >> 13), BS_MAX - (BS_MAX >> 12), BS_MAX - (BS_MAX >> 11), 
-    BS_MAX - (BS_MAX >> 10), BS_MAX - (BS_MAX >> 9), BS_MAX - (BS_MAX >> 8), 
-    BS_MAX - (BS_MAX >> 7), BS_MAX - (BS_MAX >> 6), BS_MAX - (BS_MAX >> 5), 
+    BS_MAX - (BS_MAX >> 58), BS_MAX - (BS_MAX >> 57), BS_MAX - (BS_MAX >> 56),
+    BS_MAX - (BS_MAX >> 55), BS_MAX - (BS_MAX >> 54), BS_MAX - (BS_MAX >> 53),
+    BS_MAX - (BS_MAX >> 52), BS_MAX - (BS_MAX >> 51), BS_MAX - (BS_MAX >> 50),
+    BS_MAX - (BS_MAX >> 49), BS_MAX - (BS_MAX >> 48), BS_MAX - (BS_MAX >> 47),
+    BS_MAX - (BS_MAX >> 46), BS_MAX - (BS_MAX >> 45), BS_MAX - (BS_MAX >> 44),
+    BS_MAX - (BS_MAX >> 43), BS_MAX - (BS_MAX >> 42), BS_MAX - (BS_MAX >> 41),
+    BS_MAX - (BS_MAX >> 40), BS_MAX - (BS_MAX >> 39), BS_MAX - (BS_MAX >> 38),
+    BS_MAX - (BS_MAX >> 37), BS_MAX - (BS_MAX >> 36), BS_MAX - (BS_MAX >> 35),
+    BS_MAX - (BS_MAX >> 34), BS_MAX - (BS_MAX >> 33), BS_MAX - (BS_MAX >> 32),
+    BS_MAX - (BS_MAX >> 31), BS_MAX - (BS_MAX >> 30), BS_MAX - (BS_MAX >> 29),
+    BS_MAX - (BS_MAX >> 28), BS_MAX - (BS_MAX >> 27), BS_MAX - (BS_MAX >> 26),
+    BS_MAX - (BS_MAX >> 25), BS_MAX - (BS_MAX >> 24), BS_MAX - (BS_MAX >> 23),
+    BS_MAX - (BS_MAX >> 22), BS_MAX - (BS_MAX >> 21), BS_MAX - (BS_MAX >> 20),
+    BS_MAX - (BS_MAX >> 19), BS_MAX - (BS_MAX >> 18), BS_MAX - (BS_MAX >> 17),
+    BS_MAX - (BS_MAX >> 16), BS_MAX - (BS_MAX >> 15), BS_MAX - (BS_MAX >> 14),
+    BS_MAX - (BS_MAX >> 13), BS_MAX - (BS_MAX >> 12), BS_MAX - (BS_MAX >> 11),
+    BS_MAX - (BS_MAX >> 10), BS_MAX - (BS_MAX >> 9), BS_MAX - (BS_MAX >> 8),
+    BS_MAX - (BS_MAX >> 7), BS_MAX - (BS_MAX >> 6), BS_MAX - (BS_MAX >> 5),
     BS_MAX - (BS_MAX >> 4), BS_MAX - (BS_MAX >> 3), BS_MAX - (BS_MAX >> 2),
     BS_MAX - (BS_MAX >> 1)
     };
@@ -38566,7 +38566,7 @@ int bitset_column_next(
             bs_column = &table->storage.bs_columns[index - bs_offset];
             columns[i].bs_column = bs_column;
         }
-        
+
         ecs_bitset_t *bs = &bs_column->data;
         int32_t bs_elem_count = bs->count;
         int32_t bs_block = first >> 6;
@@ -38601,10 +38601,10 @@ int bitset_column_next(
             /* Block was not empty, so bs_start must be smaller than 64 */
             ecs_assert(bs_start < 64, ECS_INTERNAL_ERROR, NULL);
         }
-        
+
         /* Step 3: Find number of contiguous enabled elements after start */
         int32_t bs_end = bs_start, bs_block_end = bs_block;
-        
+
         remain = bitmask_remain[bs_end];
         while ((v & remain) == remain) {
             bs_end = 0;
@@ -38632,7 +38632,7 @@ int bitset_column_next(
          * range is a subset of the previous one. */
         first = bs_block * 64 + bs_start;
         int32_t cur_last = bs_block_end * 64 + bs_end;
-        
+
         /* No enabled elements found in table */
         if (first == cur_last) {
             goto done;
@@ -38654,11 +38654,11 @@ int bitset_column_next(
                 cur_last = last;
             }
         }
-        
+
         last = cur_last;
         int32_t elem_count = last - first;
 
-        /* Make sure last element doesn't exceed total number of elements in 
+        /* Make sure last element doesn't exceed total number of elements in
          * the table */
         if (elem_count > (bs_elem_count - first)) {
             elem_count = (bs_elem_count - first);
@@ -38667,13 +38667,13 @@ int bitset_column_next(
                 goto done;
             }
         }
-        
+
         cur->first = first;
         cur->count = elem_count;
         iter->bitset_first = first;
     }
-    
-    /* Keep track of last processed element for iteration */ 
+
+    /* Keep track of last processed element for iteration */
     iter->bitset_first = last;
 
     return 0;
@@ -38770,7 +38770,7 @@ bool ecs_query_next_instanced(
         }
     }
 
-    for (node = iter->node; node != NULL; node = next) {     
+    for (node = iter->node; node != NULL; node = next) {
         ecs_query_table_match_t *match = node->match;
         ecs_table_t *table = match->table;
 
@@ -38796,8 +38796,8 @@ bool ecs_query_next_instanced(
                     found = false;
 
                     if (bitset_columns) {
-                        if (bitset_column_next(table, bitset_columns, iter, 
-                            &cur) == -1) 
+                        if (bitset_column_next(table, bitset_columns, iter,
+                            &cur) == -1)
                         {
                             /* No more enabled components for table */
                             break;
@@ -38845,7 +38845,7 @@ bool ecs_query_next_instanced(
         it->instance_count = 0;
 
         flecs_iter_init(it);
-        flecs_iter_populate_data(world, it, match->table, cur.first, cur.count, 
+        flecs_iter_populate_data(world, it, match->table, cur.first, cur.count,
             it->ptrs, NULL);
 
         iter->node = next;
@@ -38857,9 +38857,9 @@ done:
 error:
     ecs_iter_fini(it);
     return false;
-    
+
 yield:
-    return true;  
+    return true;
 }
 
 bool ecs_query_changed(
@@ -38871,7 +38871,7 @@ bool ecs_query_changed(
         ecs_assert(it->is_valid, ECS_INVALID_PARAMETER, NULL);
         ecs_assert(it->count >= it->instance_count, ECS_INVALID_PARAMETER, NULL);
 
-        ecs_query_table_match_t *qt = 
+        ecs_query_table_match_t *qt =
             (ecs_query_table_match_t*)it->priv.iter.query.prev;
         ecs_assert(qt != NULL, ECS_INVALID_PARAMETER, NULL);
 
@@ -38886,7 +38886,7 @@ bool ecs_query_changed(
     }
 
     ecs_poly_assert(query, ecs_query_t);
-    ecs_check(!(query->flags & EcsQueryIsOrphaned), 
+    ecs_check(!(query->flags & EcsQueryIsOrphaned),
         ECS_INVALID_PARAMETER, NULL);
 
     if (!(query->flags & EcsQueryHasMonitor)) {
@@ -38943,7 +38943,7 @@ int ids_compare(const void *ptr_1, const void *ptr_2) {
 
     const ecs_id_t *ids_1 = type_1->array;
     const ecs_id_t *ids_2 = type_2->array;
-    
+
     int32_t i;
     for (i = 0; i < count_1; i ++) {
         ecs_id_t id_1 = ids_1[i];
@@ -39102,7 +39102,7 @@ void init_flags(
 {
     ecs_id_t *ids = ecs_vector_first(table->type, ecs_id_t);
     int32_t count = ecs_vector_count(table->type);
-    
+
     /* Iterate components to initialize table flags */
     int32_t i;
     for (i = 0; i < count; i ++) {
@@ -39110,7 +39110,7 @@ void init_flags(
 
         /* As we're iterating over the table components, also set the table
          * flags. These allow us to quickly determine if the table contains
-         * data that needs to be handled in a special way, like prefabs or 
+         * data that needs to be handled in a special way, like prefabs or
          * containers */
         if (id <= EcsLastInternalComponentId) {
             table->flags |= EcsTableHasBuiltins;
@@ -39160,15 +39160,15 @@ void init_flags(
             ecs_poly_assert(world, ecs_world_t);
             ecs_entity_t obj = ecs_pair_object(world, id);
 
-            if (obj == EcsFlecs || obj == EcsFlecsCore || 
-                ecs_has_id(world, obj, EcsModule)) 
+            if (obj == EcsFlecs || obj == EcsFlecsCore ||
+                ecs_has_id(world, obj, EcsModule))
             {
                 /* If table contains entities that are inside one of the builtin
                  * modules, it contains builtin entities */
                 table->flags |= EcsTableHasBuiltins;
                 table->flags |= EcsTableHasModule;
             }
-        }      
+        }
     }
 }
 
@@ -39197,7 +39197,7 @@ void init_table(
     /* Register component info flags for all columns */
     flecs_table_notify(world, table, &(ecs_table_event_t){
         .kind = EcsTableComponentInfo
-    });    
+    });
 }
 
 static
@@ -39348,7 +39348,7 @@ void ids_append(
     ecs_id_t id)
 {
     ids->array = ecs_os_realloc_n(ids->array, ecs_id_t, ids->count + 1);
-    ids->array[ids->count ++] = id;   
+    ids->array[ids->count ++] = id;
 }
 
 static
@@ -39420,7 +39420,7 @@ void diff_insert_added_isa(
     ecs_id_t id)
 {
     ecs_table_diff_t base_diff;
-    diff_insert_isa(world, table, &base_diff, &diff->on_set, 
+    diff_insert_isa(world, table, &base_diff, &diff->on_set,
         &base_diff.un_set, id);
 }
 
@@ -39432,7 +39432,7 @@ void diff_insert_removed_isa(
     ecs_id_t id)
 {
     ecs_table_diff_t base_diff;
-    diff_insert_isa(world, table, &base_diff, &diff->un_set, 
+    diff_insert_isa(world, table, &base_diff, &diff->un_set,
         &base_diff.un_set, id);
 }
 
@@ -39509,7 +39509,7 @@ void compute_table_diff(
     int32_t i_next = 0, next_count = ecs_vector_count(next_type);
     int32_t added_count = 0;
     int32_t removed_count = 0;
-    bool trivial_edge = !ECS_HAS_RELATION(id, EcsIsA) && 
+    bool trivial_edge = !ECS_HAS_RELATION(id, EcsIsA) &&
         !(node->flags & EcsTableHasIsA) && !(next->flags & EcsTableHasIsA);
 
     /* First do a scan to see how big the diff is, so we don't have to realloc
@@ -39596,8 +39596,8 @@ void add_with_ids_to_ids(
     if (!id_table) {
         return;
     }
-    
-    ecs_table_record_t *tr = flecs_get_table_record(world, id_table, 
+
+    ecs_table_record_t *tr = flecs_get_table_record(world, id_table,
         ecs_pair(EcsWith, EcsWildcard));
     if (tr) {
         int32_t i, with_count = tr->count;
@@ -39606,7 +39606,7 @@ void add_with_ids_to_ids(
         ecs_id_t *id_ids = ecs_vector_first(id_table->type, ecs_id_t);
 
         for (i = start; i < end; i ++) {
-            ecs_assert(ECS_PAIR_RELATION(id_ids[i]) == EcsWith, 
+            ecs_assert(ECS_PAIR_RELATION(id_ids[i]) == EcsWith,
                 ECS_INTERNAL_ERROR, NULL);
             ecs_id_t id_r = ECS_PAIR_OBJECT(id_ids[i]);
             ecs_id_t id = id_r;
@@ -39631,7 +39631,7 @@ ecs_table_t* find_or_create_table_with_id(
 {
     /* If table has one or more switches and this is a case, return self */
     if (ECS_HAS_ROLE(id, CASE)) {
-        ecs_assert((node->flags & EcsTableHasSwitch) != 0, 
+        ecs_assert((node->flags & EcsTableHasSwitch) != 0,
             ECS_TYPE_INVALID_CASE, NULL);
         return node;
     } else {
@@ -39672,7 +39672,7 @@ ecs_table_t* find_or_create_table_without_id(
 {
     /* If table has one or more switches and this is a case, return self */
     if (ECS_HAS_ROLE(id, CASE)) {
-        ecs_assert((node->flags & EcsTableHasSwitch) != 0, 
+        ecs_assert((node->flags & EcsTableHasSwitch) != 0,
             ECS_TYPE_INVALID_CASE, NULL);
         return node;
     } else {
@@ -39739,7 +39739,7 @@ ecs_table_t* find_or_create_table_without(
         flecs_register_remove_ref(world, node, id);
     }
 
-    return next;   
+    return next;
 }
 
 static
@@ -39769,7 +39769,7 @@ ecs_table_t* find_or_create_table_with(
 
 static
 void populate_diff(
-    ecs_table_t *table, 
+    ecs_table_t *table,
     ecs_edge_t *edge,
     ecs_id_t *add_ptr,
     ecs_id_t *remove_ptr,
@@ -39778,9 +39778,9 @@ void populate_diff(
     if (out) {
         int32_t di = edge->diff_index;
         if (di > 0) {
-            ecs_assert(!add_ptr || !ECS_HAS_ROLE(add_ptr[0], CASE), 
+            ecs_assert(!add_ptr || !ECS_HAS_ROLE(add_ptr[0], CASE),
                 ECS_INTERNAL_ERROR, NULL);
-            ecs_assert(!remove_ptr || !ECS_HAS_ROLE(remove_ptr[0], CASE), 
+            ecs_assert(!remove_ptr || !ECS_HAS_ROLE(remove_ptr[0], CASE),
                 ECS_INTERNAL_ERROR, NULL);
             *out = ecs_vector_first(table->node.diffs, ecs_table_diff_t)[di - 1];
         } else {
@@ -39888,7 +39888,7 @@ bool ecs_entity_array_is_ordered(
             return false;
         }
         prev = array[i];
-    }    
+    }
 
     return true;
 }
@@ -39918,8 +39918,8 @@ static
 ecs_table_t* find_or_create(
     ecs_world_t *world,
     const ecs_ids_t *ids)
-{    
-    ecs_poly_assert(world, ecs_world_t);   
+{
+    ecs_poly_assert(world, ecs_world_t);
 
     /* Make sure array is ordered and does not contain duplicates */
     int32_t id_count = ids->count;
@@ -39938,9 +39938,9 @@ ecs_table_t* find_or_create(
 
         ordered = world->store.id_cache.array;
         ecs_os_memcpy_n(ordered, ids->array, ecs_id_t, id_count);
-        qsort(ordered, (size_t)id_count, sizeof(ecs_entity_t), 
+        qsort(ordered, (size_t)id_count, sizeof(ecs_entity_t),
             flecs_entity_compare_qsort);
-        id_count = ecs_entity_array_dedup(ordered, id_count);  
+        id_count = ecs_entity_array_dedup(ordered, id_count);
     } else {
         ordered = ids->array;
     }
@@ -39963,8 +39963,8 @@ ecs_table_t* find_or_create(
 
     /* If we get here, the table has not been found, so create it. */
     ecs_table_t *result = create_table(world, &ordered_ids, elem);
-    
-    ecs_assert(ordered_ids.count == ecs_vector_count(result->type), 
+
+    ecs_assert(ordered_ids.count == ecs_vector_count(result->type),
         ECS_INTERNAL_ERROR, NULL);
 
     return result;
@@ -39974,14 +39974,14 @@ ecs_table_t* flecs_table_find_or_create(
     ecs_world_t *world,
     const ecs_ids_t *ids)
 {
-    ecs_poly_assert(world, ecs_world_t);   
+    ecs_poly_assert(world, ecs_world_t);
     return find_or_create(world, ids);
 }
 
 void flecs_init_root_table(
     ecs_world_t *world)
 {
-    ecs_poly_assert(world, ecs_world_t);   
+    ecs_poly_assert(world, ecs_world_t);
 
     ecs_ids_t entities = {
         .array = NULL,
@@ -40086,7 +40086,7 @@ ecs_table_t* ecs_table_remove_id(
         if (it->priv.cache.f##_alloc) {\
             ecs_os_free((void*)it->f);\
         }\
-    }   
+    }
 
 void flecs_iter_init(
     ecs_iter_t *it)
@@ -40095,7 +40095,7 @@ void flecs_iter_init(
     INIT_CACHE(it, subjects, it->term_count);
     INIT_CACHE(it, match_indices, it->term_count);
     INIT_CACHE(it, columns, it->term_count);
-    
+
     if (!it->is_filter) {
         INIT_CACHE(it, sizes, it->term_count);
         INIT_CACHE(it, ptrs, it->term_count);
@@ -40190,7 +40190,7 @@ bool flecs_iter_populate_term_data(
 
             if (!s_table || !(tr = flecs_get_table_record(world, s_table, id))){
                 /* The entity has no components or the id is not a component */
-                
+
                 ecs_id_t term_id = it->terms[t].id;
                 if (ECS_HAS_ROLE(term_id, SWITCH) || ECS_HAS_ROLE(term_id, CASE)) {
                     /* Edge case: if this is a switch. Find switch column in
@@ -40221,7 +40221,7 @@ bool flecs_iter_populate_term_data(
         }
 
         row = it->offset;
-        
+
         int32_t storage_column = ecs_table_type_to_storage_index(
             table, column - 1);
         if (storage_column == -1) {
@@ -40303,7 +40303,7 @@ void flecs_iter_populate_data(
         for (t = 0; t < term_count; t ++) {
             int32_t column = it->columns[t];
             has_shared |= flecs_iter_populate_term_data(world, it, t, column,
-                &ptrs[t], 
+                &ptrs[t],
                 &sizes[t]);
         }
     } else {
@@ -40381,8 +40381,8 @@ void* ecs_term_w_size(
     int32_t term)
 {
     ecs_check(it->is_valid, ECS_INVALID_PARAMETER, NULL);
-    ecs_check(!size || ecs_term_size(it, term) == size || 
-        (!ecs_term_size(it, term) && (!it->ptrs || !it->ptrs[term - 1])), 
+    ecs_check(!size || ecs_term_size(it, term) == size ||
+        (!ecs_term_size(it, term) && (!it->ptrs || !it->ptrs[term - 1])),
         ECS_INVALID_PARAMETER, NULL);
 
     (void)size;
@@ -40409,7 +40409,7 @@ bool ecs_term_is_readonly(
 
     ecs_term_t *term = &it->terms[term_index - 1];
     ecs_check(term != NULL, ECS_INVALID_PARAMETER, NULL);
-    
+
     if (term->inout == EcsIn) {
         return true;
     } else {
@@ -40473,7 +40473,7 @@ void* ecs_iter_column_w_size(
     ecs_check(it->is_valid, ECS_INVALID_PARAMETER, NULL);
     ecs_check(it->table != NULL, ECS_INVALID_PARAMETER, NULL);
     (void)size;
-    
+
     ecs_table_t *table = it->table;
     int32_t storage_index = ecs_table_type_to_storage_index(table, index);
     if (storage_index == -1) {
@@ -40482,7 +40482,7 @@ void* ecs_iter_column_w_size(
 
     ecs_column_t *columns = table->storage.columns;
     ecs_column_t *column = &columns[storage_index];
-    ecs_check(!size || (ecs_size_t)size == column->size, 
+    ecs_check(!size || (ecs_size_t)size == column->size,
         ECS_INVALID_PARAMETER, NULL);
 
     void *ptr = ecs_vector_first_t(
@@ -40499,7 +40499,7 @@ size_t ecs_iter_column_size(
 {
     ecs_check(it->is_valid, ECS_INVALID_PARAMETER, NULL);
     ecs_check(it->table != NULL, ECS_INVALID_PARAMETER, NULL);
-    
+
     ecs_table_t *table = it->table;
     int32_t storage_index = ecs_table_type_to_storage_index(table, index);
     if (storage_index == -1) {
@@ -40508,7 +40508,7 @@ size_t ecs_iter_column_size(
 
     ecs_column_t *columns = table->storage.columns;
     ecs_column_t *column = &columns[storage_index];
-    
+
     return flecs_ito(size_t, column->size);
 error:
     return 0;
@@ -40682,7 +40682,7 @@ bool ecs_page_next_instanced(
         }
 
         ecs_page_iter_t *iter = &it->priv.iter.page;
-        
+
         /* Copy everything up to the private iterator data */
         ecs_os_memcpy(it, chain_it, offsetof(ecs_iter_t, priv));
         it->is_instanced = instanced;
@@ -40875,7 +40875,7 @@ error:
 
 static
 int32_t count_events(
-    const ecs_entity_t *events) 
+    const ecs_entity_t *events)
 {
     int32_t i;
 
@@ -40890,7 +40890,7 @@ int32_t count_events(
 
 static
 ecs_entity_t get_actual_event(
-    ecs_trigger_t *trigger, 
+    ecs_trigger_t *trigger,
     ecs_entity_t event)
 {
     /* If operator is Not, reverse the event */
@@ -40927,10 +40927,10 @@ void inc_trigger_count(
     ecs_event_id_record_t *idt = ecs_map_ensure(
         evt->event_ids, ecs_event_id_record_t, id);
     ecs_assert(idt != NULL, ECS_INTERNAL_ERROR, NULL);
-    
+
     int32_t result = idt->trigger_count += value;
     if (result == 1) {
-        /* Notify framework that there are triggers for the event/id. This 
+        /* Notify framework that there are triggers for the event/id. This
          * allows parts of the code to skip event evaluation early */
         flecs_notify_tables(world, id, &(ecs_table_event_t){
             .kind = EcsTableTriggersForId,
@@ -41004,7 +41004,7 @@ void register_trigger(
 
     if (term->subj.set.mask & EcsSelf) {
         if (term->subj.entity == EcsThis) {
-            register_trigger_for_id(world, observable, trigger, term->id, 
+            register_trigger_for_id(world, observable, trigger, term->id,
                 offsetof(ecs_event_id_record_t, triggers));
         } else {
             register_trigger_for_id(world, observable, trigger, term->id,
@@ -41021,13 +41021,13 @@ void register_trigger(
     if (ECS_HAS_ROLE(term->id, SWITCH)) {
         ecs_entity_t sw = term->id & ECS_COMPONENT_MASK;
         ecs_id_t sw_case = ecs_case(sw, EcsWildcard);
-        register_trigger_for_id(world, observable, trigger, sw_case, 
+        register_trigger_for_id(world, observable, trigger, sw_case,
             offsetof(ecs_event_id_record_t, triggers));
     }
 
     if (ECS_HAS_ROLE(term->id, CASE)) {
         ecs_entity_t sw = ECS_PAIR_RELATION(term->id);
-        register_trigger_for_id(world, observable, trigger, ECS_SWITCH | sw, 
+        register_trigger_for_id(world, observable, trigger, ECS_SWITCH | sw,
             offsetof(ecs_event_id_record_t, triggers));
     }
 }
@@ -41084,12 +41084,12 @@ void unregister_trigger(
     ecs_world_t *world,
     ecs_observable_t *observable,
     ecs_trigger_t *trigger)
-{    
+{
     ecs_term_t *term = &trigger->term;
 
     if (term->subj.set.mask & EcsSelf) {
         if (term->subj.entity == EcsThis) {
-            unregister_trigger_for_id(world, observable, trigger, term->id, 
+            unregister_trigger_for_id(world, observable, trigger, term->id,
                 offsetof(ecs_event_id_record_t, triggers));
         } else {
             unregister_trigger_for_id(world, observable, trigger, term->id,
@@ -41106,13 +41106,13 @@ void unregister_trigger(
     if (ECS_HAS_ROLE(term->id, SWITCH)) {
         ecs_entity_t sw = term->id & ECS_COMPONENT_MASK;
         ecs_id_t sw_case = ecs_case(sw, EcsWildcard);
-        unregister_trigger_for_id(world, observable, trigger, sw_case, 
+        unregister_trigger_for_id(world, observable, trigger, sw_case,
             offsetof(ecs_event_id_record_t, triggers));
     }
 
     if (ECS_HAS_ROLE(term->id, CASE)) {
         ecs_entity_t sw = ECS_PAIR_RELATION(term->id);
-        unregister_trigger_for_id(world, observable, trigger, ECS_SWITCH | sw, 
+        unregister_trigger_for_id(world, observable, trigger, ECS_SWITCH | sw,
             offsetof(ecs_event_id_record_t, triggers));
     }
 }
@@ -41130,7 +41130,7 @@ ecs_map_t* get_triggers_for_event(
 
     const ecs_event_record_t *evt = flecs_sparse_get(
         events, ecs_event_record_t, event);
-    
+
     if (evt) {
         return evt->event_ids;
     }
@@ -41151,7 +41151,7 @@ bool flecs_check_triggers_for_event(
     const ecs_poly_t *object,
     ecs_id_t id,
     ecs_entity_t event)
-{    
+{
     ecs_observable_t *observable = ecs_get_observable(object);
     const ecs_map_t *evt = get_triggers_for_event(observable, event);
     if (!evt) {
@@ -41172,7 +41172,7 @@ void init_iter(
     bool *iter_set)
 {
     ecs_assert(it != NULL, ECS_INTERNAL_ERROR, NULL);
-    
+
     if (*iter_set) {
         return;
     }
@@ -41191,14 +41191,14 @@ void init_iter(
 
     ecs_assert(it->table != NULL, ECS_INTERNAL_ERROR, NULL);
     ecs_assert(!it->world->is_readonly, ECS_INTERNAL_ERROR, NULL);
-    ecs_assert(!it->count || it->offset < ecs_table_count(it->table), 
+    ecs_assert(!it->count || it->offset < ecs_table_count(it->table),
         ECS_INTERNAL_ERROR, NULL);
-    ecs_assert((it->offset + it->count) <= ecs_table_count(it->table), 
+    ecs_assert((it->offset + it->count) <= ecs_table_count(it->table),
         ECS_INTERNAL_ERROR, NULL);
 
-    int32_t index = ecs_search_relation(it->world, it->table, 0, 
+    int32_t index = ecs_search_relation(it->world, it->table, 0,
         it->event_id, EcsIsA, 0, 0, it->subjects, NULL, NULL);
-    
+
     if (index == -1) {
         it->columns[0] = 0;
     } else if (it->subjects[0]) {
@@ -41213,7 +41213,7 @@ void init_iter(
 
     it->terms = &term;
     it->term_count = 1;
-    flecs_iter_populate_data(it->world, it, it->table, it->offset, 
+    flecs_iter_populate_data(it->world, it, it->table, it->offset,
         it->count, it->ptrs, it->sizes);
 }
 
@@ -41238,7 +41238,7 @@ bool ignore_trigger(
     if (!t->match_disabled && (table->flags & EcsTableIsDisabled)) {
         return true;
     }
-    
+
     return false;
 }
 
@@ -41285,7 +41285,7 @@ void notify_entity_triggers(
     ecs_trigger_t *t;
     int32_t offset = it->offset, count = it->count;
     ecs_entity_t *entities = it->entities;
-    
+
     ecs_entity_t dummy = 0;
     it->entities = &dummy;
 
@@ -41347,9 +41347,9 @@ void notify_set_base_triggers(
 
         ecs_term_t *term = &t->term;
         ecs_id_t id = term->id;
-        int32_t column = ecs_search_relation(world, obj_table, 0, id, rel, 
+        int32_t column = ecs_search_relation(world, obj_table, 0, id, rel,
             0, 0, it->subjects, it->ids, 0);
-        
+
         bool result = column != -1;
         if (term->oper == EcsNot) {
             result = !result;
@@ -41359,7 +41359,7 @@ void notify_set_base_triggers(
         }
 
         if (!term->subj.set.min_depth && flecs_get_table_record(
-            world, it->table, id) != NULL) 
+            world, it->table, id) != NULL)
         {
             continue;
         }
@@ -41384,7 +41384,7 @@ void notify_set_base_triggers(
         it->binding_ctx = t->binding_ctx;
         it->term_index = t->term.index;
         it->terms = &t->term;
-        
+
         t->action(it);
     }
 }
@@ -41435,7 +41435,7 @@ void notify_set_triggers(
             it->count = 1;
         }
 
-        if (flecs_term_match_table(world, &t->term, it->table, it->type, 
+        if (flecs_term_match_table(world, &t->term, it->table, it->type,
             it->ids, it->columns, it->subjects, NULL, true))
         {
             if (!it->subjects[0]) {
@@ -41474,7 +41474,7 @@ void notify_set_triggers(
         }
 
         it->entities[0] = subj;
-        it->count = count;            
+        it->count = count;
     }
 }
 
@@ -41592,7 +41592,7 @@ void flecs_triggers_notify(
 
                 tid = role | ecs_entity_t_comb(obj, EcsWildcard);
                 notify_triggers_for_id(world, evt, tid, it, &iter_set);
-                
+
                 tid = role | ecs_entity_t_comb(EcsWildcard, EcsWildcard);
                 notify_triggers_for_id(world, evt, tid, it, &iter_set);
             } else {
@@ -41641,7 +41641,7 @@ ecs_entity_t ecs_trigger_init(
     const ecs_trigger_desc_t *desc)
 {
     char *name = NULL;
-    
+
     ecs_poly_assert(world, ecs_world_t);
     ecs_check(!world->is_readonly, ECS_INVALID_OPERATION, NULL);
     ecs_check(desc != NULL, ECS_INVALID_PARAMETER, NULL);
@@ -41650,7 +41650,7 @@ ecs_entity_t ecs_trigger_init(
 
     const char *expr = desc->expr;
     ecs_trigger_t *trigger = NULL;
-    
+
     ecs_observable_t *observable = desc->observable;
     if (!observable) {
         observable = ecs_get_observable(world);
@@ -41667,7 +41667,7 @@ ecs_entity_t ecs_trigger_init(
     EcsTrigger *comp = ecs_get_mut(world, entity, EcsTrigger, &added);
     if (added) {
         ecs_check(desc->callback != NULL, ECS_INVALID_PARAMETER, NULL);
-        
+
         /* Something went wrong with the construction of the entity */
         ecs_check(entity != 0, ECS_INVALID_PARAMETER, NULL);
         name = ecs_get_fullpath(world, entity);
@@ -41687,7 +41687,7 @@ ecs_entity_t ecs_trigger_init(
             }
 
             if (ptr[0]) {
-                ecs_parser_error(name, expr, 0, 
+                ecs_parser_error(name, expr, 0,
                     "too many terms in trigger expression (expected 1)");
                 goto error;
             }
@@ -41713,7 +41713,7 @@ ecs_entity_t ecs_trigger_init(
         trigger->ctx_free = desc->ctx_free;
         trigger->binding_ctx_free = desc->binding_ctx_free;
         trigger->event_count = count_events(desc->events);
-        ecs_os_memcpy(trigger->events, desc->events, 
+        ecs_os_memcpy(trigger->events, desc->events,
             trigger->event_count * ECS_SIZEOF(ecs_entity_t));
         trigger->entity = entity;
         trigger->self = desc->self;
@@ -41740,7 +41740,7 @@ ecs_entity_t ecs_trigger_init(
         ecs_term_fini(&term);
 
         if (desc->entity.name) {
-            ecs_trace("#[green]trigger#[reset] %s created", 
+            ecs_trace("#[green]trigger#[reset] %s created",
                 ecs_get_name(world, entity));
         }
 
@@ -41781,7 +41781,7 @@ void* ecs_get_trigger_ctx(
         return t->trigger->ctx;
     } else {
         return NULL;
-    }     
+    }
 }
 
 void* ecs_get_trigger_binding_ctx(
@@ -41793,13 +41793,13 @@ void* ecs_get_trigger_binding_ctx(
         return t->trigger->binding_ctx;
     } else {
         return NULL;
-    }      
+    }
 }
 
 void flecs_trigger_fini(
     ecs_world_t *world,
     ecs_trigger_t *trigger)
-{    
+{
     unregister_trigger(world, trigger->observable, trigger);
     ecs_term_fini(&trigger->term);
 
@@ -41817,11 +41817,11 @@ void flecs_trigger_fini(
 #include <time.h>
 
 #ifndef NDEBUG
-static int64_t s_min[] = { 
+static int64_t s_min[] = {
     [1] = INT8_MIN, [2] = INT16_MIN, [4] = INT32_MIN, [8] = INT64_MIN };
-static int64_t s_max[] = { 
+static int64_t s_max[] = {
     [1] = INT8_MAX, [2] = INT16_MAX, [4] = INT32_MAX, [8] = INT64_MAX };
-static uint64_t u_max[] = { 
+static uint64_t u_max[] = {
     [1] = UINT8_MAX, [2] = UINT16_MAX, [4] = UINT32_MAX, [8] = UINT64_MAX };
 
 uint64_t _flecs_ito(
@@ -41912,24 +41912,24 @@ double ecs_time_measure(
 }
 
 void* ecs_os_memdup(
-    const void *src, 
-    ecs_size_t size) 
+    const void *src,
+    ecs_size_t size)
 {
     if (!src) {
         return NULL;
     }
-        
+
     void *dst = ecs_os_malloc(size);
     ecs_assert(dst != NULL, ECS_OUT_OF_MEMORY, NULL);
-    ecs_os_memcpy(dst, src, size);  
-    return dst;  
+    ecs_os_memcpy(dst, src, size);
+    return dst;
 }
 
 int flecs_entity_compare(
-    ecs_entity_t e1, 
-    const void *ptr1, 
-    ecs_entity_t e2, 
-    const void *ptr2) 
+    ecs_entity_t e1,
+    const void *ptr1,
+    ecs_entity_t e2,
+    const void *ptr2)
 {
     (void)ptr1;
     (void)ptr2;
@@ -41954,8 +41954,8 @@ uint64_t flecs_string_hash(
 }
 
 /*
-    This code was taken from sokol_time.h 
-    
+    This code was taken from sokol_time.h
+
     zlib/libpng license
     Copyright (c) 2018 Andre Weissflog
     This software is provided 'as-is', without any express or implied warranty.
@@ -41985,7 +41985,7 @@ static ECS_CTOR(EcsIdentifier, ptr, {
 })
 
 static ECS_DTOR(EcsIdentifier, ptr, {
-    ecs_os_strset(&ptr->value, NULL);    
+    ecs_os_strset(&ptr->value, NULL);
 })
 
 static ECS_COPY(EcsIdentifier, dst, src, {
@@ -42009,7 +42009,7 @@ static ECS_MOVE(EcsIdentifier, dst, src, {
 static
 void ecs_on_set(EcsIdentifier)(ecs_iter_t *it) {
     EcsIdentifier *ptr = ecs_term(it, EcsIdentifier, 1);
-    
+
     for (int i = 0; i < it->count; i ++) {
         EcsIdentifier *cur = &ptr[i];
         if (cur->value) {
@@ -42075,7 +42075,7 @@ static
 void register_on_delete(ecs_iter_t *it) {
     ecs_world_t *world = it->world;
     ecs_id_t id = ecs_term_id(it, 1);
-    
+
     int i, count = it->count;
     for (i = 0; i < count; i ++) {
         ecs_entity_t e = it->entities[i];
@@ -42104,7 +42104,7 @@ void register_on_delete_object(ecs_iter_t *it) {
         r->on_delete_object = ECS_PAIR_OBJECT(id);
 
         flecs_add_flag(world, e, ECS_FLAG_OBSERVED_ID);
-    }    
+    }
 }
 
 static
@@ -42119,17 +42119,17 @@ void on_symmetric_add_remove(ecs_iter_t *it) {
     ecs_entity_t rel = ECS_PAIR_RELATION(pair);
     ecs_entity_t obj = ECS_PAIR_OBJECT(pair);
     ecs_entity_t event = it->event;
-    
+
     int i, count = it->count;
     for (i = 0; i < count; i ++) {
         ecs_entity_t subj = it->entities[i];
         if (event == EcsOnAdd) {
             if (!ecs_has_id(it->real_world, obj, ecs_pair(rel, subj))) {
-                ecs_add_pair(it->world, obj, rel, subj);   
+                ecs_add_pair(it->world, obj, rel, subj);
             }
         } else {
             if (ecs_has_id(it->real_world, obj, ecs_pair(rel, subj))) {
-                ecs_remove_pair(it->world, obj, rel, subj);   
+                ecs_remove_pair(it->world, obj, rel, subj);
             }
         }
     }
@@ -42150,7 +42150,7 @@ void register_symmetric(ecs_iter_t *it) {
             .callback = on_symmetric_add_remove,
             .events = {EcsOnAdd, EcsOnRemove}
         });
-    } 
+    }
 }
 
 static
@@ -42161,7 +42161,7 @@ void on_set_component_lifecycle(ecs_iter_t *it) {
     int i, count = it->count;
     for (i = 0; i < count; i ++) {
         ecs_entity_t e = it->entities[i];
-        ecs_set_component_actions_w_id(world, e, &cl[i]);   
+        ecs_set_component_actions_w_id(world, e, &cl[i]);
     }
 }
 
@@ -42218,7 +42218,7 @@ void _bootstrap_component(
     ecs_record_t *record = ecs_eis_ensure(world, entity);
     record->table = table;
 
-    int32_t index = flecs_table_append(world, table, &table->storage, 
+    int32_t index = flecs_table_append(world, table, &table->storage,
         entity, record, false);
     record->row = ECS_ROW_TO_RECORD(index, 0);
 
@@ -42238,7 +42238,7 @@ void _bootstrap_component(
     EcsIdentifier *symbol_col = ecs_vector_first(columns[2].data, EcsIdentifier);
     symbol_col[index].value = ecs_os_strdup(symbol);
     symbol_col[index].length = symbol_length;
-    symbol_col[index].hash = flecs_hash(symbol, symbol_length);    
+    symbol_col[index].hash = flecs_hash(symbol, symbol_length);
 }
 
 /** Create type for component */
@@ -42259,7 +42259,7 @@ ecs_type_t flecs_bootstrap_type(
 
 /** Initialize component table. This table is manually constructed to bootstrap
  * flecs. After this function has been called, the builtin components can be
- * created. 
+ * created.
  * The reason this table is constructed manually is because it requires the size
  * and alignment of the EcsComponent and EcsIdentifier components, which haven't
  * been created yet */
@@ -42268,12 +42268,12 @@ ecs_table_t* bootstrap_component_table(
     ecs_world_t *world)
 {
     ecs_id_t entities[] = {
-        ecs_id(EcsComponent), 
+        ecs_id(EcsComponent),
         ecs_pair(ecs_id(EcsIdentifier), EcsName),
         ecs_pair(ecs_id(EcsIdentifier), EcsSymbol),
         ecs_pair(EcsChildOf, EcsFlecsCore)
     };
-    
+
     ecs_ids_t array = {
         .array = entities,
         .count = 4
@@ -42289,7 +42289,7 @@ ecs_table_t* bootstrap_component_table(
     data->columns[0].data = ecs_vector_new(EcsComponent, EcsFirstUserComponentId);
     data->columns[1].data = ecs_vector_new(EcsIdentifier, EcsFirstUserComponentId);
     data->columns[2].data = ecs_vector_new(EcsIdentifier, EcsFirstUserComponentId);
-    
+
     return result;
 }
 
@@ -42311,7 +42311,7 @@ void bootstrap_entity(
     ecs_add_pair(world, id, EcsChildOf, parent);
 
     if (!parent || parent == EcsFlecsCore) {
-        ecs_assert(ecs_lookup_fullpath(world, name) == id, 
+        ecs_assert(ecs_lookup_fullpath(world, name) == id,
             ECS_INTERNAL_ERROR, NULL);
     }
 }
@@ -42352,14 +42352,14 @@ void flecs_bootstrap(
         .dtor = ecs_dtor(EcsTrigger),
         .copy = ecs_copy(EcsTrigger),
         .move = ecs_move(EcsTrigger)
-    }); 
+    });
 
     ecs_set_component_actions(world, EcsObserver, {
         .ctor = ecs_ctor(EcsObserver),
         .dtor = ecs_dtor(EcsObserver),
         .copy = ecs_copy(EcsObserver),
         .move = ecs_move(EcsObserver)
-    });            
+    });
 
     world->stats.last_component_id = EcsFirstUserComponentId;
     world->stats.last_id = EcsFirstUserEntityId;
@@ -42511,10 +42511,10 @@ void flecs_bootstrap(
         .term = {.id = ecs_id(EcsComponentLifecycle)},
         .callback = on_set_component_lifecycle,
         .events = {EcsOnSet}
-    });  
+    });
 
     /* Removal of ChildOf objects (parents) deletes the subject (child) */
-    ecs_add_pair(world, EcsChildOf, EcsOnDeleteObject, EcsDelete);  
+    ecs_add_pair(world, EcsChildOf, EcsOnDeleteObject, EcsDelete);
 
     /* Run bootstrap functions for other parts of the code */
     flecs_bootstrap_hierarchy(world);
@@ -42531,9 +42531,9 @@ void flecs_bootstrap(
 
 static
 bool path_append(
-    const ecs_world_t *world, 
-    ecs_entity_t parent, 
-    ecs_entity_t child, 
+    const ecs_world_t *world,
+    ecs_entity_t parent,
+    ecs_entity_t child,
     const char *sep,
     const char *prefix,
     ecs_strbuf_t *buf)
@@ -42559,7 +42559,7 @@ bool path_append(
         if (!name || !ecs_os_strlen(name)) {
             ecs_os_sprintf(buff, "%u", (uint32_t)child);
             name = buff;
-        }        
+        }
     } else {
         ecs_os_sprintf(buff, "%u", (uint32_t)child);
         name = buff;
@@ -42575,7 +42575,7 @@ ecs_hashed_string_t ecs_get_hashed_string(
     ecs_size_t length,
     uint64_t hash)
 {
-    ecs_assert(!length || length == ecs_os_strlen(name), 
+    ecs_assert(!length || length == ecs_os_strlen(name),
         ECS_INTERNAL_ERROR, NULL);
 
     if (!length) {
@@ -42626,11 +42626,11 @@ void register_by_name(
     ecs_check(name != NULL, ECS_INVALID_PARAMETER, NULL);
 
     ecs_hashed_string_t key = ecs_get_hashed_string(name, length, hash);
-    
+
     ecs_entity_t existing = find_by_name(map, name, key.length, key.hash);
     if (existing) {
         if (existing != entity) {
-            ecs_abort(ECS_ALREADY_DEFINED, 
+            ecs_abort(ECS_ALREADY_DEFINED,
                 "conflicting entity registered with name '%s'", name);
         }
     } else {
@@ -42650,7 +42650,7 @@ bool is_number(
     const char *name)
 {
     ecs_assert(name != NULL, ECS_INTERNAL_ERROR, NULL);
-    
+
     if (!isdigit(name[0])) {
         return false;
     }
@@ -42667,7 +42667,7 @@ bool is_number(
     return i >= length;
 }
 
-static 
+static
 ecs_entity_t name_to_id(
     const ecs_world_t *world,
     const char *name)
@@ -42762,7 +42762,7 @@ ecs_entity_t get_parent_from_path(
 {
     bool start_from_root = false;
     const char *path = *path_ptr;
-   
+
     if (prefix) {
         ecs_size_t len = ecs_os_strlen(prefix);
         if (!ecs_os_strncmp(path, prefix, len)) {
@@ -42805,7 +42805,7 @@ uint64_t string_hash(
 
 static
 int string_compare(
-    const void *ptr1, 
+    const void *ptr1,
     const void *ptr2)
 {
     const ecs_hashed_string_t *str1 = ptr1;
@@ -42820,8 +42820,8 @@ int string_compare(
 }
 
 ecs_hashmap_t _flecs_string_hashmap_new(ecs_size_t size) {
-    return _flecs_hashmap_new(ECS_SIZEOF(ecs_hashed_string_t), size, 
-        string_hash, 
+    return _flecs_hashmap_new(ECS_SIZEOF(ecs_hashed_string_t), size,
+        string_hash,
         string_compare);
 }
 
@@ -42922,7 +42922,7 @@ error:
 ecs_entity_t ecs_lookup(
     const ecs_world_t *world,
     const char *name)
-{   
+{
     if (!name) {
         return 0;
     }
@@ -42942,8 +42942,8 @@ ecs_entity_t ecs_lookup(
     e = find_by_name(&world->aliases, name, 0, 0);
     if (e) {
         return e;
-    }    
-    
+    }
+
     return ecs_lookup_child(world, 0, name);
 error:
     return 0;
@@ -42953,7 +42953,7 @@ ecs_entity_t ecs_lookup_symbol(
     const ecs_world_t *world,
     const char *name,
     bool lookup_as_path)
-{   
+{
     if (!name) {
         return 0;
     }
@@ -43001,7 +43001,7 @@ ecs_entity_t ecs_lookup_path_w_sep(
     e = find_by_name(&world->aliases, path, 0, 0);
     if (e) {
         return e;
-    }      
+    }
 
     char buff[ECS_NAME_BUFFER_LENGTH];
     const char *ptr, *ptr_start;
@@ -43119,7 +43119,7 @@ ecs_entity_t ecs_add_path_w_sep(
 
     if (!sep) {
         sep = ".";
-    }    
+    }
 
     if (!path) {
         if (!entity) {
@@ -43155,7 +43155,7 @@ ecs_entity_t ecs_add_path_w_sep(
 
             elem = ecs_os_realloc(elem, len + 1);
             ecs_os_memcpy(elem, ptr_start, len);
-            size = len + 1;          
+            size = len + 1;
         }
 
         elem[len] = '\0';
